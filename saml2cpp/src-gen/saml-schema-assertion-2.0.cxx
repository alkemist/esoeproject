// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "saml-schema-assertion-2.0.hxx"

namespace saml2
{
  namespace assertion
  {
    // BaseIDAbstractType
    // 

    const BaseIDAbstractType::NameQualifier::container& BaseIDAbstractType::
    NameQualifier () const
    {
      return this->_xsd_NameQualifier_;
    }

    BaseIDAbstractType::NameQualifier::container& BaseIDAbstractType::
    NameQualifier ()
    {
      return this->_xsd_NameQualifier_;
    }

    void BaseIDAbstractType::
    NameQualifier (const NameQualifier::type& NameQualifier)
    {
      this->_xsd_NameQualifier_.set (NameQualifier);
    }

    void BaseIDAbstractType::
    NameQualifier (const NameQualifier::container& NameQualifier)
    {
      this->_xsd_NameQualifier_ = NameQualifier;
    }

    void BaseIDAbstractType::
    NameQualifier (::std::auto_ptr< NameQualifier::type > NameQualifier)
    {
      this->_xsd_NameQualifier_.set (NameQualifier);
    }

    const BaseIDAbstractType::SPNameQualifier::container& BaseIDAbstractType::
    SPNameQualifier () const
    {
      return this->_xsd_SPNameQualifier_;
    }

    BaseIDAbstractType::SPNameQualifier::container& BaseIDAbstractType::
    SPNameQualifier ()
    {
      return this->_xsd_SPNameQualifier_;
    }

    void BaseIDAbstractType::
    SPNameQualifier (const SPNameQualifier::type& SPNameQualifier)
    {
      this->_xsd_SPNameQualifier_.set (SPNameQualifier);
    }

    void BaseIDAbstractType::
    SPNameQualifier (const SPNameQualifier::container& SPNameQualifier)
    {
      this->_xsd_SPNameQualifier_ = SPNameQualifier;
    }

    void BaseIDAbstractType::
    SPNameQualifier (::std::auto_ptr< SPNameQualifier::type > SPNameQualifier)
    {
      this->_xsd_SPNameQualifier_.set (SPNameQualifier);
    }


    // NameIDType
    // 

    const NameIDType::NameQualifier::container& NameIDType::
    NameQualifier () const
    {
      return this->_xsd_NameQualifier_;
    }

    NameIDType::NameQualifier::container& NameIDType::
    NameQualifier ()
    {
      return this->_xsd_NameQualifier_;
    }

    void NameIDType::
    NameQualifier (const NameQualifier::type& NameQualifier)
    {
      this->_xsd_NameQualifier_.set (NameQualifier);
    }

    void NameIDType::
    NameQualifier (const NameQualifier::container& NameQualifier)
    {
      this->_xsd_NameQualifier_ = NameQualifier;
    }

    void NameIDType::
    NameQualifier (::std::auto_ptr< NameQualifier::type > NameQualifier)
    {
      this->_xsd_NameQualifier_.set (NameQualifier);
    }

    const NameIDType::SPNameQualifier::container& NameIDType::
    SPNameQualifier () const
    {
      return this->_xsd_SPNameQualifier_;
    }

    NameIDType::SPNameQualifier::container& NameIDType::
    SPNameQualifier ()
    {
      return this->_xsd_SPNameQualifier_;
    }

    void NameIDType::
    SPNameQualifier (const SPNameQualifier::type& SPNameQualifier)
    {
      this->_xsd_SPNameQualifier_.set (SPNameQualifier);
    }

    void NameIDType::
    SPNameQualifier (const SPNameQualifier::container& SPNameQualifier)
    {
      this->_xsd_SPNameQualifier_ = SPNameQualifier;
    }

    void NameIDType::
    SPNameQualifier (::std::auto_ptr< SPNameQualifier::type > SPNameQualifier)
    {
      this->_xsd_SPNameQualifier_.set (SPNameQualifier);
    }

    const NameIDType::Format::container& NameIDType::
    Format () const
    {
      return this->_xsd_Format_;
    }

    NameIDType::Format::container& NameIDType::
    Format ()
    {
      return this->_xsd_Format_;
    }

    void NameIDType::
    Format (const Format::type& Format)
    {
      this->_xsd_Format_.set (Format);
    }

    void NameIDType::
    Format (const Format::container& Format)
    {
      this->_xsd_Format_ = Format;
    }

    void NameIDType::
    Format (::std::auto_ptr< Format::type > Format)
    {
      this->_xsd_Format_.set (Format);
    }

    const NameIDType::SPProvidedID::container& NameIDType::
    SPProvidedID () const
    {
      return this->_xsd_SPProvidedID_;
    }

    NameIDType::SPProvidedID::container& NameIDType::
    SPProvidedID ()
    {
      return this->_xsd_SPProvidedID_;
    }

    void NameIDType::
    SPProvidedID (const SPProvidedID::type& SPProvidedID)
    {
      this->_xsd_SPProvidedID_.set (SPProvidedID);
    }

    void NameIDType::
    SPProvidedID (const SPProvidedID::container& SPProvidedID)
    {
      this->_xsd_SPProvidedID_ = SPProvidedID;
    }

    void NameIDType::
    SPProvidedID (::std::auto_ptr< SPProvidedID::type > SPProvidedID)
    {
      this->_xsd_SPProvidedID_.set (SPProvidedID);
    }


    // EncryptedElementType
    // 

    const EncryptedElementType::EncryptedData::type& EncryptedElementType::
    EncryptedData () const
    {
      return this->_xsd_EncryptedData_.get ();
    }

    EncryptedElementType::EncryptedData::type& EncryptedElementType::
    EncryptedData ()
    {
      return this->_xsd_EncryptedData_.get ();
    }

    void EncryptedElementType::
    EncryptedData (const EncryptedData::type& EncryptedData)
    {
      this->_xsd_EncryptedData_.set (EncryptedData);
    }

    void EncryptedElementType::
    EncryptedData (::std::auto_ptr< EncryptedData::type > EncryptedData)
    {
      this->_xsd_EncryptedData_.set (EncryptedData);
    }

    const EncryptedElementType::EncryptedKey::container& EncryptedElementType::
    EncryptedKey () const
    {
      return this->_xsd_EncryptedKey_;
    }

    EncryptedElementType::EncryptedKey::container& EncryptedElementType::
    EncryptedKey ()
    {
      return this->_xsd_EncryptedKey_;
    }

    void EncryptedElementType::
    EncryptedKey (const EncryptedKey::container& EncryptedKey)
    {
      this->_xsd_EncryptedKey_ = EncryptedKey;
    }


    // AssertionType
    // 

    const AssertionType::Issuer::type& AssertionType::
    Issuer () const
    {
      return this->_xsd_Issuer_.get ();
    }

    AssertionType::Issuer::type& AssertionType::
    Issuer ()
    {
      return this->_xsd_Issuer_.get ();
    }

    void AssertionType::
    Issuer (const Issuer::type& Issuer)
    {
      this->_xsd_Issuer_.set (Issuer);
    }

    void AssertionType::
    Issuer (::std::auto_ptr< Issuer::type > Issuer)
    {
      this->_xsd_Issuer_.set (Issuer);
    }

    const AssertionType::Signature::container& AssertionType::
    Signature () const
    {
      return this->_xsd_Signature_;
    }

    AssertionType::Signature::container& AssertionType::
    Signature ()
    {
      return this->_xsd_Signature_;
    }

    void AssertionType::
    Signature (const Signature::type& Signature)
    {
      this->_xsd_Signature_.set (Signature);
    }

    void AssertionType::
    Signature (const Signature::container& Signature)
    {
      this->_xsd_Signature_ = Signature;
    }

    void AssertionType::
    Signature (::std::auto_ptr< Signature::type > Signature)
    {
      this->_xsd_Signature_.set (Signature);
    }

    const AssertionType::Subject::container& AssertionType::
    Subject () const
    {
      return this->_xsd_Subject_;
    }

    AssertionType::Subject::container& AssertionType::
    Subject ()
    {
      return this->_xsd_Subject_;
    }

    void AssertionType::
    Subject (const Subject::type& Subject)
    {
      this->_xsd_Subject_.set (Subject);
    }

    void AssertionType::
    Subject (const Subject::container& Subject)
    {
      this->_xsd_Subject_ = Subject;
    }

    void AssertionType::
    Subject (::std::auto_ptr< Subject::type > Subject)
    {
      this->_xsd_Subject_.set (Subject);
    }

    const AssertionType::Conditions::container& AssertionType::
    Conditions () const
    {
      return this->_xsd_Conditions_;
    }

    AssertionType::Conditions::container& AssertionType::
    Conditions ()
    {
      return this->_xsd_Conditions_;
    }

    void AssertionType::
    Conditions (const Conditions::type& Conditions)
    {
      this->_xsd_Conditions_.set (Conditions);
    }

    void AssertionType::
    Conditions (const Conditions::container& Conditions)
    {
      this->_xsd_Conditions_ = Conditions;
    }

    void AssertionType::
    Conditions (::std::auto_ptr< Conditions::type > Conditions)
    {
      this->_xsd_Conditions_.set (Conditions);
    }

    const AssertionType::Advice::container& AssertionType::
    Advice () const
    {
      return this->_xsd_Advice_;
    }

    AssertionType::Advice::container& AssertionType::
    Advice ()
    {
      return this->_xsd_Advice_;
    }

    void AssertionType::
    Advice (const Advice::type& Advice)
    {
      this->_xsd_Advice_.set (Advice);
    }

    void AssertionType::
    Advice (const Advice::container& Advice)
    {
      this->_xsd_Advice_ = Advice;
    }

    void AssertionType::
    Advice (::std::auto_ptr< Advice::type > Advice)
    {
      this->_xsd_Advice_.set (Advice);
    }

    const AssertionType::Statement::container& AssertionType::
    Statement () const
    {
      return this->_xsd_Statement_;
    }

    AssertionType::Statement::container& AssertionType::
    Statement ()
    {
      return this->_xsd_Statement_;
    }

    void AssertionType::
    Statement (const Statement::container& Statement)
    {
      this->_xsd_Statement_ = Statement;
    }

    const AssertionType::AuthnStatement::container& AssertionType::
    AuthnStatement () const
    {
      return this->_xsd_AuthnStatement_;
    }

    AssertionType::AuthnStatement::container& AssertionType::
    AuthnStatement ()
    {
      return this->_xsd_AuthnStatement_;
    }

    void AssertionType::
    AuthnStatement (const AuthnStatement::container& AuthnStatement)
    {
      this->_xsd_AuthnStatement_ = AuthnStatement;
    }

    const AssertionType::AuthzDecisionStatement::container& AssertionType::
    AuthzDecisionStatement () const
    {
      return this->_xsd_AuthzDecisionStatement_;
    }

    AssertionType::AuthzDecisionStatement::container& AssertionType::
    AuthzDecisionStatement ()
    {
      return this->_xsd_AuthzDecisionStatement_;
    }

    void AssertionType::
    AuthzDecisionStatement (const AuthzDecisionStatement::container& AuthzDecisionStatement)
    {
      this->_xsd_AuthzDecisionStatement_ = AuthzDecisionStatement;
    }

    const AssertionType::AttributeStatement::container& AssertionType::
    AttributeStatement () const
    {
      return this->_xsd_AttributeStatement_;
    }

    AssertionType::AttributeStatement::container& AssertionType::
    AttributeStatement ()
    {
      return this->_xsd_AttributeStatement_;
    }

    void AssertionType::
    AttributeStatement (const AttributeStatement::container& AttributeStatement)
    {
      this->_xsd_AttributeStatement_ = AttributeStatement;
    }

    const AssertionType::Version::type& AssertionType::
    Version () const
    {
      return this->_xsd_Version_.get ();
    }

    AssertionType::Version::type& AssertionType::
    Version ()
    {
      return this->_xsd_Version_.get ();
    }

    void AssertionType::
    Version (const Version::type& Version)
    {
      this->_xsd_Version_.set (Version);
    }

    void AssertionType::
    Version (::std::auto_ptr< Version::type > Version)
    {
      this->_xsd_Version_.set (Version);
    }

    const AssertionType::ID::type& AssertionType::
    ID () const
    {
      return this->_xsd_ID_.get ();
    }

    AssertionType::ID::type& AssertionType::
    ID ()
    {
      return this->_xsd_ID_.get ();
    }

    void AssertionType::
    ID (const ID::type& ID)
    {
      this->_xsd_ID_.set (ID);
    }

    void AssertionType::
    ID (::std::auto_ptr< ID::type > ID)
    {
      this->_xsd_ID_.set (ID);
    }

    const AssertionType::IssueInstant::type& AssertionType::
    IssueInstant () const
    {
      return this->_xsd_IssueInstant_.get ();
    }

    AssertionType::IssueInstant::type& AssertionType::
    IssueInstant ()
    {
      return this->_xsd_IssueInstant_.get ();
    }

    void AssertionType::
    IssueInstant (const IssueInstant::type& IssueInstant)
    {
      this->_xsd_IssueInstant_.set (IssueInstant);
    }

    void AssertionType::
    IssueInstant (::std::auto_ptr< IssueInstant::type > IssueInstant)
    {
      this->_xsd_IssueInstant_.set (IssueInstant);
    }


    // SubjectType
    // 

    const SubjectType::BaseID::container& SubjectType::
    BaseID () const
    {
      return this->_xsd_BaseID_;
    }

    SubjectType::BaseID::container& SubjectType::
    BaseID ()
    {
      return this->_xsd_BaseID_;
    }

    void SubjectType::
    BaseID (const BaseID::type& BaseID)
    {
      this->_xsd_BaseID_.set (BaseID);
    }

    void SubjectType::
    BaseID (const BaseID::container& BaseID)
    {
      this->_xsd_BaseID_ = BaseID;
    }

    void SubjectType::
    BaseID (::std::auto_ptr< BaseID::type > BaseID)
    {
      this->_xsd_BaseID_.set (BaseID);
    }

    const SubjectType::NameID::container& SubjectType::
    NameID () const
    {
      return this->_xsd_NameID_;
    }

    SubjectType::NameID::container& SubjectType::
    NameID ()
    {
      return this->_xsd_NameID_;
    }

    void SubjectType::
    NameID (const NameID::type& NameID)
    {
      this->_xsd_NameID_.set (NameID);
    }

    void SubjectType::
    NameID (const NameID::container& NameID)
    {
      this->_xsd_NameID_ = NameID;
    }

    void SubjectType::
    NameID (::std::auto_ptr< NameID::type > NameID)
    {
      this->_xsd_NameID_.set (NameID);
    }

    const SubjectType::EncryptedID::container& SubjectType::
    EncryptedID () const
    {
      return this->_xsd_EncryptedID_;
    }

    SubjectType::EncryptedID::container& SubjectType::
    EncryptedID ()
    {
      return this->_xsd_EncryptedID_;
    }

    void SubjectType::
    EncryptedID (const EncryptedID::type& EncryptedID)
    {
      this->_xsd_EncryptedID_.set (EncryptedID);
    }

    void SubjectType::
    EncryptedID (const EncryptedID::container& EncryptedID)
    {
      this->_xsd_EncryptedID_ = EncryptedID;
    }

    void SubjectType::
    EncryptedID (::std::auto_ptr< EncryptedID::type > EncryptedID)
    {
      this->_xsd_EncryptedID_.set (EncryptedID);
    }

    const SubjectType::SubjectConfirmation::container& SubjectType::
    SubjectConfirmation () const
    {
      return this->_xsd_SubjectConfirmation_;
    }

    SubjectType::SubjectConfirmation::container& SubjectType::
    SubjectConfirmation ()
    {
      return this->_xsd_SubjectConfirmation_;
    }

    void SubjectType::
    SubjectConfirmation (const SubjectConfirmation::container& SubjectConfirmation)
    {
      this->_xsd_SubjectConfirmation_ = SubjectConfirmation;
    }


    // SubjectConfirmationType
    // 

    const SubjectConfirmationType::BaseID::container& SubjectConfirmationType::
    BaseID () const
    {
      return this->_xsd_BaseID_;
    }

    SubjectConfirmationType::BaseID::container& SubjectConfirmationType::
    BaseID ()
    {
      return this->_xsd_BaseID_;
    }

    void SubjectConfirmationType::
    BaseID (const BaseID::type& BaseID)
    {
      this->_xsd_BaseID_.set (BaseID);
    }

    void SubjectConfirmationType::
    BaseID (const BaseID::container& BaseID)
    {
      this->_xsd_BaseID_ = BaseID;
    }

    void SubjectConfirmationType::
    BaseID (::std::auto_ptr< BaseID::type > BaseID)
    {
      this->_xsd_BaseID_.set (BaseID);
    }

    const SubjectConfirmationType::NameID::container& SubjectConfirmationType::
    NameID () const
    {
      return this->_xsd_NameID_;
    }

    SubjectConfirmationType::NameID::container& SubjectConfirmationType::
    NameID ()
    {
      return this->_xsd_NameID_;
    }

    void SubjectConfirmationType::
    NameID (const NameID::type& NameID)
    {
      this->_xsd_NameID_.set (NameID);
    }

    void SubjectConfirmationType::
    NameID (const NameID::container& NameID)
    {
      this->_xsd_NameID_ = NameID;
    }

    void SubjectConfirmationType::
    NameID (::std::auto_ptr< NameID::type > NameID)
    {
      this->_xsd_NameID_.set (NameID);
    }

    const SubjectConfirmationType::EncryptedID::container& SubjectConfirmationType::
    EncryptedID () const
    {
      return this->_xsd_EncryptedID_;
    }

    SubjectConfirmationType::EncryptedID::container& SubjectConfirmationType::
    EncryptedID ()
    {
      return this->_xsd_EncryptedID_;
    }

    void SubjectConfirmationType::
    EncryptedID (const EncryptedID::type& EncryptedID)
    {
      this->_xsd_EncryptedID_.set (EncryptedID);
    }

    void SubjectConfirmationType::
    EncryptedID (const EncryptedID::container& EncryptedID)
    {
      this->_xsd_EncryptedID_ = EncryptedID;
    }

    void SubjectConfirmationType::
    EncryptedID (::std::auto_ptr< EncryptedID::type > EncryptedID)
    {
      this->_xsd_EncryptedID_.set (EncryptedID);
    }

    const SubjectConfirmationType::SubjectConfirmationData::container& SubjectConfirmationType::
    SubjectConfirmationData () const
    {
      return this->_xsd_SubjectConfirmationData_;
    }

    SubjectConfirmationType::SubjectConfirmationData::container& SubjectConfirmationType::
    SubjectConfirmationData ()
    {
      return this->_xsd_SubjectConfirmationData_;
    }

    void SubjectConfirmationType::
    SubjectConfirmationData (const SubjectConfirmationData::type& SubjectConfirmationData)
    {
      this->_xsd_SubjectConfirmationData_.set (SubjectConfirmationData);
    }

    void SubjectConfirmationType::
    SubjectConfirmationData (const SubjectConfirmationData::container& SubjectConfirmationData)
    {
      this->_xsd_SubjectConfirmationData_ = SubjectConfirmationData;
    }

    void SubjectConfirmationType::
    SubjectConfirmationData (::std::auto_ptr< SubjectConfirmationData::type > SubjectConfirmationData)
    {
      this->_xsd_SubjectConfirmationData_.set (SubjectConfirmationData);
    }

    const SubjectConfirmationType::Method::type& SubjectConfirmationType::
    Method () const
    {
      return this->_xsd_Method_.get ();
    }

    SubjectConfirmationType::Method::type& SubjectConfirmationType::
    Method ()
    {
      return this->_xsd_Method_.get ();
    }

    void SubjectConfirmationType::
    Method (const Method::type& Method)
    {
      this->_xsd_Method_.set (Method);
    }

    void SubjectConfirmationType::
    Method (::std::auto_ptr< Method::type > Method)
    {
      this->_xsd_Method_.set (Method);
    }


    // SubjectConfirmationDataType
    // 

    const SubjectConfirmationDataType::NotBefore::container& SubjectConfirmationDataType::
    NotBefore () const
    {
      return this->_xsd_NotBefore_;
    }

    SubjectConfirmationDataType::NotBefore::container& SubjectConfirmationDataType::
    NotBefore ()
    {
      return this->_xsd_NotBefore_;
    }

    void SubjectConfirmationDataType::
    NotBefore (const NotBefore::type& NotBefore)
    {
      this->_xsd_NotBefore_.set (NotBefore);
    }

    void SubjectConfirmationDataType::
    NotBefore (const NotBefore::container& NotBefore)
    {
      this->_xsd_NotBefore_ = NotBefore;
    }

    void SubjectConfirmationDataType::
    NotBefore (::std::auto_ptr< NotBefore::type > NotBefore)
    {
      this->_xsd_NotBefore_.set (NotBefore);
    }

    const SubjectConfirmationDataType::NotOnOrAfter::container& SubjectConfirmationDataType::
    NotOnOrAfter () const
    {
      return this->_xsd_NotOnOrAfter_;
    }

    SubjectConfirmationDataType::NotOnOrAfter::container& SubjectConfirmationDataType::
    NotOnOrAfter ()
    {
      return this->_xsd_NotOnOrAfter_;
    }

    void SubjectConfirmationDataType::
    NotOnOrAfter (const NotOnOrAfter::type& NotOnOrAfter)
    {
      this->_xsd_NotOnOrAfter_.set (NotOnOrAfter);
    }

    void SubjectConfirmationDataType::
    NotOnOrAfter (const NotOnOrAfter::container& NotOnOrAfter)
    {
      this->_xsd_NotOnOrAfter_ = NotOnOrAfter;
    }

    void SubjectConfirmationDataType::
    NotOnOrAfter (::std::auto_ptr< NotOnOrAfter::type > NotOnOrAfter)
    {
      this->_xsd_NotOnOrAfter_.set (NotOnOrAfter);
    }

    const SubjectConfirmationDataType::Recipient::container& SubjectConfirmationDataType::
    Recipient () const
    {
      return this->_xsd_Recipient_;
    }

    SubjectConfirmationDataType::Recipient::container& SubjectConfirmationDataType::
    Recipient ()
    {
      return this->_xsd_Recipient_;
    }

    void SubjectConfirmationDataType::
    Recipient (const Recipient::type& Recipient)
    {
      this->_xsd_Recipient_.set (Recipient);
    }

    void SubjectConfirmationDataType::
    Recipient (const Recipient::container& Recipient)
    {
      this->_xsd_Recipient_ = Recipient;
    }

    void SubjectConfirmationDataType::
    Recipient (::std::auto_ptr< Recipient::type > Recipient)
    {
      this->_xsd_Recipient_.set (Recipient);
    }

    const SubjectConfirmationDataType::InResponseTo::container& SubjectConfirmationDataType::
    InResponseTo () const
    {
      return this->_xsd_InResponseTo_;
    }

    SubjectConfirmationDataType::InResponseTo::container& SubjectConfirmationDataType::
    InResponseTo ()
    {
      return this->_xsd_InResponseTo_;
    }

    void SubjectConfirmationDataType::
    InResponseTo (const InResponseTo::type& InResponseTo)
    {
      this->_xsd_InResponseTo_.set (InResponseTo);
    }

    void SubjectConfirmationDataType::
    InResponseTo (const InResponseTo::container& InResponseTo)
    {
      this->_xsd_InResponseTo_ = InResponseTo;
    }

    void SubjectConfirmationDataType::
    InResponseTo (::std::auto_ptr< InResponseTo::type > InResponseTo)
    {
      this->_xsd_InResponseTo_.set (InResponseTo);
    }

    const SubjectConfirmationDataType::Address::container& SubjectConfirmationDataType::
    Address () const
    {
      return this->_xsd_Address_;
    }

    SubjectConfirmationDataType::Address::container& SubjectConfirmationDataType::
    Address ()
    {
      return this->_xsd_Address_;
    }

    void SubjectConfirmationDataType::
    Address (const Address::type& Address)
    {
      this->_xsd_Address_.set (Address);
    }

    void SubjectConfirmationDataType::
    Address (const Address::container& Address)
    {
      this->_xsd_Address_ = Address;
    }

    void SubjectConfirmationDataType::
    Address (::std::auto_ptr< Address::type > Address)
    {
      this->_xsd_Address_.set (Address);
    }


    // KeyInfoConfirmationDataType
    // 


    // ConditionsType
    // 

    const ConditionsType::Condition::container& ConditionsType::
    Condition () const
    {
      return this->_xsd_Condition_;
    }

    ConditionsType::Condition::container& ConditionsType::
    Condition ()
    {
      return this->_xsd_Condition_;
    }

    void ConditionsType::
    Condition (const Condition::container& Condition)
    {
      this->_xsd_Condition_ = Condition;
    }

    const ConditionsType::AudienceRestriction::container& ConditionsType::
    AudienceRestriction () const
    {
      return this->_xsd_AudienceRestriction_;
    }

    ConditionsType::AudienceRestriction::container& ConditionsType::
    AudienceRestriction ()
    {
      return this->_xsd_AudienceRestriction_;
    }

    void ConditionsType::
    AudienceRestriction (const AudienceRestriction::container& AudienceRestriction)
    {
      this->_xsd_AudienceRestriction_ = AudienceRestriction;
    }

    const ConditionsType::OneTimeUse::container& ConditionsType::
    OneTimeUse () const
    {
      return this->_xsd_OneTimeUse_;
    }

    ConditionsType::OneTimeUse::container& ConditionsType::
    OneTimeUse ()
    {
      return this->_xsd_OneTimeUse_;
    }

    void ConditionsType::
    OneTimeUse (const OneTimeUse::container& OneTimeUse)
    {
      this->_xsd_OneTimeUse_ = OneTimeUse;
    }

    const ConditionsType::ProxyRestriction::container& ConditionsType::
    ProxyRestriction () const
    {
      return this->_xsd_ProxyRestriction_;
    }

    ConditionsType::ProxyRestriction::container& ConditionsType::
    ProxyRestriction ()
    {
      return this->_xsd_ProxyRestriction_;
    }

    void ConditionsType::
    ProxyRestriction (const ProxyRestriction::container& ProxyRestriction)
    {
      this->_xsd_ProxyRestriction_ = ProxyRestriction;
    }

    const ConditionsType::NotBefore::container& ConditionsType::
    NotBefore () const
    {
      return this->_xsd_NotBefore_;
    }

    ConditionsType::NotBefore::container& ConditionsType::
    NotBefore ()
    {
      return this->_xsd_NotBefore_;
    }

    void ConditionsType::
    NotBefore (const NotBefore::type& NotBefore)
    {
      this->_xsd_NotBefore_.set (NotBefore);
    }

    void ConditionsType::
    NotBefore (const NotBefore::container& NotBefore)
    {
      this->_xsd_NotBefore_ = NotBefore;
    }

    void ConditionsType::
    NotBefore (::std::auto_ptr< NotBefore::type > NotBefore)
    {
      this->_xsd_NotBefore_.set (NotBefore);
    }

    const ConditionsType::NotOnOrAfter::container& ConditionsType::
    NotOnOrAfter () const
    {
      return this->_xsd_NotOnOrAfter_;
    }

    ConditionsType::NotOnOrAfter::container& ConditionsType::
    NotOnOrAfter ()
    {
      return this->_xsd_NotOnOrAfter_;
    }

    void ConditionsType::
    NotOnOrAfter (const NotOnOrAfter::type& NotOnOrAfter)
    {
      this->_xsd_NotOnOrAfter_.set (NotOnOrAfter);
    }

    void ConditionsType::
    NotOnOrAfter (const NotOnOrAfter::container& NotOnOrAfter)
    {
      this->_xsd_NotOnOrAfter_ = NotOnOrAfter;
    }

    void ConditionsType::
    NotOnOrAfter (::std::auto_ptr< NotOnOrAfter::type > NotOnOrAfter)
    {
      this->_xsd_NotOnOrAfter_.set (NotOnOrAfter);
    }


    // ConditionAbstractType
    // 


    // AudienceRestrictionType
    // 

    const AudienceRestrictionType::Audience::container& AudienceRestrictionType::
    Audience () const
    {
      return this->_xsd_Audience_;
    }

    AudienceRestrictionType::Audience::container& AudienceRestrictionType::
    Audience ()
    {
      return this->_xsd_Audience_;
    }

    void AudienceRestrictionType::
    Audience (const Audience::container& Audience)
    {
      this->_xsd_Audience_ = Audience;
    }


    // OneTimeUseType
    // 


    // ProxyRestrictionType
    // 

    const ProxyRestrictionType::Audience::container& ProxyRestrictionType::
    Audience () const
    {
      return this->_xsd_Audience_;
    }

    ProxyRestrictionType::Audience::container& ProxyRestrictionType::
    Audience ()
    {
      return this->_xsd_Audience_;
    }

    void ProxyRestrictionType::
    Audience (const Audience::container& Audience)
    {
      this->_xsd_Audience_ = Audience;
    }

    const ProxyRestrictionType::Count::container& ProxyRestrictionType::
    Count () const
    {
      return this->_xsd_Count_;
    }

    ProxyRestrictionType::Count::container& ProxyRestrictionType::
    Count ()
    {
      return this->_xsd_Count_;
    }

    void ProxyRestrictionType::
    Count (const Count::type& Count)
    {
      this->_xsd_Count_.set (Count);
    }

    void ProxyRestrictionType::
    Count (const Count::container& Count)
    {
      this->_xsd_Count_ = Count;
    }


    // AdviceType
    // 

    const AdviceType::AssertionIDRef::container& AdviceType::
    AssertionIDRef () const
    {
      return this->_xsd_AssertionIDRef_;
    }

    AdviceType::AssertionIDRef::container& AdviceType::
    AssertionIDRef ()
    {
      return this->_xsd_AssertionIDRef_;
    }

    void AdviceType::
    AssertionIDRef (const AssertionIDRef::container& AssertionIDRef)
    {
      this->_xsd_AssertionIDRef_ = AssertionIDRef;
    }

    const AdviceType::AssertionURIRef::container& AdviceType::
    AssertionURIRef () const
    {
      return this->_xsd_AssertionURIRef_;
    }

    AdviceType::AssertionURIRef::container& AdviceType::
    AssertionURIRef ()
    {
      return this->_xsd_AssertionURIRef_;
    }

    void AdviceType::
    AssertionURIRef (const AssertionURIRef::container& AssertionURIRef)
    {
      this->_xsd_AssertionURIRef_ = AssertionURIRef;
    }

    const AdviceType::Assertion::container& AdviceType::
    Assertion () const
    {
      return this->_xsd_Assertion_;
    }

    AdviceType::Assertion::container& AdviceType::
    Assertion ()
    {
      return this->_xsd_Assertion_;
    }

    void AdviceType::
    Assertion (const Assertion::container& Assertion)
    {
      this->_xsd_Assertion_ = Assertion;
    }

    const AdviceType::EncryptedAssertion::container& AdviceType::
    EncryptedAssertion () const
    {
      return this->_xsd_EncryptedAssertion_;
    }

    AdviceType::EncryptedAssertion::container& AdviceType::
    EncryptedAssertion ()
    {
      return this->_xsd_EncryptedAssertion_;
    }

    void AdviceType::
    EncryptedAssertion (const EncryptedAssertion::container& EncryptedAssertion)
    {
      this->_xsd_EncryptedAssertion_ = EncryptedAssertion;
    }


    // StatementAbstractType
    // 


    // AuthnStatementType
    // 

    const AuthnStatementType::SubjectLocality::container& AuthnStatementType::
    SubjectLocality () const
    {
      return this->_xsd_SubjectLocality_;
    }

    AuthnStatementType::SubjectLocality::container& AuthnStatementType::
    SubjectLocality ()
    {
      return this->_xsd_SubjectLocality_;
    }

    void AuthnStatementType::
    SubjectLocality (const SubjectLocality::type& SubjectLocality)
    {
      this->_xsd_SubjectLocality_.set (SubjectLocality);
    }

    void AuthnStatementType::
    SubjectLocality (const SubjectLocality::container& SubjectLocality)
    {
      this->_xsd_SubjectLocality_ = SubjectLocality;
    }

    void AuthnStatementType::
    SubjectLocality (::std::auto_ptr< SubjectLocality::type > SubjectLocality)
    {
      this->_xsd_SubjectLocality_.set (SubjectLocality);
    }

    const AuthnStatementType::AuthnContext::type& AuthnStatementType::
    AuthnContext () const
    {
      return this->_xsd_AuthnContext_.get ();
    }

    AuthnStatementType::AuthnContext::type& AuthnStatementType::
    AuthnContext ()
    {
      return this->_xsd_AuthnContext_.get ();
    }

    void AuthnStatementType::
    AuthnContext (const AuthnContext::type& AuthnContext)
    {
      this->_xsd_AuthnContext_.set (AuthnContext);
    }

    void AuthnStatementType::
    AuthnContext (::std::auto_ptr< AuthnContext::type > AuthnContext)
    {
      this->_xsd_AuthnContext_.set (AuthnContext);
    }

    const AuthnStatementType::AuthnInstant::type& AuthnStatementType::
    AuthnInstant () const
    {
      return this->_xsd_AuthnInstant_.get ();
    }

    AuthnStatementType::AuthnInstant::type& AuthnStatementType::
    AuthnInstant ()
    {
      return this->_xsd_AuthnInstant_.get ();
    }

    void AuthnStatementType::
    AuthnInstant (const AuthnInstant::type& AuthnInstant)
    {
      this->_xsd_AuthnInstant_.set (AuthnInstant);
    }

    void AuthnStatementType::
    AuthnInstant (::std::auto_ptr< AuthnInstant::type > AuthnInstant)
    {
      this->_xsd_AuthnInstant_.set (AuthnInstant);
    }

    const AuthnStatementType::SessionIndex::container& AuthnStatementType::
    SessionIndex () const
    {
      return this->_xsd_SessionIndex_;
    }

    AuthnStatementType::SessionIndex::container& AuthnStatementType::
    SessionIndex ()
    {
      return this->_xsd_SessionIndex_;
    }

    void AuthnStatementType::
    SessionIndex (const SessionIndex::type& SessionIndex)
    {
      this->_xsd_SessionIndex_.set (SessionIndex);
    }

    void AuthnStatementType::
    SessionIndex (const SessionIndex::container& SessionIndex)
    {
      this->_xsd_SessionIndex_ = SessionIndex;
    }

    void AuthnStatementType::
    SessionIndex (::std::auto_ptr< SessionIndex::type > SessionIndex)
    {
      this->_xsd_SessionIndex_.set (SessionIndex);
    }

    const AuthnStatementType::SessionNotOnOrAfter::container& AuthnStatementType::
    SessionNotOnOrAfter () const
    {
      return this->_xsd_SessionNotOnOrAfter_;
    }

    AuthnStatementType::SessionNotOnOrAfter::container& AuthnStatementType::
    SessionNotOnOrAfter ()
    {
      return this->_xsd_SessionNotOnOrAfter_;
    }

    void AuthnStatementType::
    SessionNotOnOrAfter (const SessionNotOnOrAfter::type& SessionNotOnOrAfter)
    {
      this->_xsd_SessionNotOnOrAfter_.set (SessionNotOnOrAfter);
    }

    void AuthnStatementType::
    SessionNotOnOrAfter (const SessionNotOnOrAfter::container& SessionNotOnOrAfter)
    {
      this->_xsd_SessionNotOnOrAfter_ = SessionNotOnOrAfter;
    }

    void AuthnStatementType::
    SessionNotOnOrAfter (::std::auto_ptr< SessionNotOnOrAfter::type > SessionNotOnOrAfter)
    {
      this->_xsd_SessionNotOnOrAfter_.set (SessionNotOnOrAfter);
    }


    // SubjectLocalityType
    // 

    const SubjectLocalityType::Address::container& SubjectLocalityType::
    Address () const
    {
      return this->_xsd_Address_;
    }

    SubjectLocalityType::Address::container& SubjectLocalityType::
    Address ()
    {
      return this->_xsd_Address_;
    }

    void SubjectLocalityType::
    Address (const Address::type& Address)
    {
      this->_xsd_Address_.set (Address);
    }

    void SubjectLocalityType::
    Address (const Address::container& Address)
    {
      this->_xsd_Address_ = Address;
    }

    void SubjectLocalityType::
    Address (::std::auto_ptr< Address::type > Address)
    {
      this->_xsd_Address_.set (Address);
    }

    const SubjectLocalityType::DNSName::container& SubjectLocalityType::
    DNSName () const
    {
      return this->_xsd_DNSName_;
    }

    SubjectLocalityType::DNSName::container& SubjectLocalityType::
    DNSName ()
    {
      return this->_xsd_DNSName_;
    }

    void SubjectLocalityType::
    DNSName (const DNSName::type& DNSName)
    {
      this->_xsd_DNSName_.set (DNSName);
    }

    void SubjectLocalityType::
    DNSName (const DNSName::container& DNSName)
    {
      this->_xsd_DNSName_ = DNSName;
    }

    void SubjectLocalityType::
    DNSName (::std::auto_ptr< DNSName::type > DNSName)
    {
      this->_xsd_DNSName_.set (DNSName);
    }


    // AuthnContextType
    // 

    const AuthnContextType::AuthnContextClassRef::container& AuthnContextType::
    AuthnContextClassRef () const
    {
      return this->_xsd_AuthnContextClassRef_;
    }

    AuthnContextType::AuthnContextClassRef::container& AuthnContextType::
    AuthnContextClassRef ()
    {
      return this->_xsd_AuthnContextClassRef_;
    }

    void AuthnContextType::
    AuthnContextClassRef (const AuthnContextClassRef::type& AuthnContextClassRef)
    {
      this->_xsd_AuthnContextClassRef_.set (AuthnContextClassRef);
    }

    void AuthnContextType::
    AuthnContextClassRef (const AuthnContextClassRef::container& AuthnContextClassRef)
    {
      this->_xsd_AuthnContextClassRef_ = AuthnContextClassRef;
    }

    void AuthnContextType::
    AuthnContextClassRef (::std::auto_ptr< AuthnContextClassRef::type > AuthnContextClassRef)
    {
      this->_xsd_AuthnContextClassRef_.set (AuthnContextClassRef);
    }

    const AuthnContextType::AuthnContextDecl::container& AuthnContextType::
    AuthnContextDecl () const
    {
      return this->_xsd_AuthnContextDecl_;
    }

    AuthnContextType::AuthnContextDecl::container& AuthnContextType::
    AuthnContextDecl ()
    {
      return this->_xsd_AuthnContextDecl_;
    }

    void AuthnContextType::
    AuthnContextDecl (const AuthnContextDecl::type& AuthnContextDecl)
    {
      this->_xsd_AuthnContextDecl_.set (AuthnContextDecl);
    }

    void AuthnContextType::
    AuthnContextDecl (const AuthnContextDecl::container& AuthnContextDecl)
    {
      this->_xsd_AuthnContextDecl_ = AuthnContextDecl;
    }

    void AuthnContextType::
    AuthnContextDecl (::std::auto_ptr< AuthnContextDecl::type > AuthnContextDecl)
    {
      this->_xsd_AuthnContextDecl_.set (AuthnContextDecl);
    }

    const AuthnContextType::AuthnContextDeclRef::container& AuthnContextType::
    AuthnContextDeclRef () const
    {
      return this->_xsd_AuthnContextDeclRef_;
    }

    AuthnContextType::AuthnContextDeclRef::container& AuthnContextType::
    AuthnContextDeclRef ()
    {
      return this->_xsd_AuthnContextDeclRef_;
    }

    void AuthnContextType::
    AuthnContextDeclRef (const AuthnContextDeclRef::type& AuthnContextDeclRef)
    {
      this->_xsd_AuthnContextDeclRef_.set (AuthnContextDeclRef);
    }

    void AuthnContextType::
    AuthnContextDeclRef (const AuthnContextDeclRef::container& AuthnContextDeclRef)
    {
      this->_xsd_AuthnContextDeclRef_ = AuthnContextDeclRef;
    }

    void AuthnContextType::
    AuthnContextDeclRef (::std::auto_ptr< AuthnContextDeclRef::type > AuthnContextDeclRef)
    {
      this->_xsd_AuthnContextDeclRef_.set (AuthnContextDeclRef);
    }

    const AuthnContextType::AuthenticatingAuthority::container& AuthnContextType::
    AuthenticatingAuthority () const
    {
      return this->_xsd_AuthenticatingAuthority_;
    }

    AuthnContextType::AuthenticatingAuthority::container& AuthnContextType::
    AuthenticatingAuthority ()
    {
      return this->_xsd_AuthenticatingAuthority_;
    }

    void AuthnContextType::
    AuthenticatingAuthority (const AuthenticatingAuthority::container& AuthenticatingAuthority)
    {
      this->_xsd_AuthenticatingAuthority_ = AuthenticatingAuthority;
    }


    // AuthzDecisionStatementType
    // 

    const AuthzDecisionStatementType::Action::container& AuthzDecisionStatementType::
    Action () const
    {
      return this->_xsd_Action_;
    }

    AuthzDecisionStatementType::Action::container& AuthzDecisionStatementType::
    Action ()
    {
      return this->_xsd_Action_;
    }

    void AuthzDecisionStatementType::
    Action (const Action::container& Action)
    {
      this->_xsd_Action_ = Action;
    }

    const AuthzDecisionStatementType::Evidence::container& AuthzDecisionStatementType::
    Evidence () const
    {
      return this->_xsd_Evidence_;
    }

    AuthzDecisionStatementType::Evidence::container& AuthzDecisionStatementType::
    Evidence ()
    {
      return this->_xsd_Evidence_;
    }

    void AuthzDecisionStatementType::
    Evidence (const Evidence::type& Evidence)
    {
      this->_xsd_Evidence_.set (Evidence);
    }

    void AuthzDecisionStatementType::
    Evidence (const Evidence::container& Evidence)
    {
      this->_xsd_Evidence_ = Evidence;
    }

    void AuthzDecisionStatementType::
    Evidence (::std::auto_ptr< Evidence::type > Evidence)
    {
      this->_xsd_Evidence_.set (Evidence);
    }

    const AuthzDecisionStatementType::Resource::type& AuthzDecisionStatementType::
    Resource () const
    {
      return this->_xsd_Resource_.get ();
    }

    AuthzDecisionStatementType::Resource::type& AuthzDecisionStatementType::
    Resource ()
    {
      return this->_xsd_Resource_.get ();
    }

    void AuthzDecisionStatementType::
    Resource (const Resource::type& Resource)
    {
      this->_xsd_Resource_.set (Resource);
    }

    void AuthzDecisionStatementType::
    Resource (::std::auto_ptr< Resource::type > Resource)
    {
      this->_xsd_Resource_.set (Resource);
    }

    const AuthzDecisionStatementType::Decision::type& AuthzDecisionStatementType::
    Decision () const
    {
      return this->_xsd_Decision_.get ();
    }

    AuthzDecisionStatementType::Decision::type& AuthzDecisionStatementType::
    Decision ()
    {
      return this->_xsd_Decision_.get ();
    }

    void AuthzDecisionStatementType::
    Decision (const Decision::type& Decision)
    {
      this->_xsd_Decision_.set (Decision);
    }

    void AuthzDecisionStatementType::
    Decision (::std::auto_ptr< Decision::type > Decision)
    {
      this->_xsd_Decision_.set (Decision);
    }


    // DecisionType
    // 

    DecisionType::
    DecisionType ()
    : ::xml_schema::string ()
    {
    }

    DecisionType::
    DecisionType (_xsd_DecisionType v)
    : ::xml_schema::string (_xsd_DecisionType_literals_[v])
    {
    }

    DecisionType::
    DecisionType (const ::xml_schema::string& _xsd_DecisionType)
    : ::xml_schema::string (_xsd_DecisionType)
    {
    }

    DecisionType::
    DecisionType (const DecisionType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    DecisionType& DecisionType::
    operator= (_xsd_DecisionType v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_DecisionType_literals_[v]);

      return *this;
    }


    // ActionType
    // 

    const ActionType::Namespace::type& ActionType::
    Namespace () const
    {
      return this->_xsd_Namespace_.get ();
    }

    ActionType::Namespace::type& ActionType::
    Namespace ()
    {
      return this->_xsd_Namespace_.get ();
    }

    void ActionType::
    Namespace (const Namespace::type& Namespace)
    {
      this->_xsd_Namespace_.set (Namespace);
    }

    void ActionType::
    Namespace (::std::auto_ptr< Namespace::type > Namespace)
    {
      this->_xsd_Namespace_.set (Namespace);
    }


    // EvidenceType
    // 

    const EvidenceType::AssertionIDRef::container& EvidenceType::
    AssertionIDRef () const
    {
      return this->_xsd_AssertionIDRef_;
    }

    EvidenceType::AssertionIDRef::container& EvidenceType::
    AssertionIDRef ()
    {
      return this->_xsd_AssertionIDRef_;
    }

    void EvidenceType::
    AssertionIDRef (const AssertionIDRef::container& AssertionIDRef)
    {
      this->_xsd_AssertionIDRef_ = AssertionIDRef;
    }

    const EvidenceType::AssertionURIRef::container& EvidenceType::
    AssertionURIRef () const
    {
      return this->_xsd_AssertionURIRef_;
    }

    EvidenceType::AssertionURIRef::container& EvidenceType::
    AssertionURIRef ()
    {
      return this->_xsd_AssertionURIRef_;
    }

    void EvidenceType::
    AssertionURIRef (const AssertionURIRef::container& AssertionURIRef)
    {
      this->_xsd_AssertionURIRef_ = AssertionURIRef;
    }

    const EvidenceType::Assertion::container& EvidenceType::
    Assertion () const
    {
      return this->_xsd_Assertion_;
    }

    EvidenceType::Assertion::container& EvidenceType::
    Assertion ()
    {
      return this->_xsd_Assertion_;
    }

    void EvidenceType::
    Assertion (const Assertion::container& Assertion)
    {
      this->_xsd_Assertion_ = Assertion;
    }

    const EvidenceType::EncryptedAssertion::container& EvidenceType::
    EncryptedAssertion () const
    {
      return this->_xsd_EncryptedAssertion_;
    }

    EvidenceType::EncryptedAssertion::container& EvidenceType::
    EncryptedAssertion ()
    {
      return this->_xsd_EncryptedAssertion_;
    }

    void EvidenceType::
    EncryptedAssertion (const EncryptedAssertion::container& EncryptedAssertion)
    {
      this->_xsd_EncryptedAssertion_ = EncryptedAssertion;
    }


    // AttributeStatementType
    // 

    const AttributeStatementType::Attribute::container& AttributeStatementType::
    Attribute () const
    {
      return this->_xsd_Attribute_;
    }

    AttributeStatementType::Attribute::container& AttributeStatementType::
    Attribute ()
    {
      return this->_xsd_Attribute_;
    }

    void AttributeStatementType::
    Attribute (const Attribute::container& Attribute)
    {
      this->_xsd_Attribute_ = Attribute;
    }

    const AttributeStatementType::EncryptedAttribute::container& AttributeStatementType::
    EncryptedAttribute () const
    {
      return this->_xsd_EncryptedAttribute_;
    }

    AttributeStatementType::EncryptedAttribute::container& AttributeStatementType::
    EncryptedAttribute ()
    {
      return this->_xsd_EncryptedAttribute_;
    }

    void AttributeStatementType::
    EncryptedAttribute (const EncryptedAttribute::container& EncryptedAttribute)
    {
      this->_xsd_EncryptedAttribute_ = EncryptedAttribute;
    }


    // AttributeType
    // 

    const AttributeType::AttributeValue::container& AttributeType::
    AttributeValue () const
    {
      return this->_xsd_AttributeValue_;
    }

    AttributeType::AttributeValue::container& AttributeType::
    AttributeValue ()
    {
      return this->_xsd_AttributeValue_;
    }

    void AttributeType::
    AttributeValue (const AttributeValue::container& AttributeValue)
    {
      this->_xsd_AttributeValue_ = AttributeValue;
    }

    const AttributeType::Name::type& AttributeType::
    Name () const
    {
      return this->_xsd_Name_.get ();
    }

    AttributeType::Name::type& AttributeType::
    Name ()
    {
      return this->_xsd_Name_.get ();
    }

    void AttributeType::
    Name (const Name::type& Name)
    {
      this->_xsd_Name_.set (Name);
    }

    void AttributeType::
    Name (::std::auto_ptr< Name::type > Name)
    {
      this->_xsd_Name_.set (Name);
    }

    const AttributeType::NameFormat::container& AttributeType::
    NameFormat () const
    {
      return this->_xsd_NameFormat_;
    }

    AttributeType::NameFormat::container& AttributeType::
    NameFormat ()
    {
      return this->_xsd_NameFormat_;
    }

    void AttributeType::
    NameFormat (const NameFormat::type& NameFormat)
    {
      this->_xsd_NameFormat_.set (NameFormat);
    }

    void AttributeType::
    NameFormat (const NameFormat::container& NameFormat)
    {
      this->_xsd_NameFormat_ = NameFormat;
    }

    void AttributeType::
    NameFormat (::std::auto_ptr< NameFormat::type > NameFormat)
    {
      this->_xsd_NameFormat_.set (NameFormat);
    }

    const AttributeType::FriendlyName::container& AttributeType::
    FriendlyName () const
    {
      return this->_xsd_FriendlyName_;
    }

    AttributeType::FriendlyName::container& AttributeType::
    FriendlyName ()
    {
      return this->_xsd_FriendlyName_;
    }

    void AttributeType::
    FriendlyName (const FriendlyName::type& FriendlyName)
    {
      this->_xsd_FriendlyName_.set (FriendlyName);
    }

    void AttributeType::
    FriendlyName (const FriendlyName::container& FriendlyName)
    {
      this->_xsd_FriendlyName_ = FriendlyName;
    }

    void AttributeType::
    FriendlyName (::std::auto_ptr< FriendlyName::type > FriendlyName)
    {
      this->_xsd_FriendlyName_.set (FriendlyName);
    }
  }
}

#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace saml2
{
  namespace assertion
  {
    // BaseIDAbstractType
    //

    BaseIDAbstractType::
    BaseIDAbstractType ()
    : ::xml_schema::type (),
    _xsd_NameQualifier_ (::xml_schema::flags (), this),
    _xsd_SPNameQualifier_ (::xml_schema::flags (), this)
    {
    }

    BaseIDAbstractType::
    BaseIDAbstractType (const BaseIDAbstractType& _xsd_BaseIDAbstractType,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_BaseIDAbstractType, f, c),
    _xsd_NameQualifier_ (_xsd_BaseIDAbstractType._xsd_NameQualifier_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_SPNameQualifier_ (_xsd_BaseIDAbstractType._xsd_SPNameQualifier_,
                           f | ::xml_schema::flags::not_root,
                           this)
    {
    }

    BaseIDAbstractType::
    BaseIDAbstractType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_NameQualifier_ (f | ::xml_schema::flags::not_root, this),
    _xsd_SPNameQualifier_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void BaseIDAbstractType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"NameQualifier" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameQualifier::type > r (
            NameQualifier::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->NameQualifier (r);
          continue;
        }

        if (a.name () == L"SPNameQualifier" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< SPNameQualifier::type > r (
            SPNameQualifier::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->SPNameQualifier (r);
          continue;
        }
      }
    }

    BaseIDAbstractType* BaseIDAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new BaseIDAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, BaseIDAbstractType >
    _xsd_BaseIDAbstractType_type_factory_init (
      L"BaseIDAbstractType urn:oasis:names:tc:SAML:2.0:assertion");


    // NameIDType
    //

    NameIDType::
    NameIDType ()
    : ::xml_schema::string (),
    _xsd_NameQualifier_ (::xml_schema::flags (), this),
    _xsd_SPNameQualifier_ (::xml_schema::flags (), this),
    _xsd_Format_ (::xml_schema::flags (), this),
    _xsd_SPProvidedID_ (::xml_schema::flags (), this)
    {
    }

    NameIDType::
    NameIDType (const _xsd_NameIDType::base_& _xsd_NameIDType)
    : ::xml_schema::string (_xsd_NameIDType),
    _xsd_NameQualifier_ (::xml_schema::flags (), this),
    _xsd_SPNameQualifier_ (::xml_schema::flags (), this),
    _xsd_Format_ (::xml_schema::flags (), this),
    _xsd_SPProvidedID_ (::xml_schema::flags (), this)
    {
    }

    NameIDType::
    NameIDType (const NameIDType& _xsd_NameIDType,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (_xsd_NameIDType, f, c),
    _xsd_NameQualifier_ (_xsd_NameIDType._xsd_NameQualifier_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_SPNameQualifier_ (_xsd_NameIDType._xsd_SPNameQualifier_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_Format_ (_xsd_NameIDType._xsd_Format_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_SPProvidedID_ (_xsd_NameIDType._xsd_SPProvidedID_,
                        f | ::xml_schema::flags::not_root,
                        this)
    {
    }

    NameIDType::
    NameIDType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c),
    _xsd_NameQualifier_ (f | ::xml_schema::flags::not_root, this),
    _xsd_SPNameQualifier_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Format_ (f | ::xml_schema::flags::not_root, this),
    _xsd_SPProvidedID_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void NameIDType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"NameQualifier" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameQualifier::type > r (
            NameQualifier::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->NameQualifier (r);
          continue;
        }

        if (a.name () == L"SPNameQualifier" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< SPNameQualifier::type > r (
            SPNameQualifier::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->SPNameQualifier (r);
          continue;
        }

        if (a.name () == L"Format" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Format::type > r (
            Format::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Format (r);
          continue;
        }

        if (a.name () == L"SPProvidedID" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< SPProvidedID::type > r (
            SPProvidedID::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->SPProvidedID (r);
          continue;
        }
      }
    }

    NameIDType* NameIDType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new NameIDType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NameIDType >
    _xsd_NameIDType_type_factory_init (
      L"NameIDType urn:oasis:names:tc:SAML:2.0:assertion");


    // EncryptedElementType
    //

    EncryptedElementType::
    EncryptedElementType ()
    : ::xml_schema::type (),
    _xsd_EncryptedData_ (::xml_schema::flags (), this),
    _xsd_EncryptedKey_ (::xml_schema::flags (), this)
    {
    }

    EncryptedElementType::
    EncryptedElementType (const EncryptedData::type& _xsd_EncryptedData)
    : ::xml_schema::type (),
    _xsd_EncryptedData_ (_xsd_EncryptedData,
                         ::xml_schema::flags (),
                         this),
    _xsd_EncryptedKey_ (::xml_schema::flags (), this)
    {
    }

    EncryptedElementType::
    EncryptedElementType (const EncryptedElementType& _xsd_EncryptedElementType,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_EncryptedElementType, f, c),
    _xsd_EncryptedData_ (_xsd_EncryptedElementType._xsd_EncryptedData_,
                         f | ::xml_schema::flags::not_root,
                         this),
    _xsd_EncryptedKey_ (_xsd_EncryptedElementType._xsd_EncryptedKey_,
                        f | ::xml_schema::flags::not_root,
                        this)
    {
    }

    EncryptedElementType::
    EncryptedElementType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_EncryptedData_ (f | ::xml_schema::flags::not_root, this),
    _xsd_EncryptedKey_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void EncryptedElementType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // EncryptedData
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< EncryptedData::type > r (
            tfm.create< EncryptedData::type > (
              L"EncryptedData",
              L"http://www.w3.org/2001/04/xmlenc#",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (_xsd_EncryptedData_.present ())
              continue;
            this->EncryptedData (r);
            continue;
          }
        }

        // EncryptedKey
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< EncryptedKey::type > r (
            tfm.create< EncryptedKey::type > (
              L"EncryptedKey",
              L"http://www.w3.org/2001/04/xmlenc#",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->EncryptedKey ().push_back (r);
            continue;
          }
        }
      }

      if (!_xsd_EncryptedData_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EncryptedData",
          L"http://www.w3.org/2001/04/xmlenc#");
      }
    }

    EncryptedElementType* EncryptedElementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new EncryptedElementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptedElementType >
    _xsd_EncryptedElementType_type_factory_init (
      L"EncryptedElementType urn:oasis:names:tc:SAML:2.0:assertion");


    // AssertionType
    //

    AssertionType::
    AssertionType ()
    : ::xml_schema::type (),
    _xsd_Issuer_ (::xml_schema::flags (), this),
    _xsd_Signature_ (::xml_schema::flags (), this),
    _xsd_Subject_ (::xml_schema::flags (), this),
    _xsd_Conditions_ (::xml_schema::flags (), this),
    _xsd_Advice_ (::xml_schema::flags (), this),
    _xsd_Statement_ (::xml_schema::flags (), this),
    _xsd_AuthnStatement_ (::xml_schema::flags (), this),
    _xsd_AuthzDecisionStatement_ (::xml_schema::flags (), this),
    _xsd_AttributeStatement_ (::xml_schema::flags (), this),
    _xsd_Version_ (::xml_schema::flags (), this),
    _xsd_ID_ (::xml_schema::flags (), this),
    _xsd_IssueInstant_ (::xml_schema::flags (), this)
    {
    }

    AssertionType::
    AssertionType (const Issuer::type& _xsd_Issuer,
                   const Version::type& _xsd_Version,
                   const ID::type& _xsd_ID,
                   const IssueInstant::type& _xsd_IssueInstant)
    : ::xml_schema::type (),
    _xsd_Issuer_ (_xsd_Issuer,
                  ::xml_schema::flags (),
                  this),
    _xsd_Signature_ (::xml_schema::flags (), this),
    _xsd_Subject_ (::xml_schema::flags (), this),
    _xsd_Conditions_ (::xml_schema::flags (), this),
    _xsd_Advice_ (::xml_schema::flags (), this),
    _xsd_Statement_ (::xml_schema::flags (), this),
    _xsd_AuthnStatement_ (::xml_schema::flags (), this),
    _xsd_AuthzDecisionStatement_ (::xml_schema::flags (), this),
    _xsd_AttributeStatement_ (::xml_schema::flags (), this),
    _xsd_Version_ (_xsd_Version,
                   ::xml_schema::flags (),
                   this),
    _xsd_ID_ (_xsd_ID,
              ::xml_schema::flags (),
              this),
    _xsd_IssueInstant_ (_xsd_IssueInstant,
                        ::xml_schema::flags (),
                        this)
    {
    }

    AssertionType::
    AssertionType (const AssertionType& _xsd_AssertionType,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_AssertionType, f, c),
    _xsd_Issuer_ (_xsd_AssertionType._xsd_Issuer_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_Signature_ (_xsd_AssertionType._xsd_Signature_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_Subject_ (_xsd_AssertionType._xsd_Subject_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_Conditions_ (_xsd_AssertionType._xsd_Conditions_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_Advice_ (_xsd_AssertionType._xsd_Advice_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_Statement_ (_xsd_AssertionType._xsd_Statement_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_AuthnStatement_ (_xsd_AssertionType._xsd_AuthnStatement_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_AuthzDecisionStatement_ (_xsd_AssertionType._xsd_AuthzDecisionStatement_,
                                  f | ::xml_schema::flags::not_root,
                                  this),
    _xsd_AttributeStatement_ (_xsd_AssertionType._xsd_AttributeStatement_,
                              f | ::xml_schema::flags::not_root,
                              this),
    _xsd_Version_ (_xsd_AssertionType._xsd_Version_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_ID_ (_xsd_AssertionType._xsd_ID_,
              f | ::xml_schema::flags::not_root,
              this),
    _xsd_IssueInstant_ (_xsd_AssertionType._xsd_IssueInstant_,
                        f | ::xml_schema::flags::not_root,
                        this)
    {
    }

    AssertionType::
    AssertionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_Issuer_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Signature_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Subject_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Conditions_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Advice_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Statement_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AuthnStatement_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AuthzDecisionStatement_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AttributeStatement_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Version_ (f | ::xml_schema::flags::not_root, this),
    _xsd_ID_ (f | ::xml_schema::flags::not_root, this),
    _xsd_IssueInstant_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AssertionType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // Issuer
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Issuer::type > r (
            tfm.create< Issuer::type > (
              L"Issuer",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (_xsd_Issuer_.present ())
              continue;
            this->Issuer (r);
            continue;
          }
        }

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Signature::type > r (
            tfm.create< Signature::type > (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->Signature ())
              continue;
            this->Signature (r);
            continue;
          }
        }

        // Subject
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Subject::type > r (
            tfm.create< Subject::type > (
              L"Subject",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->Subject ())
              continue;
            this->Subject (r);
            continue;
          }
        }

        // Conditions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Conditions::type > r (
            tfm.create< Conditions::type > (
              L"Conditions",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->Conditions ())
              continue;
            this->Conditions (r);
            continue;
          }
        }

        // Advice
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Advice::type > r (
            tfm.create< Advice::type > (
              L"Advice",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->Advice ())
              continue;
            this->Advice (r);
            continue;
          }
        }

        // Statement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Statement::type > r (
            tfm.create< Statement::type > (
              L"Statement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Statement ().push_back (r);
            continue;
          }
        }

        // AuthnStatement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AuthnStatement::type > r (
            tfm.create< AuthnStatement::type > (
              L"AuthnStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AuthnStatement ().push_back (r);
            continue;
          }
        }

        // AuthzDecisionStatement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AuthzDecisionStatement::type > r (
            tfm.create< AuthzDecisionStatement::type > (
              L"AuthzDecisionStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AuthzDecisionStatement ().push_back (r);
            continue;
          }
        }

        // AttributeStatement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AttributeStatement::type > r (
            tfm.create< AttributeStatement::type > (
              L"AttributeStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AttributeStatement ().push_back (r);
            continue;
          }
        }
      }

      if (!_xsd_Issuer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Issuer",
          L"urn:oasis:names:tc:SAML:2.0:assertion");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"Version" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Version::type > r (
            Version::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Version (r);
          continue;
        }

        if (a.name () == L"ID" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID::type > r (
            ID::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->ID (r);
          continue;
        }

        if (a.name () == L"IssueInstant" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< IssueInstant::type > r (
            IssueInstant::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->IssueInstant (r);
          continue;
        }
      }

      if (!_xsd_Version_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Version",
          L"");
      }

      if (!_xsd_ID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"ID",
          L"");
      }

      if (!_xsd_IssueInstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"IssueInstant",
          L"");
      }
    }

    AssertionType* AssertionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AssertionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AssertionType >
    _xsd_AssertionType_type_factory_init (
      L"AssertionType urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectType
    //

    SubjectType::
    SubjectType ()
    : ::xml_schema::type (),
    _xsd_BaseID_ (::xml_schema::flags (), this),
    _xsd_NameID_ (::xml_schema::flags (), this),
    _xsd_EncryptedID_ (::xml_schema::flags (), this),
    _xsd_SubjectConfirmation_ (::xml_schema::flags (), this)
    {
    }

    SubjectType::
    SubjectType (const SubjectType& _xsd_SubjectType,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_SubjectType, f, c),
    _xsd_BaseID_ (_xsd_SubjectType._xsd_BaseID_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_NameID_ (_xsd_SubjectType._xsd_NameID_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_EncryptedID_ (_xsd_SubjectType._xsd_EncryptedID_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_SubjectConfirmation_ (_xsd_SubjectType._xsd_SubjectConfirmation_,
                               f | ::xml_schema::flags::not_root,
                               this)
    {
    }

    SubjectType::
    SubjectType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_BaseID_ (f | ::xml_schema::flags::not_root, this),
    _xsd_NameID_ (f | ::xml_schema::flags::not_root, this),
    _xsd_EncryptedID_ (f | ::xml_schema::flags::not_root, this),
    _xsd_SubjectConfirmation_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void SubjectType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // BaseID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< BaseID::type > r (
            tfm.create< BaseID::type > (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->BaseID ())
              continue;
            this->BaseID (r);
            continue;
          }
        }

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< NameID::type > r (
            tfm.create< NameID::type > (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->NameID ())
              continue;
            this->NameID (r);
            continue;
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< EncryptedID::type > r (
            tfm.create< EncryptedID::type > (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->EncryptedID ())
              continue;
            this->EncryptedID (r);
            continue;
          }
        }

        // SubjectConfirmation
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< SubjectConfirmation::type > r (
            tfm.create< SubjectConfirmation::type > (
              L"SubjectConfirmation",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->SubjectConfirmation ().push_back (r);
            continue;
          }
        }
      }
    }

    SubjectType* SubjectType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectType >
    _xsd_SubjectType_type_factory_init (
      L"SubjectType urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectConfirmationType
    //

    SubjectConfirmationType::
    SubjectConfirmationType ()
    : ::xml_schema::type (),
    _xsd_BaseID_ (::xml_schema::flags (), this),
    _xsd_NameID_ (::xml_schema::flags (), this),
    _xsd_EncryptedID_ (::xml_schema::flags (), this),
    _xsd_SubjectConfirmationData_ (::xml_schema::flags (), this),
    _xsd_Method_ (::xml_schema::flags (), this)
    {
    }

    SubjectConfirmationType::
    SubjectConfirmationType (const Method::type& _xsd_Method)
    : ::xml_schema::type (),
    _xsd_BaseID_ (::xml_schema::flags (), this),
    _xsd_NameID_ (::xml_schema::flags (), this),
    _xsd_EncryptedID_ (::xml_schema::flags (), this),
    _xsd_SubjectConfirmationData_ (::xml_schema::flags (), this),
    _xsd_Method_ (_xsd_Method,
                  ::xml_schema::flags (),
                  this)
    {
    }

    SubjectConfirmationType::
    SubjectConfirmationType (const SubjectConfirmationType& _xsd_SubjectConfirmationType,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_SubjectConfirmationType, f, c),
    _xsd_BaseID_ (_xsd_SubjectConfirmationType._xsd_BaseID_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_NameID_ (_xsd_SubjectConfirmationType._xsd_NameID_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_EncryptedID_ (_xsd_SubjectConfirmationType._xsd_EncryptedID_,
                       f | ::xml_schema::flags::not_root,
                       this),
    _xsd_SubjectConfirmationData_ (_xsd_SubjectConfirmationType._xsd_SubjectConfirmationData_,
                                   f | ::xml_schema::flags::not_root,
                                   this),
    _xsd_Method_ (_xsd_SubjectConfirmationType._xsd_Method_,
                  f | ::xml_schema::flags::not_root,
                  this)
    {
    }

    SubjectConfirmationType::
    SubjectConfirmationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_BaseID_ (f | ::xml_schema::flags::not_root, this),
    _xsd_NameID_ (f | ::xml_schema::flags::not_root, this),
    _xsd_EncryptedID_ (f | ::xml_schema::flags::not_root, this),
    _xsd_SubjectConfirmationData_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Method_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void SubjectConfirmationType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // BaseID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< BaseID::type > r (
            tfm.create< BaseID::type > (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->BaseID ())
              continue;
            this->BaseID (r);
            continue;
          }
        }

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< NameID::type > r (
            tfm.create< NameID::type > (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->NameID ())
              continue;
            this->NameID (r);
            continue;
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< EncryptedID::type > r (
            tfm.create< EncryptedID::type > (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->EncryptedID ())
              continue;
            this->EncryptedID (r);
            continue;
          }
        }

        // SubjectConfirmationData
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< SubjectConfirmationData::type > r (
            tfm.create< SubjectConfirmationData::type > (
              L"SubjectConfirmationData",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->SubjectConfirmationData ())
              continue;
            this->SubjectConfirmationData (r);
            continue;
          }
        }
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"Method" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Method::type > r (
            Method::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Method (r);
          continue;
        }
      }

      if (!_xsd_Method_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Method",
          L"");
      }
    }

    SubjectConfirmationType* SubjectConfirmationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectConfirmationType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectConfirmationType >
    _xsd_SubjectConfirmationType_type_factory_init (
      L"SubjectConfirmationType urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectConfirmationDataType
    //

    SubjectConfirmationDataType::
    SubjectConfirmationDataType ()
    : ::xml_schema::type (),
    _xsd_NotBefore_ (::xml_schema::flags (), this),
    _xsd_NotOnOrAfter_ (::xml_schema::flags (), this),
    _xsd_Recipient_ (::xml_schema::flags (), this),
    _xsd_InResponseTo_ (::xml_schema::flags (), this),
    _xsd_Address_ (::xml_schema::flags (), this)
    {
    }

    SubjectConfirmationDataType::
    SubjectConfirmationDataType (const _xsd_SubjectConfirmationDataType::base_& _xsd_SubjectConfirmationDataType)
    : ::xml_schema::type (_xsd_SubjectConfirmationDataType),
    _xsd_NotBefore_ (::xml_schema::flags (), this),
    _xsd_NotOnOrAfter_ (::xml_schema::flags (), this),
    _xsd_Recipient_ (::xml_schema::flags (), this),
    _xsd_InResponseTo_ (::xml_schema::flags (), this),
    _xsd_Address_ (::xml_schema::flags (), this)
    {
    }

    SubjectConfirmationDataType::
    SubjectConfirmationDataType (const SubjectConfirmationDataType& _xsd_SubjectConfirmationDataType,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_SubjectConfirmationDataType, f, c),
    _xsd_NotBefore_ (_xsd_SubjectConfirmationDataType._xsd_NotBefore_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_NotOnOrAfter_ (_xsd_SubjectConfirmationDataType._xsd_NotOnOrAfter_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_Recipient_ (_xsd_SubjectConfirmationDataType._xsd_Recipient_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_InResponseTo_ (_xsd_SubjectConfirmationDataType._xsd_InResponseTo_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_Address_ (_xsd_SubjectConfirmationDataType._xsd_Address_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    SubjectConfirmationDataType::
    SubjectConfirmationDataType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_NotBefore_ (f | ::xml_schema::flags::not_root, this),
    _xsd_NotOnOrAfter_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Recipient_ (f | ::xml_schema::flags::not_root, this),
    _xsd_InResponseTo_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Address_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void SubjectConfirmationDataType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"NotBefore" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotBefore::type > r (
            NotBefore::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->NotBefore (r);
          continue;
        }

        if (a.name () == L"NotOnOrAfter" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotOnOrAfter::type > r (
            NotOnOrAfter::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->NotOnOrAfter (r);
          continue;
        }

        if (a.name () == L"Recipient" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Recipient::type > r (
            Recipient::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Recipient (r);
          continue;
        }

        if (a.name () == L"InResponseTo" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< InResponseTo::type > r (
            InResponseTo::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->InResponseTo (r);
          continue;
        }

        if (a.name () == L"Address" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Address::type > r (
            Address::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Address (r);
          continue;
        }
      }
    }

    SubjectConfirmationDataType* SubjectConfirmationDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectConfirmationDataType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectConfirmationDataType >
    _xsd_SubjectConfirmationDataType_type_factory_init (
      L"SubjectConfirmationDataType urn:oasis:names:tc:SAML:2.0:assertion");


    // KeyInfoConfirmationDataType
    //

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType ()
    : ::saml2::assertion::SubjectConfirmationDataType ()
    {
    }

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType (const _xsd_KeyInfoConfirmationDataType::base_& _xsd_KeyInfoConfirmationDataType)
    : ::saml2::assertion::SubjectConfirmationDataType (_xsd_KeyInfoConfirmationDataType)
    {
    }

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType (const KeyInfoConfirmationDataType& _xsd_KeyInfoConfirmationDataType,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::saml2::assertion::SubjectConfirmationDataType (_xsd_KeyInfoConfirmationDataType, f, c)
    {
    }

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::saml2::assertion::SubjectConfirmationDataType (e, f, c)
    {
    }

    KeyInfoConfirmationDataType* KeyInfoConfirmationDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new KeyInfoConfirmationDataType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, KeyInfoConfirmationDataType >
    _xsd_KeyInfoConfirmationDataType_type_factory_init (
      L"KeyInfoConfirmationDataType urn:oasis:names:tc:SAML:2.0:assertion");


    // ConditionsType
    //

    ConditionsType::
    ConditionsType ()
    : ::xml_schema::type (),
    _xsd_Condition_ (::xml_schema::flags (), this),
    _xsd_AudienceRestriction_ (::xml_schema::flags (), this),
    _xsd_OneTimeUse_ (::xml_schema::flags (), this),
    _xsd_ProxyRestriction_ (::xml_schema::flags (), this),
    _xsd_NotBefore_ (::xml_schema::flags (), this),
    _xsd_NotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    ConditionsType::
    ConditionsType (const ConditionsType& _xsd_ConditionsType,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_ConditionsType, f, c),
    _xsd_Condition_ (_xsd_ConditionsType._xsd_Condition_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_AudienceRestriction_ (_xsd_ConditionsType._xsd_AudienceRestriction_,
                               f | ::xml_schema::flags::not_root,
                               this),
    _xsd_OneTimeUse_ (_xsd_ConditionsType._xsd_OneTimeUse_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_ProxyRestriction_ (_xsd_ConditionsType._xsd_ProxyRestriction_,
                            f | ::xml_schema::flags::not_root,
                            this),
    _xsd_NotBefore_ (_xsd_ConditionsType._xsd_NotBefore_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_NotOnOrAfter_ (_xsd_ConditionsType._xsd_NotOnOrAfter_,
                        f | ::xml_schema::flags::not_root,
                        this)
    {
    }

    ConditionsType::
    ConditionsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_Condition_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AudienceRestriction_ (f | ::xml_schema::flags::not_root, this),
    _xsd_OneTimeUse_ (f | ::xml_schema::flags::not_root, this),
    _xsd_ProxyRestriction_ (f | ::xml_schema::flags::not_root, this),
    _xsd_NotBefore_ (f | ::xml_schema::flags::not_root, this),
    _xsd_NotOnOrAfter_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void ConditionsType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // Condition
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Condition::type > r (
            tfm.create< Condition::type > (
              L"Condition",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Condition ().push_back (r);
            continue;
          }
        }

        // AudienceRestriction
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AudienceRestriction::type > r (
            tfm.create< AudienceRestriction::type > (
              L"AudienceRestriction",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AudienceRestriction ().push_back (r);
            continue;
          }
        }

        // OneTimeUse
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< OneTimeUse::type > r (
            tfm.create< OneTimeUse::type > (
              L"OneTimeUse",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->OneTimeUse ().push_back (r);
            continue;
          }
        }

        // ProxyRestriction
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ProxyRestriction::type > r (
            tfm.create< ProxyRestriction::type > (
              L"ProxyRestriction",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->ProxyRestriction ().push_back (r);
            continue;
          }
        }
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"NotBefore" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotBefore::type > r (
            NotBefore::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->NotBefore (r);
          continue;
        }

        if (a.name () == L"NotOnOrAfter" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotOnOrAfter::type > r (
            NotOnOrAfter::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->NotOnOrAfter (r);
          continue;
        }
      }
    }

    ConditionsType* ConditionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ConditionsType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConditionsType >
    _xsd_ConditionsType_type_factory_init (
      L"ConditionsType urn:oasis:names:tc:SAML:2.0:assertion");


    // ConditionAbstractType
    //

    ConditionAbstractType::
    ConditionAbstractType ()
    : ::xml_schema::type ()
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ConditionAbstractType& _xsd_ConditionAbstractType,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_ConditionAbstractType, f, c)
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ::std::basic_string< wchar_t >& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    ConditionAbstractType* ConditionAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ConditionAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConditionAbstractType >
    _xsd_ConditionAbstractType_type_factory_init (
      L"ConditionAbstractType urn:oasis:names:tc:SAML:2.0:assertion");


    // AudienceRestrictionType
    //

    AudienceRestrictionType::
    AudienceRestrictionType ()
    : ::saml2::assertion::ConditionAbstractType (),
    _xsd_Audience_ (::xml_schema::flags (), this)
    {
    }

    AudienceRestrictionType::
    AudienceRestrictionType (const AudienceRestrictionType& _xsd_AudienceRestrictionType,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (_xsd_AudienceRestrictionType, f, c),
    _xsd_Audience_ (_xsd_AudienceRestrictionType._xsd_Audience_,
                    f | ::xml_schema::flags::not_root,
                    this)
    {
    }

    AudienceRestrictionType::
    AudienceRestrictionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (e, f, c),
    _xsd_Audience_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AudienceRestrictionType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // Audience
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Audience::type > r (
            tfm.create< Audience::type > (
              L"Audience",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Audience ().push_back (r);
            continue;
          }
        }
      }
    }

    AudienceRestrictionType* AudienceRestrictionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AudienceRestrictionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AudienceRestrictionType >
    _xsd_AudienceRestrictionType_type_factory_init (
      L"AudienceRestrictionType urn:oasis:names:tc:SAML:2.0:assertion");


    // OneTimeUseType
    //

    OneTimeUseType::
    OneTimeUseType ()
    : ::saml2::assertion::ConditionAbstractType ()
    {
    }

    OneTimeUseType::
    OneTimeUseType (const OneTimeUseType& _xsd_OneTimeUseType,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (_xsd_OneTimeUseType, f, c)
    {
    }

    OneTimeUseType::
    OneTimeUseType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (e, f, c)
    {
    }

    OneTimeUseType::
    OneTimeUseType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (a, f, c)
    {
    }

    OneTimeUseType::
    OneTimeUseType (const ::std::basic_string< wchar_t >& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (s, e, f, c)
    {
    }

    OneTimeUseType* OneTimeUseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new OneTimeUseType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OneTimeUseType >
    _xsd_OneTimeUseType_type_factory_init (
      L"OneTimeUseType urn:oasis:names:tc:SAML:2.0:assertion");


    // ProxyRestrictionType
    //

    ProxyRestrictionType::
    ProxyRestrictionType ()
    : ::saml2::assertion::ConditionAbstractType (),
    _xsd_Audience_ (::xml_schema::flags (), this),
    _xsd_Count_ (::xml_schema::flags (), this)
    {
    }

    ProxyRestrictionType::
    ProxyRestrictionType (const ProxyRestrictionType& _xsd_ProxyRestrictionType,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (_xsd_ProxyRestrictionType, f, c),
    _xsd_Audience_ (_xsd_ProxyRestrictionType._xsd_Audience_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_Count_ (_xsd_ProxyRestrictionType._xsd_Count_,
                 f | ::xml_schema::flags::not_root,
                 this)
    {
    }

    ProxyRestrictionType::
    ProxyRestrictionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (e, f, c),
    _xsd_Audience_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Count_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void ProxyRestrictionType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // Audience
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Audience::type > r (
            tfm.create< Audience::type > (
              L"Audience",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Audience ().push_back (r);
            continue;
          }
        }
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"Count" && a.namespace_ ().empty ())
        {
          this->Count (
            Count::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));
          continue;
        }
      }
    }

    ProxyRestrictionType* ProxyRestrictionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ProxyRestrictionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ProxyRestrictionType >
    _xsd_ProxyRestrictionType_type_factory_init (
      L"ProxyRestrictionType urn:oasis:names:tc:SAML:2.0:assertion");


    // AdviceType
    //

    AdviceType::
    AdviceType ()
    : ::xml_schema::type (),
    _xsd_AssertionIDRef_ (::xml_schema::flags (), this),
    _xsd_AssertionURIRef_ (::xml_schema::flags (), this),
    _xsd_Assertion_ (::xml_schema::flags (), this),
    _xsd_EncryptedAssertion_ (::xml_schema::flags (), this)
    {
    }

    AdviceType::
    AdviceType (const AdviceType& _xsd_AdviceType,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_AdviceType, f, c),
    _xsd_AssertionIDRef_ (_xsd_AdviceType._xsd_AssertionIDRef_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_AssertionURIRef_ (_xsd_AdviceType._xsd_AssertionURIRef_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_Assertion_ (_xsd_AdviceType._xsd_Assertion_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_EncryptedAssertion_ (_xsd_AdviceType._xsd_EncryptedAssertion_,
                              f | ::xml_schema::flags::not_root,
                              this)
    {
    }

    AdviceType::
    AdviceType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_AssertionIDRef_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AssertionURIRef_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Assertion_ (f | ::xml_schema::flags::not_root, this),
    _xsd_EncryptedAssertion_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AdviceType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // AssertionIDRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AssertionIDRef::type > r (
            tfm.create< AssertionIDRef::type > (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AssertionIDRef ().push_back (r);
            continue;
          }
        }

        // AssertionURIRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AssertionURIRef::type > r (
            tfm.create< AssertionURIRef::type > (
              L"AssertionURIRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AssertionURIRef ().push_back (r);
            continue;
          }
        }

        // Assertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Assertion::type > r (
            tfm.create< Assertion::type > (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Assertion ().push_back (r);
            continue;
          }
        }

        // EncryptedAssertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< EncryptedAssertion::type > r (
            tfm.create< EncryptedAssertion::type > (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->EncryptedAssertion ().push_back (r);
            continue;
          }
        }
      }
    }

    AdviceType* AdviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AdviceType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AdviceType >
    _xsd_AdviceType_type_factory_init (
      L"AdviceType urn:oasis:names:tc:SAML:2.0:assertion");


    // StatementAbstractType
    //

    StatementAbstractType::
    StatementAbstractType ()
    : ::xml_schema::type ()
    {
    }

    StatementAbstractType::
    StatementAbstractType (const StatementAbstractType& _xsd_StatementAbstractType,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_StatementAbstractType, f, c)
    {
    }

    StatementAbstractType::
    StatementAbstractType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    StatementAbstractType::
    StatementAbstractType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    StatementAbstractType::
    StatementAbstractType (const ::std::basic_string< wchar_t >& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    StatementAbstractType* StatementAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new StatementAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StatementAbstractType >
    _xsd_StatementAbstractType_type_factory_init (
      L"StatementAbstractType urn:oasis:names:tc:SAML:2.0:assertion");


    // AuthnStatementType
    //

    AuthnStatementType::
    AuthnStatementType ()
    : ::saml2::assertion::StatementAbstractType (),
    _xsd_SubjectLocality_ (::xml_schema::flags (), this),
    _xsd_AuthnContext_ (::xml_schema::flags (), this),
    _xsd_AuthnInstant_ (::xml_schema::flags (), this),
    _xsd_SessionIndex_ (::xml_schema::flags (), this),
    _xsd_SessionNotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    AuthnStatementType::
    AuthnStatementType (const AuthnContext::type& _xsd_AuthnContext,
                        const AuthnInstant::type& _xsd_AuthnInstant)
    : ::saml2::assertion::StatementAbstractType (),
    _xsd_SubjectLocality_ (::xml_schema::flags (), this),
    _xsd_AuthnContext_ (_xsd_AuthnContext,
                        ::xml_schema::flags (),
                        this),
    _xsd_AuthnInstant_ (_xsd_AuthnInstant,
                        ::xml_schema::flags (),
                        this),
    _xsd_SessionIndex_ (::xml_schema::flags (), this),
    _xsd_SessionNotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    AuthnStatementType::
    AuthnStatementType (const AuthnStatementType& _xsd_AuthnStatementType,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (_xsd_AuthnStatementType, f, c),
    _xsd_SubjectLocality_ (_xsd_AuthnStatementType._xsd_SubjectLocality_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_AuthnContext_ (_xsd_AuthnStatementType._xsd_AuthnContext_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_AuthnInstant_ (_xsd_AuthnStatementType._xsd_AuthnInstant_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_SessionIndex_ (_xsd_AuthnStatementType._xsd_SessionIndex_,
                        f | ::xml_schema::flags::not_root,
                        this),
    _xsd_SessionNotOnOrAfter_ (_xsd_AuthnStatementType._xsd_SessionNotOnOrAfter_,
                               f | ::xml_schema::flags::not_root,
                               this)
    {
    }

    AuthnStatementType::
    AuthnStatementType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (e, f, c),
    _xsd_SubjectLocality_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AuthnContext_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AuthnInstant_ (f | ::xml_schema::flags::not_root, this),
    _xsd_SessionIndex_ (f | ::xml_schema::flags::not_root, this),
    _xsd_SessionNotOnOrAfter_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AuthnStatementType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // SubjectLocality
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< SubjectLocality::type > r (
            tfm.create< SubjectLocality::type > (
              L"SubjectLocality",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->SubjectLocality ())
              continue;
            this->SubjectLocality (r);
            continue;
          }
        }

        // AuthnContext
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AuthnContext::type > r (
            tfm.create< AuthnContext::type > (
              L"AuthnContext",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (_xsd_AuthnContext_.present ())
              continue;
            this->AuthnContext (r);
            continue;
          }
        }
      }

      if (!_xsd_AuthnContext_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:assertion");
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"AuthnInstant" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< AuthnInstant::type > r (
            AuthnInstant::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->AuthnInstant (r);
          continue;
        }

        if (a.name () == L"SessionIndex" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< SessionIndex::type > r (
            SessionIndex::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->SessionIndex (r);
          continue;
        }

        if (a.name () == L"SessionNotOnOrAfter" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< SessionNotOnOrAfter::type > r (
            SessionNotOnOrAfter::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->SessionNotOnOrAfter (r);
          continue;
        }
      }

      if (!_xsd_AuthnInstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"AuthnInstant",
          L"");
      }
    }

    AuthnStatementType* AuthnStatementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnStatementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnStatementType >
    _xsd_AuthnStatementType_type_factory_init (
      L"AuthnStatementType urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectLocalityType
    //

    SubjectLocalityType::
    SubjectLocalityType ()
    : ::xml_schema::type (),
    _xsd_Address_ (::xml_schema::flags (), this),
    _xsd_DNSName_ (::xml_schema::flags (), this)
    {
    }

    SubjectLocalityType::
    SubjectLocalityType (const SubjectLocalityType& _xsd_SubjectLocalityType,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_SubjectLocalityType, f, c),
    _xsd_Address_ (_xsd_SubjectLocalityType._xsd_Address_,
                   f | ::xml_schema::flags::not_root,
                   this),
    _xsd_DNSName_ (_xsd_SubjectLocalityType._xsd_DNSName_,
                   f | ::xml_schema::flags::not_root,
                   this)
    {
    }

    SubjectLocalityType::
    SubjectLocalityType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_Address_ (f | ::xml_schema::flags::not_root, this),
    _xsd_DNSName_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void SubjectLocalityType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"Address" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Address::type > r (
            Address::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Address (r);
          continue;
        }

        if (a.name () == L"DNSName" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< DNSName::type > r (
            DNSName::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->DNSName (r);
          continue;
        }
      }
    }

    SubjectLocalityType* SubjectLocalityType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectLocalityType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectLocalityType >
    _xsd_SubjectLocalityType_type_factory_init (
      L"SubjectLocalityType urn:oasis:names:tc:SAML:2.0:assertion");


    // AuthnContextType
    //

    AuthnContextType::
    AuthnContextType ()
    : ::xml_schema::type (),
    _xsd_AuthnContextClassRef_ (::xml_schema::flags (), this),
    _xsd_AuthnContextDecl_ (::xml_schema::flags (), this),
    _xsd_AuthnContextDeclRef_ (::xml_schema::flags (), this),
    _xsd_AuthenticatingAuthority_ (::xml_schema::flags (), this)
    {
    }

    AuthnContextType::
    AuthnContextType (const AuthnContextType& _xsd_AuthnContextType,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_AuthnContextType, f, c),
    _xsd_AuthnContextClassRef_ (_xsd_AuthnContextType._xsd_AuthnContextClassRef_,
                                f | ::xml_schema::flags::not_root,
                                this),
    _xsd_AuthnContextDecl_ (_xsd_AuthnContextType._xsd_AuthnContextDecl_,
                            f | ::xml_schema::flags::not_root,
                            this),
    _xsd_AuthnContextDeclRef_ (_xsd_AuthnContextType._xsd_AuthnContextDeclRef_,
                               f | ::xml_schema::flags::not_root,
                               this),
    _xsd_AuthenticatingAuthority_ (_xsd_AuthnContextType._xsd_AuthenticatingAuthority_,
                                   f | ::xml_schema::flags::not_root,
                                   this)
    {
    }

    AuthnContextType::
    AuthnContextType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_AuthnContextClassRef_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AuthnContextDecl_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AuthnContextDeclRef_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AuthenticatingAuthority_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AuthnContextType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // AuthnContextClassRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AuthnContextClassRef::type > r (
            tfm.create< AuthnContextClassRef::type > (
              L"AuthnContextClassRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->AuthnContextClassRef ())
              continue;
            this->AuthnContextClassRef (r);
            continue;
          }
        }

        // AuthnContextDecl
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AuthnContextDecl::type > r (
            tfm.create< AuthnContextDecl::type > (
              L"AuthnContextDecl",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->AuthnContextDecl ())
              continue;
            this->AuthnContextDecl (r);
            continue;
          }
        }

        // AuthnContextDeclRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AuthnContextDeclRef::type > r (
            tfm.create< AuthnContextDeclRef::type > (
              L"AuthnContextDeclRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->AuthnContextDeclRef ())
              continue;
            this->AuthnContextDeclRef (r);
            continue;
          }
        }

        // AuthenticatingAuthority
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AuthenticatingAuthority::type > r (
            tfm.create< AuthenticatingAuthority::type > (
              L"AuthenticatingAuthority",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AuthenticatingAuthority ().push_back (r);
            continue;
          }
        }
      }
    }

    AuthnContextType* AuthnContextType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnContextType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnContextType >
    _xsd_AuthnContextType_type_factory_init (
      L"AuthnContextType urn:oasis:names:tc:SAML:2.0:assertion");


    // AuthzDecisionStatementType
    //

    AuthzDecisionStatementType::
    AuthzDecisionStatementType ()
    : ::saml2::assertion::StatementAbstractType (),
    _xsd_Action_ (::xml_schema::flags (), this),
    _xsd_Evidence_ (::xml_schema::flags (), this),
    _xsd_Resource_ (::xml_schema::flags (), this),
    _xsd_Decision_ (::xml_schema::flags (), this)
    {
    }

    AuthzDecisionStatementType::
    AuthzDecisionStatementType (const Resource::type& _xsd_Resource,
                                const Decision::type& _xsd_Decision)
    : ::saml2::assertion::StatementAbstractType (),
    _xsd_Action_ (::xml_schema::flags (), this),
    _xsd_Evidence_ (::xml_schema::flags (), this),
    _xsd_Resource_ (_xsd_Resource,
                    ::xml_schema::flags (),
                    this),
    _xsd_Decision_ (_xsd_Decision,
                    ::xml_schema::flags (),
                    this)
    {
    }

    AuthzDecisionStatementType::
    AuthzDecisionStatementType (const AuthzDecisionStatementType& _xsd_AuthzDecisionStatementType,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (_xsd_AuthzDecisionStatementType, f, c),
    _xsd_Action_ (_xsd_AuthzDecisionStatementType._xsd_Action_,
                  f | ::xml_schema::flags::not_root,
                  this),
    _xsd_Evidence_ (_xsd_AuthzDecisionStatementType._xsd_Evidence_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_Resource_ (_xsd_AuthzDecisionStatementType._xsd_Resource_,
                    f | ::xml_schema::flags::not_root,
                    this),
    _xsd_Decision_ (_xsd_AuthzDecisionStatementType._xsd_Decision_,
                    f | ::xml_schema::flags::not_root,
                    this)
    {
    }

    AuthzDecisionStatementType::
    AuthzDecisionStatementType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (e, f, c),
    _xsd_Action_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Evidence_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Resource_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Decision_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AuthzDecisionStatementType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // Action
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Action::type > r (
            tfm.create< Action::type > (
              L"Action",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Action ().push_back (r);
            continue;
          }
        }

        // Evidence
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Evidence::type > r (
            tfm.create< Evidence::type > (
              L"Evidence",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            if (this->Evidence ())
              continue;
            this->Evidence (r);
            continue;
          }
        }
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"Resource" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Resource::type > r (
            Resource::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Resource (r);
          continue;
        }

        if (a.name () == L"Decision" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Decision::type > r (
            Decision::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Decision (r);
          continue;
        }
      }

      if (!_xsd_Resource_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Resource",
          L"");
      }

      if (!_xsd_Decision_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Decision",
          L"");
      }
    }

    AuthzDecisionStatementType* AuthzDecisionStatementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthzDecisionStatementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthzDecisionStatementType >
    _xsd_AuthzDecisionStatementType_type_factory_init (
      L"AuthzDecisionStatementType urn:oasis:names:tc:SAML:2.0:assertion");


    // DecisionType
    //

    DecisionType::
    DecisionType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_DecisionType_convert ();
    }

    DecisionType::
    DecisionType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_DecisionType_convert ();
    }

    DecisionType::
    DecisionType (const ::std::basic_string< wchar_t >& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_DecisionType_convert ();
    }

    DecisionType* DecisionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new DecisionType (*this, f, c);
    }

    DecisionType::_xsd_DecisionType DecisionType::
    _xsd_DecisionType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DecisionType_literals_);
      const _xsd_DecisionType* i (::std::lower_bound (
                                    _xsd_DecisionType_indexes_,
                                    _xsd_DecisionType_indexes_ + 3,
                                    *this,
                                    c));

      if (i == _xsd_DecisionType_indexes_ + 3 || _xsd_DecisionType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DecisionType::
    _xsd_DecisionType_literals_[3] =
    {
      L"Permit",
      L"Deny",
      L"Indeterminate"
    };

    const DecisionType::_xsd_DecisionType DecisionType::
    _xsd_DecisionType_indexes_[3] =
    {
      ::saml2::assertion::DecisionType::Deny,
      ::saml2::assertion::DecisionType::Indeterminate,
      ::saml2::assertion::DecisionType::Permit
    };

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DecisionType >
    _xsd_DecisionType_type_factory_init (
      L"DecisionType urn:oasis:names:tc:SAML:2.0:assertion");


    // ActionType
    //

    ActionType::
    ActionType ()
    : ::xml_schema::string (),
    _xsd_Namespace_ (::xml_schema::flags (), this)
    {
    }

    ActionType::
    ActionType (const _xsd_ActionType::base_& _xsd_ActionType,
                const Namespace::type& _xsd_Namespace)
    : ::xml_schema::string (_xsd_ActionType),
    _xsd_Namespace_ (_xsd_Namespace,
                     ::xml_schema::flags (),
                     this)
    {
    }

    ActionType::
    ActionType (const ActionType& _xsd_ActionType,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (_xsd_ActionType, f, c),
    _xsd_Namespace_ (_xsd_ActionType._xsd_Namespace_,
                     f | ::xml_schema::flags::not_root,
                     this)
    {
    }

    ActionType::
    ActionType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c),
    _xsd_Namespace_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void ActionType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"Namespace" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Namespace::type > r (
            Namespace::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Namespace (r);
          continue;
        }
      }

      if (!_xsd_Namespace_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Namespace",
          L"");
      }
    }

    ActionType* ActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ActionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ActionType >
    _xsd_ActionType_type_factory_init (
      L"ActionType urn:oasis:names:tc:SAML:2.0:assertion");


    // EvidenceType
    //

    EvidenceType::
    EvidenceType ()
    : ::xml_schema::type (),
    _xsd_AssertionIDRef_ (::xml_schema::flags (), this),
    _xsd_AssertionURIRef_ (::xml_schema::flags (), this),
    _xsd_Assertion_ (::xml_schema::flags (), this),
    _xsd_EncryptedAssertion_ (::xml_schema::flags (), this)
    {
    }

    EvidenceType::
    EvidenceType (const EvidenceType& _xsd_EvidenceType,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_EvidenceType, f, c),
    _xsd_AssertionIDRef_ (_xsd_EvidenceType._xsd_AssertionIDRef_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_AssertionURIRef_ (_xsd_EvidenceType._xsd_AssertionURIRef_,
                           f | ::xml_schema::flags::not_root,
                           this),
    _xsd_Assertion_ (_xsd_EvidenceType._xsd_Assertion_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_EncryptedAssertion_ (_xsd_EvidenceType._xsd_EncryptedAssertion_,
                              f | ::xml_schema::flags::not_root,
                              this)
    {
    }

    EvidenceType::
    EvidenceType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_AssertionIDRef_ (f | ::xml_schema::flags::not_root, this),
    _xsd_AssertionURIRef_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Assertion_ (f | ::xml_schema::flags::not_root, this),
    _xsd_EncryptedAssertion_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void EvidenceType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // AssertionIDRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AssertionIDRef::type > r (
            tfm.create< AssertionIDRef::type > (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AssertionIDRef ().push_back (r);
            continue;
          }
        }

        // AssertionURIRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AssertionURIRef::type > r (
            tfm.create< AssertionURIRef::type > (
              L"AssertionURIRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AssertionURIRef ().push_back (r);
            continue;
          }
        }

        // Assertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Assertion::type > r (
            tfm.create< Assertion::type > (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Assertion ().push_back (r);
            continue;
          }
        }

        // EncryptedAssertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< EncryptedAssertion::type > r (
            tfm.create< EncryptedAssertion::type > (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->EncryptedAssertion ().push_back (r);
            continue;
          }
        }
      }
    }

    EvidenceType* EvidenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new EvidenceType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EvidenceType >
    _xsd_EvidenceType_type_factory_init (
      L"EvidenceType urn:oasis:names:tc:SAML:2.0:assertion");


    // AttributeStatementType
    //

    AttributeStatementType::
    AttributeStatementType ()
    : ::saml2::assertion::StatementAbstractType (),
    _xsd_Attribute_ (::xml_schema::flags (), this),
    _xsd_EncryptedAttribute_ (::xml_schema::flags (), this)
    {
    }

    AttributeStatementType::
    AttributeStatementType (const AttributeStatementType& _xsd_AttributeStatementType,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (_xsd_AttributeStatementType, f, c),
    _xsd_Attribute_ (_xsd_AttributeStatementType._xsd_Attribute_,
                     f | ::xml_schema::flags::not_root,
                     this),
    _xsd_EncryptedAttribute_ (_xsd_AttributeStatementType._xsd_EncryptedAttribute_,
                              f | ::xml_schema::flags::not_root,
                              this)
    {
    }

    AttributeStatementType::
    AttributeStatementType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (e, f, c),
    _xsd_Attribute_ (f | ::xml_schema::flags::not_root, this),
    _xsd_EncryptedAttribute_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AttributeStatementType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // Attribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< Attribute::type > r (
            tfm.create< Attribute::type > (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->Attribute ().push_back (r);
            continue;
          }
        }

        // EncryptedAttribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< EncryptedAttribute::type > r (
            tfm.create< EncryptedAttribute::type > (
              L"EncryptedAttribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->EncryptedAttribute ().push_back (r);
            continue;
          }
        }
      }
    }

    AttributeStatementType* AttributeStatementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AttributeStatementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeStatementType >
    _xsd_AttributeStatementType_type_factory_init (
      L"AttributeStatementType urn:oasis:names:tc:SAML:2.0:assertion");


    // AttributeType
    //

    AttributeType::
    AttributeType ()
    : ::xml_schema::type (),
    _xsd_AttributeValue_ (::xml_schema::flags (), this),
    _xsd_Name_ (::xml_schema::flags (), this),
    _xsd_NameFormat_ (::xml_schema::flags (), this),
    _xsd_FriendlyName_ (::xml_schema::flags (), this)
    {
    }

    AttributeType::
    AttributeType (const Name::type& _xsd_Name)
    : ::xml_schema::type (),
    _xsd_AttributeValue_ (::xml_schema::flags (), this),
    _xsd_Name_ (_xsd_Name,
                ::xml_schema::flags (),
                this),
    _xsd_NameFormat_ (::xml_schema::flags (), this),
    _xsd_FriendlyName_ (::xml_schema::flags (), this)
    {
    }

    AttributeType::
    AttributeType (const AttributeType& _xsd_AttributeType,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (_xsd_AttributeType, f, c),
    _xsd_AttributeValue_ (_xsd_AttributeType._xsd_AttributeValue_,
                          f | ::xml_schema::flags::not_root,
                          this),
    _xsd_Name_ (_xsd_AttributeType._xsd_Name_,
                f | ::xml_schema::flags::not_root,
                this),
    _xsd_NameFormat_ (_xsd_AttributeType._xsd_NameFormat_,
                      f | ::xml_schema::flags::not_root,
                      this),
    _xsd_FriendlyName_ (_xsd_AttributeType._xsd_FriendlyName_,
                        f | ::xml_schema::flags::not_root,
                        this)
    {
    }

    AttributeType::
    AttributeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c),
    _xsd_AttributeValue_ (f | ::xml_schema::flags::not_root, this),
    _xsd_Name_ (f | ::xml_schema::flags::not_root, this),
    _xsd_NameFormat_ (f | ::xml_schema::flags::not_root, this),
    _xsd_FriendlyName_ (f | ::xml_schema::flags::not_root, this)
    {
      parse (e, f);
    }

    void AttributeType::
    parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e);

      while (p.more_elements ())
      {
        const ::xsd::cxx::xml::dom::element< wchar_t > e (p.next_element ());

        // AttributeValue
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< AttributeValue::type > r (
            tfm.create< AttributeValue::type > (
              L"AttributeValue",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true,
              true,
              e,
              f | ::xml_schema::flags::not_root,
              this));

          if (r.get () != 0)
          {
            this->AttributeValue ().push_back (r);
            continue;
          }
        }
      }

      while (p.more_attributes ())
      {
        const ::xsd::cxx::xml::dom::attribute< wchar_t > a (p.next_attribute ());

        if (a.name () == L"Name" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< Name::type > r (
            Name::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->Name (r);
          continue;
        }

        if (a.name () == L"NameFormat" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameFormat::type > r (
            NameFormat::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->NameFormat (r);
          continue;
        }

        if (a.name () == L"FriendlyName" && a.namespace_ ().empty ())
        {
          ::std::auto_ptr< FriendlyName::type > r (
            FriendlyName::traits::create (
              a.dom_attribute (),
              f | ::xml_schema::flags::not_root,
              this));

          this->FriendlyName (r);
          continue;
        }
      }

      if (!_xsd_Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Name",
          L"");
      }
    }

    AttributeType* AttributeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AttributeType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeType >
    _xsd_AttributeType_type_factory_init (
      L"AttributeType urn:oasis:names:tc:SAML:2.0:assertion");
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace saml2
{
  namespace assertion
  {
    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::std::basic_string< wchar_t >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::BaseID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::std::basic_string< wchar_t >& u,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::BaseID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::std::basic_string< wchar_t >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::BaseID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::BaseID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::BaseID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::BaseID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
        tfm.create< ::saml2::assertion::BaseIDAbstractType > (
          L"BaseID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"BaseID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::std::basic_string< wchar_t >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::NameID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::std::basic_string< wchar_t >& u,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::NameID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::std::basic_string< wchar_t >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::NameID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::NameID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::NameID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::NameID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        tfm.create< ::saml2::assertion::NameIDType > (
          L"NameID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"NameID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::std::basic_string< wchar_t >& u,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::EncryptedID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::std::basic_string< wchar_t >& u,
                 ::xsd::cxx::xml::error_handler< wchar_t >& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::std::basic_string< wchar_t >& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 ::xsd::cxx::xml::error_handler< wchar_t >& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 const ::std::basic_string< wchar_t >& sid,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 const ::std::basic_string< wchar_t >& sid,
                 ::xsd::cxx::xml::error_handler< wchar_t >& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 const ::std::basic_string< wchar_t >& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::EncryptedID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMInputSource& i,
                 ::xsd::cxx::xml::error_handler< wchar_t >& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMInputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedID (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        tfm.create< ::saml2::assertion::EncryptedElementType > (
          L"EncryptedID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"EncryptedID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::std::basic_string< wchar_t >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Issuer (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::std::basic_string< wchar_t >& u,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Issuer (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::std::basic_string< wchar_t >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Issuer (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Issuer (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Issuer (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Issuer (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        tfm.create< ::saml2::assertion::NameIDType > (
          L"Issuer",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Issuer",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::std::basic_string< wchar_t >& u,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AssertionIDRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::std::basic_string< wchar_t >& u,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionIDRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::std::basic_string< wchar_t >& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionIDRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AssertionIDRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMInputSource& i,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionIDRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionIDRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::ncname > r (
        tfm.create< ::xml_schema::ncname > (
          L"AssertionIDRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AssertionIDRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::std::basic_string< wchar_t >& u,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AssertionURIRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::std::basic_string< wchar_t >& u,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionURIRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::std::basic_string< wchar_t >& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionURIRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     const ::std::basic_string< wchar_t >& sid,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     const ::std::basic_string< wchar_t >& sid,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     const ::std::basic_string< wchar_t >& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AssertionURIRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMInputSource& i,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionURIRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AssertionURIRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::uri > r (
        tfm.create< ::xml_schema::uri > (
          L"AssertionURIRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AssertionURIRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::std::basic_string< wchar_t >& u,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Assertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::std::basic_string< wchar_t >& u,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Assertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::std::basic_string< wchar_t >& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Assertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Assertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMInputSource& i,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Assertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Assertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
        tfm.create< ::saml2::assertion::AssertionType > (
          L"Assertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Assertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::std::basic_string< wchar_t >& u,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Subject (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::std::basic_string< wchar_t >& u,
             ::xsd::cxx::xml::error_handler< wchar_t >& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Subject (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::std::basic_string< wchar_t >& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Subject (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             ::xsd::cxx::xml::error_handler< wchar_t >& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             const ::std::basic_string< wchar_t >& sid,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             const ::std::basic_string< wchar_t >& sid,
             ::xsd::cxx::xml::error_handler< wchar_t >& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             const ::std::basic_string< wchar_t >& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Subject (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMInputSource& i,
             ::xsd::cxx::xml::error_handler< wchar_t >& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Subject (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Subject (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
        tfm.create< ::saml2::assertion::SubjectType > (
          L"Subject",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Subject",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::std::basic_string< wchar_t >& u,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::SubjectConfirmation (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::std::basic_string< wchar_t >& u,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmation (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::std::basic_string< wchar_t >& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmation (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::SubjectConfirmation (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMInputSource& i,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmation (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmation (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
        tfm.create< ::saml2::assertion::SubjectConfirmationType > (
          L"SubjectConfirmation",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"SubjectConfirmation",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::std::basic_string< wchar_t >& u,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::SubjectConfirmationData (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::std::basic_string< wchar_t >& u,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmationData (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::std::basic_string< wchar_t >& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmationData (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             const ::std::basic_string< wchar_t >& sid,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             const ::std::basic_string< wchar_t >& sid,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             const ::std::basic_string< wchar_t >& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::SubjectConfirmationData (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMInputSource& i,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmationData (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMInputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectConfirmationData (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
        tfm.create< ::saml2::assertion::SubjectConfirmationDataType > (
          L"SubjectConfirmationData",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"SubjectConfirmationData",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::std::basic_string< wchar_t >& u,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Conditions (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::std::basic_string< wchar_t >& u,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Conditions (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::std::basic_string< wchar_t >& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Conditions (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                const ::std::basic_string< wchar_t >& sid,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                const ::std::basic_string< wchar_t >& sid,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                const ::std::basic_string< wchar_t >& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Conditions (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMInputSource& i,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Conditions (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Conditions (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
        tfm.create< ::saml2::assertion::ConditionsType > (
          L"Conditions",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Conditions",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::std::basic_string< wchar_t >& u,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Condition (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::std::basic_string< wchar_t >& u,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Condition (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::std::basic_string< wchar_t >& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Condition (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Condition (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMInputSource& i,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Condition (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Condition (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
        tfm.create< ::saml2::assertion::ConditionAbstractType > (
          L"Condition",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Condition",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::std::basic_string< wchar_t >& u,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AudienceRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::std::basic_string< wchar_t >& u,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AudienceRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::std::basic_string< wchar_t >& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AudienceRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AudienceRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMInputSource& i,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AudienceRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AudienceRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
        tfm.create< ::saml2::assertion::AudienceRestrictionType > (
          L"AudienceRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AudienceRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::std::basic_string< wchar_t >& u,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Audience (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::std::basic_string< wchar_t >& u,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Audience (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::std::basic_string< wchar_t >& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Audience (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              const ::std::basic_string< wchar_t >& sid,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              const ::std::basic_string< wchar_t >& sid,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              const ::std::basic_string< wchar_t >& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Audience (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMInputSource& i,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Audience (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Audience (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::uri > r (
        tfm.create< ::xml_schema::uri > (
          L"Audience",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Audience",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::std::basic_string< wchar_t >& u,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::OneTimeUse (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::std::basic_string< wchar_t >& u,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::OneTimeUse (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::std::basic_string< wchar_t >& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::OneTimeUse (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                const ::std::basic_string< wchar_t >& sid,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                const ::std::basic_string< wchar_t >& sid,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                const ::std::basic_string< wchar_t >& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::OneTimeUse (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMInputSource& i,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::OneTimeUse (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::OneTimeUse (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
        tfm.create< ::saml2::assertion::OneTimeUseType > (
          L"OneTimeUse",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"OneTimeUse",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::std::basic_string< wchar_t >& u,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::ProxyRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::std::basic_string< wchar_t >& u,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::ProxyRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::std::basic_string< wchar_t >& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::ProxyRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      const ::std::basic_string< wchar_t >& sid,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      const ::std::basic_string< wchar_t >& sid,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      const ::std::basic_string< wchar_t >& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::ProxyRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMInputSource& i,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::ProxyRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::ProxyRestriction (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
        tfm.create< ::saml2::assertion::ProxyRestrictionType > (
          L"ProxyRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"ProxyRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::std::basic_string< wchar_t >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Advice (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::std::basic_string< wchar_t >& u,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Advice (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::std::basic_string< wchar_t >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Advice (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Advice (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Advice (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Advice (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
        tfm.create< ::saml2::assertion::AdviceType > (
          L"Advice",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Advice",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::std::basic_string< wchar_t >& u,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::EncryptedAssertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::std::basic_string< wchar_t >& u,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAssertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::std::basic_string< wchar_t >& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAssertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::EncryptedAssertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMInputSource& i,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAssertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAssertion (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        tfm.create< ::saml2::assertion::EncryptedElementType > (
          L"EncryptedAssertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"EncryptedAssertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::std::basic_string< wchar_t >& u,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Statement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::std::basic_string< wchar_t >& u,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Statement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::std::basic_string< wchar_t >& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Statement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Statement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMInputSource& i,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Statement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Statement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
        tfm.create< ::saml2::assertion::StatementAbstractType > (
          L"Statement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Statement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::std::basic_string< wchar_t >& u,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::std::basic_string< wchar_t >& u,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::std::basic_string< wchar_t >& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMInputSource& i,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
        tfm.create< ::saml2::assertion::AuthnStatementType > (
          L"AuthnStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AuthnStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::std::basic_string< wchar_t >& u,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::SubjectLocality (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::std::basic_string< wchar_t >& u,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectLocality (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::std::basic_string< wchar_t >& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectLocality (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     const ::std::basic_string< wchar_t >& sid,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     const ::std::basic_string< wchar_t >& sid,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     const ::std::basic_string< wchar_t >& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::SubjectLocality (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMInputSource& i,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectLocality (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::SubjectLocality (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
        tfm.create< ::saml2::assertion::SubjectLocalityType > (
          L"SubjectLocality",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"SubjectLocality",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::std::basic_string< wchar_t >& u,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContext (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::std::basic_string< wchar_t >& u,
                  ::xsd::cxx::xml::error_handler< wchar_t >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContext (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::std::basic_string< wchar_t >& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContext (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  ::xsd::cxx::xml::error_handler< wchar_t >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  const ::std::basic_string< wchar_t >& sid,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  const ::std::basic_string< wchar_t >& sid,
                  ::xsd::cxx::xml::error_handler< wchar_t >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  const ::std::basic_string< wchar_t >& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContext (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMInputSource& i,
                  ::xsd::cxx::xml::error_handler< wchar_t >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContext (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContext (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
        tfm.create< ::saml2::assertion::AuthnContextType > (
          L"AuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AuthnContext",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::std::basic_string< wchar_t >& u,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContextClassRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::std::basic_string< wchar_t >& u,
                          ::xsd::cxx::xml::error_handler< wchar_t >& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextClassRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::std::basic_string< wchar_t >& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextClassRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          ::xsd::cxx::xml::error_handler< wchar_t >& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          const ::std::basic_string< wchar_t >& sid,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          const ::std::basic_string< wchar_t >& sid,
                          ::xsd::cxx::xml::error_handler< wchar_t >& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          const ::std::basic_string< wchar_t >& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContextClassRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMInputSource& i,
                          ::xsd::cxx::xml::error_handler< wchar_t >& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextClassRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMInputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextClassRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::uri > r (
        tfm.create< ::xml_schema::uri > (
          L"AuthnContextClassRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AuthnContextClassRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::std::basic_string< wchar_t >& u,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContextDeclRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::std::basic_string< wchar_t >& u,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDeclRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::std::basic_string< wchar_t >& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDeclRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         const ::std::basic_string< wchar_t >& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContextDeclRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMInputSource& i,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDeclRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDeclRef (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::uri > r (
        tfm.create< ::xml_schema::uri > (
          L"AuthnContextDeclRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AuthnContextDeclRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::std::basic_string< wchar_t >& u,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContextDecl (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::std::basic_string< wchar_t >& u,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDecl (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::std::basic_string< wchar_t >& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDecl (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      const ::std::basic_string< wchar_t >& sid,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      const ::std::basic_string< wchar_t >& sid,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      const ::std::basic_string< wchar_t >& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthnContextDecl (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMInputSource& i,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDecl (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthnContextDecl (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > r (
        tfm.create< ::xml_schema::type > (
          L"AuthnContextDecl",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AuthnContextDecl",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::std::basic_string< wchar_t >& u,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthenticatingAuthority (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::std::basic_string< wchar_t >& u,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthenticatingAuthority (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::std::basic_string< wchar_t >& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthenticatingAuthority (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             const ::std::basic_string< wchar_t >& sid,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             const ::std::basic_string< wchar_t >& sid,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             const ::std::basic_string< wchar_t >& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthenticatingAuthority (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMInputSource& i,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthenticatingAuthority (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMInputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthenticatingAuthority (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::uri > r (
        tfm.create< ::xml_schema::uri > (
          L"AuthenticatingAuthority",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AuthenticatingAuthority",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::std::basic_string< wchar_t >& u,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthzDecisionStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::std::basic_string< wchar_t >& u,
                            ::xsd::cxx::xml::error_handler< wchar_t >& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthzDecisionStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::std::basic_string< wchar_t >& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthzDecisionStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            ::xsd::cxx::xml::error_handler< wchar_t >& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            const ::std::basic_string< wchar_t >& sid,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            const ::std::basic_string< wchar_t >& sid,
                            ::xsd::cxx::xml::error_handler< wchar_t >& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            const ::std::basic_string< wchar_t >& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMInputSource& i,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AuthzDecisionStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMInputSource& i,
                            ::xsd::cxx::xml::error_handler< wchar_t >& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthzDecisionStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMInputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AuthzDecisionStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
        tfm.create< ::saml2::assertion::AuthzDecisionStatementType > (
          L"AuthzDecisionStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AuthzDecisionStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::std::basic_string< wchar_t >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Action (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::std::basic_string< wchar_t >& u,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Action (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::std::basic_string< wchar_t >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Action (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            const ::std::basic_string< wchar_t >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Action (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Action (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Action (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::ActionType > r (
        tfm.create< ::saml2::assertion::ActionType > (
          L"Action",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Action",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::std::basic_string< wchar_t >& u,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Evidence (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::std::basic_string< wchar_t >& u,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Evidence (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::std::basic_string< wchar_t >& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Evidence (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              const ::std::basic_string< wchar_t >& sid,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              const ::std::basic_string< wchar_t >& sid,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              const ::std::basic_string< wchar_t >& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Evidence (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMInputSource& i,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Evidence (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Evidence (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
        tfm.create< ::saml2::assertion::EvidenceType > (
          L"Evidence",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Evidence",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::std::basic_string< wchar_t >& u,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AttributeStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::std::basic_string< wchar_t >& u,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::std::basic_string< wchar_t >& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AttributeStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMInputSource& i,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeStatement (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
        tfm.create< ::saml2::assertion::AttributeStatementType > (
          L"AttributeStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AttributeStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::std::basic_string< wchar_t >& u,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Attribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::std::basic_string< wchar_t >& u,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Attribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::std::basic_string< wchar_t >& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Attribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               const ::std::basic_string< wchar_t >& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::Attribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMInputSource& i,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Attribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::Attribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
        tfm.create< ::saml2::assertion::AttributeType > (
          L"Attribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"Attribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::std::basic_string< wchar_t >& u,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AttributeValue (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::std::basic_string< wchar_t >& u,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeValue (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::std::basic_string< wchar_t >& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeValue (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    const ::std::basic_string< wchar_t >& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::AttributeValue (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMInputSource& i,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeValue (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::AttributeValue (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > r (
        tfm.create< ::xml_schema::type > (
          L"AttributeValue",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"AttributeValue",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::std::basic_string< wchar_t >& u,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::EncryptedAttribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::std::basic_string< wchar_t >& u,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAttribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::std::basic_string< wchar_t >& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAttribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        const ::std::basic_string< wchar_t >& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::saml2::assertion::EncryptedAttribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAttribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
      {
        throw ::xsd::cxx::tree::parsing< wchar_t > ();
      }

      return ::saml2::assertion::EncryptedAttribute (
        static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xsd::cxx::tree::properties< wchar_t >&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        (f & ::xml_schema::flags::keep_dom) 
        ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
        : 0);

      const ::xsd::cxx::xml::dom::element< wchar_t > e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d.getDocumentElement ());

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        tfm.create< ::saml2::assertion::EncryptedElementType > (
          L"EncryptedAttribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          f,
          0));

      if (r.get () != 0)
      {
        if (f & ::xml_schema::flags::keep_dom) c.release ();
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        e.name (),
        e.namespace_ (),
        L"EncryptedAttribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace saml2
{
  namespace assertion
  {
    void
    BaseID (::xercesc::DOMDocument& d,
            const ::saml2::assertion::BaseIDAbstractType& s,
            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::BaseIDAbstractType > (
        L"BaseID",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    BaseID (const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::BaseIDAbstractType > (
            L"BaseID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::BaseID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    BaseID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    BaseID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    BaseID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    BaseID (::std::ostream& o,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    BaseID (::std::ostream& o,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    BaseID (::std::ostream& o,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const BaseIDAbstractType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      if (i.NameQualifier ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"NameQualifier",
          e);

        a.dom_attribute () << *i.NameQualifier ();
      }

      if (i.SPNameQualifier ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"SPNameQualifier",
          e);

        a.dom_attribute () << *i.SPNameQualifier ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, BaseIDAbstractType >
    _xsd_BaseIDAbstractType_type_serializer_init (
      L"BaseIDAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    NameID (::xercesc::DOMDocument& d,
            const ::saml2::assertion::NameIDType& s,
            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::NameIDType > (
        L"NameID",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NameID (const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::NameIDType > (
            L"NameID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::NameID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    NameID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameID (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameID (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameID (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const NameIDType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      if (i.NameQualifier ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"NameQualifier",
          e);

        a.dom_attribute () << *i.NameQualifier ();
      }

      if (i.SPNameQualifier ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"SPNameQualifier",
          e);

        a.dom_attribute () << *i.SPNameQualifier ();
      }

      if (i.Format ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Format",
          e);

        a.dom_attribute () << *i.Format ();
      }

      if (i.SPProvidedID ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"SPProvidedID",
          e);

        a.dom_attribute () << *i.SPProvidedID ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NameIDType >
    _xsd_NameIDType_type_serializer_init (
      L"NameIDType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    operator<< (::xercesc::DOMElement& e,
                const EncryptedElementType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize< EncryptedElementType::EncryptedData::type > (
          L"EncryptedData",
          L"http://www.w3.org/2001/04/xmlenc#",
          true,
          true,
          e,
          i.EncryptedData ());
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EncryptedElementType::EncryptedKey::const_iterator
             b (i.EncryptedKey ().begin ()), n (i.EncryptedKey ().end ());
             b != n; ++b)
        {
          tsm.serialize< EncryptedElementType::EncryptedKey::type > (
            L"EncryptedKey",
            L"http://www.w3.org/2001/04/xmlenc#",
            true,
            true,
            e,
            *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptedElementType >
    _xsd_EncryptedElementType_type_serializer_init (
      L"EncryptedElementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    EncryptedID (::xercesc::DOMDocument& d,
                 const ::saml2::assertion::EncryptedElementType& s,
                 ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::EncryptedElementType > (
        L"EncryptedID",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedID (const ::saml2::assertion::EncryptedElementType& s,
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                 ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::EncryptedElementType > (
            L"EncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::EncryptedID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    EncryptedID (::xercesc::XMLFormatTarget& t,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                 const ::std::basic_string< wchar_t >& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedID (::xercesc::XMLFormatTarget& t,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                 ::xsd::cxx::xml::error_handler< wchar_t >& h,
                 const ::std::basic_string< wchar_t >& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedID (::xercesc::XMLFormatTarget& t,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::basic_string< wchar_t >& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedID (::std::ostream& o,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                 const ::std::basic_string< wchar_t >& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedID (::std::ostream& o,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                 ::xsd::cxx::xml::error_handler< wchar_t >& h,
                 const ::std::basic_string< wchar_t >& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedID (::std::ostream& o,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::basic_string< wchar_t >& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::xercesc::DOMDocument& d,
            const ::saml2::assertion::NameIDType& s,
            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::NameIDType > (
        L"Issuer",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Issuer (const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::NameIDType > (
            L"Issuer",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Issuer (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Issuer (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Issuer (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Issuer (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::xercesc::DOMDocument& d,
                    const ::xml_schema::ncname& s,
                    ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::ncname > (
        L"AssertionIDRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AssertionIDRef (const ::xml_schema::ncname& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::ncname > (
            L"AssertionIDRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AssertionIDRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::ncname& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRef (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::ncname& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::ncname& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::std::ostream& o,
                    const ::xml_schema::ncname& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRef (::std::ostream& o,
                    const ::xml_schema::ncname& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::std::ostream& o,
                    const ::xml_schema::ncname& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::xercesc::DOMDocument& d,
                     const ::xml_schema::uri& s,
                     ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::uri > (
        L"AssertionURIRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AssertionURIRef (const ::xml_schema::uri& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::uri > (
            L"AssertionURIRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AssertionURIRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::uri& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionURIRef (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::uri& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::uri& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::std::ostream& o,
                     const ::xml_schema::uri& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionURIRef (::std::ostream& o,
                     const ::xml_schema::uri& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::std::ostream& o,
                     const ::xml_schema::uri& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::xercesc::DOMDocument& d,
               const ::saml2::assertion::AssertionType& s,
               ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AssertionType > (
        L"Assertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Assertion (const ::saml2::assertion::AssertionType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AssertionType > (
            L"Assertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Assertion (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Assertion (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AssertionType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Assertion (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AssertionType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AssertionType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::std::ostream& o,
               const ::saml2::assertion::AssertionType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Assertion (::std::ostream& o,
               const ::saml2::assertion::AssertionType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::std::ostream& o,
               const ::saml2::assertion::AssertionType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AssertionType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize< AssertionType::Issuer::type > (
          L"Issuer",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          i.Issuer ());
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          tsm.serialize< AssertionType::Signature::type > (
            L"Signature",
            L"http://www.w3.org/2000/09/xmldsig#",
            true,
            true,
            e,
            *i.Signature ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Subject ())
        {
          tsm.serialize< AssertionType::Subject::type > (
            L"Subject",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.Subject ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Conditions ())
        {
          tsm.serialize< AssertionType::Conditions::type > (
            L"Conditions",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.Conditions ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Advice ())
        {
          tsm.serialize< AssertionType::Advice::type > (
            L"Advice",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.Advice ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::Statement::const_iterator
             b (i.Statement ().begin ()), n (i.Statement ().end ());
             b != n; ++b)
        {
          tsm.serialize< AssertionType::Statement::type > (
            L"Statement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::AuthnStatement::const_iterator
             b (i.AuthnStatement ().begin ()), n (i.AuthnStatement ().end ());
             b != n; ++b)
        {
          tsm.serialize< AssertionType::AuthnStatement::type > (
            L"AuthnStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::AuthzDecisionStatement::const_iterator
             b (i.AuthzDecisionStatement ().begin ()), n (i.AuthzDecisionStatement ().end ());
             b != n; ++b)
        {
          tsm.serialize< AssertionType::AuthzDecisionStatement::type > (
            L"AuthzDecisionStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::AttributeStatement::const_iterator
             b (i.AttributeStatement ().begin ()), n (i.AttributeStatement ().end ());
             b != n; ++b)
        {
          tsm.serialize< AssertionType::AttributeStatement::type > (
            L"AttributeStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Version",
          e);

        a.dom_attribute () << i.Version ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"ID",
          e);

        a.dom_attribute () << i.ID ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"IssueInstant",
          e);

        a.dom_attribute () << i.IssueInstant ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AssertionType >
    _xsd_AssertionType_type_serializer_init (
      L"AssertionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Subject (::xercesc::DOMDocument& d,
             const ::saml2::assertion::SubjectType& s,
             ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::SubjectType > (
        L"Subject",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Subject (const ::saml2::assertion::SubjectType& s,
             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::SubjectType > (
            L"Subject",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Subject (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Subject (::xercesc::XMLFormatTarget& t,
             const ::saml2::assertion::SubjectType& s,
             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
             const ::std::basic_string< wchar_t >& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Subject (::xercesc::XMLFormatTarget& t,
             const ::saml2::assertion::SubjectType& s,
             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
             ::xsd::cxx::xml::error_handler< wchar_t >& h,
             const ::std::basic_string< wchar_t >& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Subject (::xercesc::XMLFormatTarget& t,
             const ::saml2::assertion::SubjectType& s,
             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::basic_string< wchar_t >& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Subject (::std::ostream& o,
             const ::saml2::assertion::SubjectType& s,
             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
             const ::std::basic_string< wchar_t >& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Subject (::std::ostream& o,
             const ::saml2::assertion::SubjectType& s,
             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
             ::xsd::cxx::xml::error_handler< wchar_t >& h,
             const ::std::basic_string< wchar_t >& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Subject (::std::ostream& o,
             const ::saml2::assertion::SubjectType& s,
             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::basic_string< wchar_t >& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const SubjectType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BaseID ())
        {
          tsm.serialize< SubjectType::BaseID::type > (
            L"BaseID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.BaseID ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          tsm.serialize< SubjectType::NameID::type > (
            L"NameID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.NameID ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          tsm.serialize< SubjectType::EncryptedID::type > (
            L"EncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.EncryptedID ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SubjectType::SubjectConfirmation::const_iterator
             b (i.SubjectConfirmation ().begin ()), n (i.SubjectConfirmation ().end ());
             b != n; ++b)
        {
          tsm.serialize< SubjectType::SubjectConfirmation::type > (
            L"SubjectConfirmation",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectType >
    _xsd_SubjectType_type_serializer_init (
      L"SubjectType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    SubjectConfirmation (::xercesc::DOMDocument& d,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::SubjectConfirmationType > (
        L"SubjectConfirmation",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SubjectConfirmation (const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::SubjectConfirmationType > (
            L"SubjectConfirmation",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::SubjectConfirmation (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmation (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::std::ostream& o,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmation (::std::ostream& o,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::std::ostream& o,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const SubjectConfirmationType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BaseID ())
        {
          tsm.serialize< SubjectConfirmationType::BaseID::type > (
            L"BaseID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.BaseID ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          tsm.serialize< SubjectConfirmationType::NameID::type > (
            L"NameID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.NameID ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          tsm.serialize< SubjectConfirmationType::EncryptedID::type > (
            L"EncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.EncryptedID ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.SubjectConfirmationData ())
        {
          tsm.serialize< SubjectConfirmationType::SubjectConfirmationData::type > (
            L"SubjectConfirmationData",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.SubjectConfirmationData ());
        }
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Method",
          e);

        a.dom_attribute () << i.Method ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectConfirmationType >
    _xsd_SubjectConfirmationType_type_serializer_init (
      L"SubjectConfirmationType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    SubjectConfirmationData (::xercesc::DOMDocument& d,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::SubjectConfirmationDataType > (
        L"SubjectConfirmationData",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SubjectConfirmationData (const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::SubjectConfirmationDataType > (
            L"SubjectConfirmationData",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::SubjectConfirmationData (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::xercesc::XMLFormatTarget& t,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmationData (::xercesc::XMLFormatTarget& t,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::xercesc::XMLFormatTarget& t,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::std::ostream& o,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmationData (::std::ostream& o,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::std::ostream& o,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const SubjectConfirmationDataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      if (i.NotBefore ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"NotBefore",
          e);

        a.dom_attribute () << *i.NotBefore ();
      }

      if (i.NotOnOrAfter ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"NotOnOrAfter",
          e);

        a.dom_attribute () << *i.NotOnOrAfter ();
      }

      if (i.Recipient ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Recipient",
          e);

        a.dom_attribute () << *i.Recipient ();
      }

      if (i.InResponseTo ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"InResponseTo",
          e);

        a.dom_attribute () << *i.InResponseTo ();
      }

      if (i.Address ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Address",
          e);

        a.dom_attribute () << *i.Address ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectConfirmationDataType >
    _xsd_SubjectConfirmationDataType_type_serializer_init (
      L"SubjectConfirmationDataType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    operator<< (::xercesc::DOMElement& e,
                const KeyInfoConfirmationDataType& i)
    {
      e << static_cast< const ::saml2::assertion::SubjectConfirmationDataType& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, KeyInfoConfirmationDataType >
    _xsd_KeyInfoConfirmationDataType_type_serializer_init (
      L"KeyInfoConfirmationDataType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Conditions (::xercesc::DOMDocument& d,
                const ::saml2::assertion::ConditionsType& s,
                ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::ConditionsType > (
        L"Conditions",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Conditions (const ::saml2::assertion::ConditionsType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::ConditionsType > (
            L"Conditions",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Conditions (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Conditions (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::ConditionsType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Conditions (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::ConditionsType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Conditions (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::ConditionsType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Conditions (::std::ostream& o,
                const ::saml2::assertion::ConditionsType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Conditions (::std::ostream& o,
                const ::saml2::assertion::ConditionsType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Conditions (::std::ostream& o,
                const ::saml2::assertion::ConditionsType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const ConditionsType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::Condition::const_iterator
             b (i.Condition ().begin ()), n (i.Condition ().end ());
             b != n; ++b)
        {
          tsm.serialize< ConditionsType::Condition::type > (
            L"Condition",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::AudienceRestriction::const_iterator
             b (i.AudienceRestriction ().begin ()), n (i.AudienceRestriction ().end ());
             b != n; ++b)
        {
          tsm.serialize< ConditionsType::AudienceRestriction::type > (
            L"AudienceRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::OneTimeUse::const_iterator
             b (i.OneTimeUse ().begin ()), n (i.OneTimeUse ().end ());
             b != n; ++b)
        {
          tsm.serialize< ConditionsType::OneTimeUse::type > (
            L"OneTimeUse",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::ProxyRestriction::const_iterator
             b (i.ProxyRestriction ().begin ()), n (i.ProxyRestriction ().end ());
             b != n; ++b)
        {
          tsm.serialize< ConditionsType::ProxyRestriction::type > (
            L"ProxyRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      if (i.NotBefore ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"NotBefore",
          e);

        a.dom_attribute () << *i.NotBefore ();
      }

      if (i.NotOnOrAfter ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"NotOnOrAfter",
          e);

        a.dom_attribute () << *i.NotOnOrAfter ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConditionsType >
    _xsd_ConditionsType_type_serializer_init (
      L"ConditionsType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Condition (::xercesc::DOMDocument& d,
               const ::saml2::assertion::ConditionAbstractType& s,
               ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::ConditionAbstractType > (
        L"Condition",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Condition (const ::saml2::assertion::ConditionAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::ConditionAbstractType > (
            L"Condition",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Condition (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Condition (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Condition (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Condition (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Condition (::std::ostream& o,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Condition (::std::ostream& o,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Condition (::std::ostream& o,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const ConditionAbstractType&)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);
    }

    void
    operator<< (::xercesc::DOMAttr&,
                const ConditionAbstractType&)
    {
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >&,
                const ConditionAbstractType&)
    {
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConditionAbstractType >
    _xsd_ConditionAbstractType_type_serializer_init (
      L"ConditionAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AudienceRestriction (::xercesc::DOMDocument& d,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AudienceRestrictionType > (
        L"AudienceRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AudienceRestriction (const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AudienceRestrictionType > (
            L"AudienceRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AudienceRestriction (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AudienceRestriction (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::std::ostream& o,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AudienceRestriction (::std::ostream& o,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::std::ostream& o,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AudienceRestrictionType& i)
    {
      e << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AudienceRestrictionType::Audience::const_iterator
             b (i.Audience ().begin ()), n (i.Audience ().end ());
             b != n; ++b)
        {
          tsm.serialize< AudienceRestrictionType::Audience::type > (
            L"Audience",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AudienceRestrictionType >
    _xsd_AudienceRestrictionType_type_serializer_init (
      L"AudienceRestrictionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Audience (::xercesc::DOMDocument& d,
              const ::xml_schema::uri& s,
              ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::uri > (
        L"Audience",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Audience (const ::xml_schema::uri& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::uri > (
            L"Audience",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Audience (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Audience (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::uri& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Audience (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::uri& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Audience (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::uri& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Audience (::std::ostream& o,
              const ::xml_schema::uri& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Audience (::std::ostream& o,
              const ::xml_schema::uri& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Audience (::std::ostream& o,
              const ::xml_schema::uri& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::xercesc::DOMDocument& d,
                const ::saml2::assertion::OneTimeUseType& s,
                ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::OneTimeUseType > (
        L"OneTimeUse",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    OneTimeUse (const ::saml2::assertion::OneTimeUseType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::OneTimeUseType > (
            L"OneTimeUse",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::OneTimeUse (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    OneTimeUse (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OneTimeUse (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::std::ostream& o,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OneTimeUse (::std::ostream& o,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xsd::cxx::xml::error_handler< wchar_t >& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::std::ostream& o,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::basic_string< wchar_t >& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const OneTimeUseType& i)
    {
      e << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                const OneTimeUseType& i)
    {
      a << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const OneTimeUseType& i)
    {
      l << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OneTimeUseType >
    _xsd_OneTimeUseType_type_serializer_init (
      L"OneTimeUseType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    ProxyRestriction (::xercesc::DOMDocument& d,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::ProxyRestrictionType > (
        L"ProxyRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ProxyRestriction (const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::ProxyRestrictionType > (
            L"ProxyRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::ProxyRestriction (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::xercesc::XMLFormatTarget& t,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ProxyRestriction (::xercesc::XMLFormatTarget& t,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::xercesc::XMLFormatTarget& t,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::std::ostream& o,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ProxyRestriction (::std::ostream& o,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::std::ostream& o,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const ProxyRestrictionType& i)
    {
      e << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ProxyRestrictionType::Audience::const_iterator
             b (i.Audience ().begin ()), n (i.Audience ().end ());
             b != n; ++b)
        {
          tsm.serialize< ProxyRestrictionType::Audience::type > (
            L"Audience",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      if (i.Count ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Count",
          e);

        a.dom_attribute () << *i.Count ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ProxyRestrictionType >
    _xsd_ProxyRestrictionType_type_serializer_init (
      L"ProxyRestrictionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Advice (::xercesc::DOMDocument& d,
            const ::saml2::assertion::AdviceType& s,
            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AdviceType > (
        L"Advice",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Advice (const ::saml2::assertion::AdviceType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AdviceType > (
            L"Advice",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Advice (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Advice (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::AdviceType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Advice (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::AdviceType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Advice (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::AdviceType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Advice (::std::ostream& o,
            const ::saml2::assertion::AdviceType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Advice (::std::ostream& o,
            const ::saml2::assertion::AdviceType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Advice (::std::ostream& o,
            const ::saml2::assertion::AdviceType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AdviceType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::AssertionIDRef::const_iterator
             b (i.AssertionIDRef ().begin ()), n (i.AssertionIDRef ().end ());
             b != n; ++b)
        {
          tsm.serialize< AdviceType::AssertionIDRef::type > (
            L"AssertionIDRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::AssertionURIRef::const_iterator
             b (i.AssertionURIRef ().begin ()), n (i.AssertionURIRef ().end ());
             b != n; ++b)
        {
          tsm.serialize< AdviceType::AssertionURIRef::type > (
            L"AssertionURIRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::Assertion::const_iterator
             b (i.Assertion ().begin ()), n (i.Assertion ().end ());
             b != n; ++b)
        {
          tsm.serialize< AdviceType::Assertion::type > (
            L"Assertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::EncryptedAssertion::const_iterator
             b (i.EncryptedAssertion ().begin ()), n (i.EncryptedAssertion ().end ());
             b != n; ++b)
        {
          tsm.serialize< AdviceType::EncryptedAssertion::type > (
            L"EncryptedAssertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AdviceType >
    _xsd_AdviceType_type_serializer_init (
      L"AdviceType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    EncryptedAssertion (::xercesc::DOMDocument& d,
                        const ::saml2::assertion::EncryptedElementType& s,
                        ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::EncryptedElementType > (
        L"EncryptedAssertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedAssertion (const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::EncryptedElementType > (
            L"EncryptedAssertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::EncryptedAssertion (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAssertion (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAssertion (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::xercesc::DOMDocument& d,
               const ::saml2::assertion::StatementAbstractType& s,
               ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::StatementAbstractType > (
        L"Statement",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Statement (const ::saml2::assertion::StatementAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::StatementAbstractType > (
            L"Statement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Statement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Statement (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Statement (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::std::ostream& o,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Statement (::std::ostream& o,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::std::ostream& o,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const StatementAbstractType&)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);
    }

    void
    operator<< (::xercesc::DOMAttr&,
                const StatementAbstractType&)
    {
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >&,
                const StatementAbstractType&)
    {
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StatementAbstractType >
    _xsd_StatementAbstractType_type_serializer_init (
      L"StatementAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AuthnStatement (::xercesc::DOMDocument& d,
                    const ::saml2::assertion::AuthnStatementType& s,
                    ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AuthnStatementType > (
        L"AuthnStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnStatement (const ::saml2::assertion::AuthnStatementType& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AuthnStatementType > (
            L"AuthnStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AuthnStatement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthnStatement (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnStatement (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnStatement (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnStatement (::std::ostream& o,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnStatement (::std::ostream& o,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnStatement (::std::ostream& o,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AuthnStatementType& i)
    {
      e << static_cast< const ::saml2::assertion::StatementAbstractType& > (i);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.SubjectLocality ())
        {
          tsm.serialize< AuthnStatementType::SubjectLocality::type > (
            L"SubjectLocality",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.SubjectLocality ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize< AuthnStatementType::AuthnContext::type > (
          L"AuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          true,
          true,
          e,
          i.AuthnContext ());
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"AuthnInstant",
          e);

        a.dom_attribute () << i.AuthnInstant ();
      }

      if (i.SessionIndex ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"SessionIndex",
          e);

        a.dom_attribute () << *i.SessionIndex ();
      }

      if (i.SessionNotOnOrAfter ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"SessionNotOnOrAfter",
          e);

        a.dom_attribute () << *i.SessionNotOnOrAfter ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnStatementType >
    _xsd_AuthnStatementType_type_serializer_init (
      L"AuthnStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    SubjectLocality (::xercesc::DOMDocument& d,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::SubjectLocalityType > (
        L"SubjectLocality",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SubjectLocality (const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::SubjectLocalityType > (
            L"SubjectLocality",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::SubjectLocality (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    SubjectLocality (::xercesc::XMLFormatTarget& t,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectLocality (::xercesc::XMLFormatTarget& t,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectLocality (::xercesc::XMLFormatTarget& t,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectLocality (::std::ostream& o,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectLocality (::std::ostream& o,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xsd::cxx::xml::error_handler< wchar_t >& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectLocality (::std::ostream& o,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::basic_string< wchar_t >& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const SubjectLocalityType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      if (i.Address ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Address",
          e);

        a.dom_attribute () << *i.Address ();
      }

      if (i.DNSName ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"DNSName",
          e);

        a.dom_attribute () << *i.DNSName ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectLocalityType >
    _xsd_SubjectLocalityType_type_serializer_init (
      L"SubjectLocalityType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AuthnContext (::xercesc::DOMDocument& d,
                  const ::saml2::assertion::AuthnContextType& s,
                  ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AuthnContextType > (
        L"AuthnContext",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContext (const ::saml2::assertion::AuthnContextType& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AuthnContextType > (
            L"AuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AuthnContext (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthnContext (::xercesc::XMLFormatTarget& t,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                  const ::std::basic_string< wchar_t >& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContext (::xercesc::XMLFormatTarget& t,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                  ::xsd::cxx::xml::error_handler< wchar_t >& h,
                  const ::std::basic_string< wchar_t >& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContext (::xercesc::XMLFormatTarget& t,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::basic_string< wchar_t >& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContext (::std::ostream& o,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                  const ::std::basic_string< wchar_t >& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContext (::std::ostream& o,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                  ::xsd::cxx::xml::error_handler< wchar_t >& h,
                  const ::std::basic_string< wchar_t >& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContext (::std::ostream& o,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::basic_string< wchar_t >& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AuthnContextType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.AuthnContextClassRef ())
        {
          tsm.serialize< AuthnContextType::AuthnContextClassRef::type > (
            L"AuthnContextClassRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.AuthnContextClassRef ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.AuthnContextDecl ())
        {
          tsm.serialize< AuthnContextType::AuthnContextDecl::type > (
            L"AuthnContextDecl",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.AuthnContextDecl ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.AuthnContextDeclRef ())
        {
          tsm.serialize< AuthnContextType::AuthnContextDeclRef::type > (
            L"AuthnContextDeclRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.AuthnContextDeclRef ());
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthnContextType::AuthenticatingAuthority::const_iterator
             b (i.AuthenticatingAuthority ().begin ()), n (i.AuthenticatingAuthority ().end ());
             b != n; ++b)
        {
          tsm.serialize< AuthnContextType::AuthenticatingAuthority::type > (
            L"AuthenticatingAuthority",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnContextType >
    _xsd_AuthnContextType_type_serializer_init (
      L"AuthnContextType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AuthnContextClassRef (::xercesc::DOMDocument& d,
                          const ::xml_schema::uri& s,
                          ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::uri > (
        L"AuthnContextClassRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContextClassRef (const ::xml_schema::uri& s,
                          const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                          ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::uri > (
            L"AuthnContextClassRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AuthnContextClassRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::xercesc::XMLFormatTarget& t,
                          const ::xml_schema::uri& s,
                          const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                          const ::std::basic_string< wchar_t >& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextClassRef (::xercesc::XMLFormatTarget& t,
                          const ::xml_schema::uri& s,
                          const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                          ::xsd::cxx::xml::error_handler< wchar_t >& h,
                          const ::std::basic_string< wchar_t >& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::xercesc::XMLFormatTarget& t,
                          const ::xml_schema::uri& s,
                          const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::basic_string< wchar_t >& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::std::ostream& o,
                          const ::xml_schema::uri& s,
                          const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                          const ::std::basic_string< wchar_t >& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextClassRef (::std::ostream& o,
                          const ::xml_schema::uri& s,
                          const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                          ::xsd::cxx::xml::error_handler< wchar_t >& h,
                          const ::std::basic_string< wchar_t >& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::std::ostream& o,
                          const ::xml_schema::uri& s,
                          const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::basic_string< wchar_t >& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::DOMDocument& d,
                         const ::xml_schema::uri& s,
                         ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::uri > (
        L"AuthnContextDeclRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContextDeclRef (const ::xml_schema::uri& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::uri > (
            L"AuthnContextDeclRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AuthnContextDeclRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::XMLFormatTarget& t,
                         const ::xml_schema::uri& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::XMLFormatTarget& t,
                         const ::xml_schema::uri& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::XMLFormatTarget& t,
                         const ::xml_schema::uri& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::std::ostream& o,
                         const ::xml_schema::uri& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDeclRef (::std::ostream& o,
                         const ::xml_schema::uri& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xsd::cxx::xml::error_handler< wchar_t >& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::std::ostream& o,
                         const ::xml_schema::uri& s,
                         const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::basic_string< wchar_t >& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::DOMDocument& d,
                      const ::xml_schema::type& s,
                      ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::type > (
        L"AuthnContextDecl",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContextDecl (const ::xml_schema::type& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::type > (
            L"AuthnContextDecl",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AuthnContextDecl (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::type& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::type& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::type& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::std::ostream& o,
                      const ::xml_schema::type& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDecl (::std::ostream& o,
                      const ::xml_schema::type& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xsd::cxx::xml::error_handler< wchar_t >& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::std::ostream& o,
                      const ::xml_schema::type& s,
                      const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::basic_string< wchar_t >& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::DOMDocument& d,
                             const ::xml_schema::uri& s,
                             ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::uri > (
        L"AuthenticatingAuthority",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthenticatingAuthority (const ::xml_schema::uri& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::uri > (
            L"AuthenticatingAuthority",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AuthenticatingAuthority (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::XMLFormatTarget& t,
                             const ::xml_schema::uri& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::XMLFormatTarget& t,
                             const ::xml_schema::uri& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::XMLFormatTarget& t,
                             const ::xml_schema::uri& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::std::ostream& o,
                             const ::xml_schema::uri& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthenticatingAuthority (::std::ostream& o,
                             const ::xml_schema::uri& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xsd::cxx::xml::error_handler< wchar_t >& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::std::ostream& o,
                             const ::xml_schema::uri& s,
                             const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::basic_string< wchar_t >& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::DOMDocument& d,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AuthzDecisionStatementType > (
        L"AuthzDecisionStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthzDecisionStatement (const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AuthzDecisionStatementType > (
            L"AuthzDecisionStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AuthzDecisionStatement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::XMLFormatTarget& t,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                            const ::std::basic_string< wchar_t >& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::XMLFormatTarget& t,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                            ::xsd::cxx::xml::error_handler< wchar_t >& h,
                            const ::std::basic_string< wchar_t >& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::XMLFormatTarget& t,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                            ::xercesc::DOMErrorHandler& h,
                            const ::std::basic_string< wchar_t >& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::std::ostream& o,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                            const ::std::basic_string< wchar_t >& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzDecisionStatement (::std::ostream& o,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                            ::xsd::cxx::xml::error_handler< wchar_t >& h,
                            const ::std::basic_string< wchar_t >& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::std::ostream& o,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                            ::xercesc::DOMErrorHandler& h,
                            const ::std::basic_string< wchar_t >& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AuthzDecisionStatementType& i)
    {
      e << static_cast< const ::saml2::assertion::StatementAbstractType& > (i);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthzDecisionStatementType::Action::const_iterator
             b (i.Action ().begin ()), n (i.Action ().end ());
             b != n; ++b)
        {
          tsm.serialize< AuthzDecisionStatementType::Action::type > (
            L"Action",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Evidence ())
        {
          tsm.serialize< AuthzDecisionStatementType::Evidence::type > (
            L"Evidence",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *i.Evidence ());
        }
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Resource",
          e);

        a.dom_attribute () << i.Resource ();
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Decision",
          e);

        a.dom_attribute () << i.Decision ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthzDecisionStatementType >
    _xsd_AuthzDecisionStatementType_type_serializer_init (
      L"AuthzDecisionStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    operator<< (::xercesc::DOMElement& e,
                DecisionType i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,
                DecisionType i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                DecisionType i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DecisionType >
    _xsd_DecisionType_type_serializer_init (
      L"DecisionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Action (::xercesc::DOMDocument& d,
            const ::saml2::assertion::ActionType& s,
            ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::ActionType > (
        L"Action",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Action (const ::saml2::assertion::ActionType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::ActionType > (
            L"Action",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Action (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Action (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::ActionType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Action (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::ActionType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Action (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::ActionType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Action (::std::ostream& o,
            const ::saml2::assertion::ActionType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Action (::std::ostream& o,
            const ::saml2::assertion::ActionType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xsd::cxx::xml::error_handler< wchar_t >& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Action (::std::ostream& o,
            const ::saml2::assertion::ActionType& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< wchar_t >& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const ActionType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Namespace",
          e);

        a.dom_attribute () << i.Namespace ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ActionType >
    _xsd_ActionType_type_serializer_init (
      L"ActionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Evidence (::xercesc::DOMDocument& d,
              const ::saml2::assertion::EvidenceType& s,
              ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::EvidenceType > (
        L"Evidence",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Evidence (const ::saml2::assertion::EvidenceType& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::EvidenceType > (
            L"Evidence",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Evidence (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Evidence (::xercesc::XMLFormatTarget& t,
              const ::saml2::assertion::EvidenceType& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Evidence (::xercesc::XMLFormatTarget& t,
              const ::saml2::assertion::EvidenceType& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Evidence (::xercesc::XMLFormatTarget& t,
              const ::saml2::assertion::EvidenceType& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Evidence (::std::ostream& o,
              const ::saml2::assertion::EvidenceType& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Evidence (::std::ostream& o,
              const ::saml2::assertion::EvidenceType& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xsd::cxx::xml::error_handler< wchar_t >& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Evidence (::std::ostream& o,
              const ::saml2::assertion::EvidenceType& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::basic_string< wchar_t >& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const EvidenceType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::AssertionIDRef::const_iterator
             b (i.AssertionIDRef ().begin ()), n (i.AssertionIDRef ().end ());
             b != n; ++b)
        {
          tsm.serialize< EvidenceType::AssertionIDRef::type > (
            L"AssertionIDRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::AssertionURIRef::const_iterator
             b (i.AssertionURIRef ().begin ()), n (i.AssertionURIRef ().end ());
             b != n; ++b)
        {
          tsm.serialize< EvidenceType::AssertionURIRef::type > (
            L"AssertionURIRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::Assertion::const_iterator
             b (i.Assertion ().begin ()), n (i.Assertion ().end ());
             b != n; ++b)
        {
          tsm.serialize< EvidenceType::Assertion::type > (
            L"Assertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::EncryptedAssertion::const_iterator
             b (i.EncryptedAssertion ().begin ()), n (i.EncryptedAssertion ().end ());
             b != n; ++b)
        {
          tsm.serialize< EvidenceType::EncryptedAssertion::type > (
            L"EncryptedAssertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EvidenceType >
    _xsd_EvidenceType_type_serializer_init (
      L"EvidenceType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AttributeStatement (::xercesc::DOMDocument& d,
                        const ::saml2::assertion::AttributeStatementType& s,
                        ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AttributeStatementType > (
        L"AttributeStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeStatement (const ::saml2::assertion::AttributeStatementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AttributeStatementType > (
            L"AttributeStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AttributeStatement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AttributeStatement (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeStatement (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeStatement (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeStatement (::std::ostream& o,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeStatement (::std::ostream& o,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeStatement (::std::ostream& o,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AttributeStatementType& i)
    {
      e << static_cast< const ::saml2::assertion::StatementAbstractType& > (i);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeStatementType::Attribute::const_iterator
             b (i.Attribute ().begin ()), n (i.Attribute ().end ());
             b != n; ++b)
        {
          tsm.serialize< AttributeStatementType::Attribute::type > (
            L"Attribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeStatementType::EncryptedAttribute::const_iterator
             b (i.EncryptedAttribute ().begin ()), n (i.EncryptedAttribute ().end ());
             b != n; ++b)
        {
          tsm.serialize< AttributeStatementType::EncryptedAttribute::type > (
            L"EncryptedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeStatementType >
    _xsd_AttributeStatementType_type_serializer_init (
      L"AttributeStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Attribute (::xercesc::DOMDocument& d,
               const ::saml2::assertion::AttributeType& s,
               ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::AttributeType > (
        L"Attribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Attribute (const ::saml2::assertion::AttributeType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::AttributeType > (
            L"Attribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::Attribute (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Attribute (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AttributeType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Attribute (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AttributeType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Attribute (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AttributeType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Attribute (::std::ostream& o,
               const ::saml2::assertion::AttributeType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Attribute (::std::ostream& o,
               const ::saml2::assertion::AttributeType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xsd::cxx::xml::error_handler< wchar_t >& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Attribute (::std::ostream& o,
               const ::saml2::assertion::AttributeType& s,
               const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::basic_string< wchar_t >& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e,
                const AttributeType& i)
    {
      while (::xercesc::DOMNode* n = e.getFirstChild ())
        e.removeChild (n);

      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeType::AttributeValue::const_iterator
             b (i.AttributeValue ().begin ()), n (i.AttributeValue ().end ());
             b != n; ++b)
        {
          tsm.serialize< AttributeType::AttributeValue::type > (
            L"AttributeValue",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true,
            true,
            e,
            *b);
        }
      }

      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"Name",
          e);

        a.dom_attribute () << i.Name ();
      }

      if (i.NameFormat ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"NameFormat",
          e);

        a.dom_attribute () << *i.NameFormat ();
      }

      if (i.FriendlyName ())
      {
        ::xsd::cxx::xml::dom::attribute< wchar_t > a (
          L"FriendlyName",
          e);

        a.dom_attribute () << *i.FriendlyName ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeType >
    _xsd_AttributeType_type_serializer_init (
      L"AttributeType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AttributeValue (::xercesc::DOMDocument& d,
                    const ::xml_schema::type& s,
                    ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::xml_schema::type > (
        L"AttributeValue",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeValue (const ::xml_schema::type& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::xml_schema::type > (
            L"AttributeValue",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::AttributeValue (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AttributeValue (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::type& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeValue (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::type& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeValue (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::type& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeValue (::std::ostream& o,
                    const ::xml_schema::type& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeValue (::std::ostream& o,
                    const ::xml_schema::type& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xsd::cxx::xml::error_handler< wchar_t >& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeValue (::std::ostream& o,
                    const ::xml_schema::type& s,
                    const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::basic_string< wchar_t >& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::DOMDocument& d,
                        const ::saml2::assertion::EncryptedElementType& s,
                        ::xml_schema::flags)
    {
      ::xsd::cxx::xml::dom::element< wchar_t > e (*d.getDocumentElement ());

      ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

      tsm.serialize< ::saml2::assertion::EncryptedElementType > (
        L"EncryptedAttribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion",
        e,
        s);
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedAttribute (const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
          tsm.serialize< ::saml2::assertion::EncryptedElementType > (
            L"EncryptedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m,
            s,
            f));
        ::saml2::assertion::EncryptedAttribute (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAttribute (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xsd::cxx::xml::error_handler< wchar_t >& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::basic_string< wchar_t >& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

