// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

#ifndef SESSIONDATA_SCHEMA_HXX
#define SESSIONDATA_SCHEMA_HXX

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 2030100L)
#error XSD runtime version mismatch
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

#include "xsd/xml-schema.hxx"

// Forward declarations.
//
namespace middleware
{
  namespace SessionDataSchema
  {
    class SessionDataType;
    class IdentityType;
    class AttributeType;
    class DataType;
    class HandlerType;
  }
}


#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

namespace middleware
{
  namespace SessionDataSchema
  {
    class SessionDataType: public ::xml_schema::type
    {
      public:

      struct _xsd_SessionDataType
      {
        typedef ::xml_schema::type base_;
      };

      // Identity
      // 
      public:
      struct Identity
      {
        typedef ::middleware::SessionDataSchema::IdentityType type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const Identity::container&
      Identity () const;

      Identity::container&
      Identity ();

      void
      Identity (const Identity::container&);

      // Constructors.
      //
      public:
      SessionDataType ();

      SessionDataType (const ::xercesc::DOMElement&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      SessionDataType (const SessionDataType&,
                       ::xml_schema::flags = 0,
                       ::xml_schema::type* = 0);

      virtual SessionDataType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< Identity::type > _xsd_Identity_;
    };

    class IdentityType: public ::xml_schema::type
    {
      public:

      struct _xsd_IdentityType
      {
        typedef ::xml_schema::type base_;
      };

      // Attribute
      // 
      public:
      struct Attribute
      {
        typedef ::middleware::SessionDataSchema::AttributeType type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const Attribute::container&
      Attribute () const;

      Attribute::container&
      Attribute ();

      void
      Attribute (const Attribute::container&);

      // Constructors.
      //
      public:
      IdentityType ();

      IdentityType (const ::xercesc::DOMElement&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      IdentityType (const IdentityType&,
                    ::xml_schema::flags = 0,
                    ::xml_schema::type* = 0);

      virtual IdentityType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< Attribute::type > _xsd_Attribute_;
    };

    class AttributeType: public ::xml_schema::type
    {
      public:

      struct _xsd_AttributeType
      {
        typedef ::xml_schema::type base_;
      };

      // Handler
      // 
      public:
      struct Handler
      {
        typedef ::middleware::SessionDataSchema::HandlerType type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
        typedef ::xsd::cxx::tree::sequence< type > container;
        typedef container::iterator iterator;
        typedef container::const_iterator const_iterator;
      };

      const Handler::container&
      Handler () const;

      Handler::container&
      Handler ();

      void
      Handler (const Handler::container&);

      // Identifier
      // 
      public:
      struct Identifier
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
      };

      const Identifier::type&
      Identifier () const;

      Identifier::type&
      Identifier ();

      void
      Identifier (const Identifier::type&);

      void
      Identifier (::std::auto_ptr< Identifier::type >);

      // Type
      // 
      public:
      struct Type
      {
        typedef ::middleware::SessionDataSchema::DataType type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
      };

      const Type::type&
      Type () const;

      Type::type&
      Type ();

      void
      Type (const Type::type&);

      void
      Type (::std::auto_ptr< Type::type >);

      // Singleton
      // 
      public:
      struct Singleton
      {
        typedef ::xml_schema::boolean type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
      };

      const Singleton::type&
      Singleton () const;

      Singleton::type&
      Singleton ();

      void
      Singleton (const Singleton::type&);

      // Constructors.
      //
      public:
      AttributeType ();

      AttributeType (const Identifier::type&,
                     const Type::type&,
                     const Singleton::type&);

      AttributeType (const ::xercesc::DOMElement&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      AttributeType (const AttributeType&,
                     ::xml_schema::flags = 0,
                     ::xml_schema::type* = 0);

      virtual AttributeType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::sequence< Handler::type > _xsd_Handler_;
      ::xsd::cxx::tree::one< Identifier::type > _xsd_Identifier_;
      ::xsd::cxx::tree::one< Type::type > _xsd_Type_;
      ::xsd::cxx::tree::one< Singleton::type > _xsd_Singleton_;
    };

    class DataType: public ::xml_schema::string
    {
      public:
      enum _xsd_DataType
      {
        String,
        Integer,
        Float,
        Date,
        Boolean,
        Other
      };

      DataType ();

      DataType (_xsd_DataType);

      DataType (const ::xml_schema::string&);

      DataType (const ::xercesc::DOMElement&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

      DataType (const ::xercesc::DOMAttr&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

      DataType (const ::std::basic_string< wchar_t >&,
                const ::xercesc::DOMElement*,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

      DataType (const DataType&,
                ::xml_schema::flags = 0,
                ::xml_schema::type* = 0);

      virtual DataType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      DataType&
      operator= (_xsd_DataType);

      virtual
      operator _xsd_DataType () const
      {
        return _xsd_DataType_convert ();
      }

      protected:
      _xsd_DataType
      _xsd_DataType_convert () const;

      public:
      static const wchar_t* const _xsd_DataType_literals_[6];
      static const _xsd_DataType _xsd_DataType_indexes_[6];
    };

    class HandlerType: public ::xml_schema::type
    {
      public:

      struct _xsd_HandlerType
      {
        typedef ::xml_schema::type base_;
      };

      // Name
      // 
      public:
      struct Name
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
      };

      const Name::type&
      Name () const;

      Name::type&
      Name ();

      void
      Name (const Name::type&);

      void
      Name (::std::auto_ptr< Name::type >);

      // LocalIdentifier
      // 
      public:
      struct LocalIdentifier
      {
        typedef ::xml_schema::string type;
        typedef ::xsd::cxx::tree::traits< type, wchar_t > traits;
      };

      const LocalIdentifier::type&
      LocalIdentifier () const;

      LocalIdentifier::type&
      LocalIdentifier ();

      void
      LocalIdentifier (const LocalIdentifier::type&);

      void
      LocalIdentifier (::std::auto_ptr< LocalIdentifier::type >);

      // Constructors.
      //
      public:
      HandlerType ();

      HandlerType (const Name::type&,
                   const LocalIdentifier::type&);

      HandlerType (const ::xercesc::DOMElement&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      HandlerType (const HandlerType&,
                   ::xml_schema::flags = 0,
                   ::xml_schema::type* = 0);

      virtual HandlerType*
      _clone (::xml_schema::flags = 0,
              ::xml_schema::type* = 0) const;

      // Implementation.
      //
      private:
      void
      parse (const ::xercesc::DOMElement&, ::xml_schema::flags);

      ::xsd::cxx::tree::one< Name::type > _xsd_Name_;
      ::xsd::cxx::tree::one< LocalIdentifier::type > _xsd_LocalIdentifier_;
    };
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMInputSource.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace middleware
{
  namespace SessionDataSchema
  {
    // Read from a URI or a local file.
    //

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (const ::std::basic_string< wchar_t >&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (const ::std::basic_string< wchar_t >&,
                 ::xsd::cxx::xml::error_handler< wchar_t >&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (const ::std::basic_string< wchar_t >&,
                 ::xercesc::DOMErrorHandler&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());


    // Read from std::istream.
    //

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (::std::istream&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (::std::istream&,
                 ::xsd::cxx::xml::error_handler< wchar_t >&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (::std::istream&,
                 ::xercesc::DOMErrorHandler&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());


    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (::std::istream&,
                 const ::std::basic_string< wchar_t >& id,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (::std::istream&,
                 const ::std::basic_string< wchar_t >& id,
                 ::xsd::cxx::xml::error_handler< wchar_t >&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (::std::istream&,
                 const ::std::basic_string< wchar_t >& id,
                 ::xercesc::DOMErrorHandler&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());


    // Read from InputSource.
    //

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (const ::xercesc::DOMInputSource&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (const ::xercesc::DOMInputSource&,
                 ::xsd::cxx::xml::error_handler< wchar_t >&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (const ::xercesc::DOMInputSource&,
                 ::xercesc::DOMErrorHandler&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());


    // Read from DOM.
    //

    ::std::auto_ptr< ::middleware::SessionDataSchema::SessionDataType >
    SessionData (const ::xercesc::DOMDocument&,
                 ::xml_schema::flags = 0,
                 const ::xsd::cxx::tree::properties< wchar_t >& = ::xsd::cxx::tree::properties< wchar_t > ());
  }
}

#include <iosfwd> // std::ostream&

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace middleware
{
  namespace SessionDataSchema
  {
    // Serialize to an existing DOM instance.
    //
    void
    SessionData (::xercesc::DOMDocument&,
                 const ::middleware::SessionDataSchema::SessionDataType&,
                 ::xml_schema::flags = 0);


    // Serialize to a new DOM instance.
    //
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SessionData (const ::middleware::SessionDataSchema::SessionDataType&, 
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >&,
                 ::xml_schema::flags = 0);


    // Serialize to XMLFormatTarget.
    //
    void
    SessionData (::xercesc::XMLFormatTarget&,
                 const ::middleware::SessionDataSchema::SessionDataType&, 
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >&,
                 const ::std::basic_string< wchar_t >& = L"UTF-8",
                 ::xml_schema::flags = 0);


    void
    SessionData (::xercesc::XMLFormatTarget&,
                 const ::middleware::SessionDataSchema::SessionDataType&, 
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >&,
                 ::xsd::cxx::xml::error_handler< wchar_t >&,
                 const ::std::basic_string< wchar_t >& = L"UTF-8",
                 ::xml_schema::flags = 0);

    void
    SessionData (::xercesc::XMLFormatTarget&,
                 const ::middleware::SessionDataSchema::SessionDataType&, 
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >&,
                 ::xercesc::DOMErrorHandler&,
                 const ::std::basic_string< wchar_t >& = L"UTF-8",
                 ::xml_schema::flags = 0);


    // Serialize to std::ostream.
    //
    void
    SessionData (::std::ostream&,
                 const ::middleware::SessionDataSchema::SessionDataType&, 
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >&,
                 const ::std::basic_string< wchar_t >& = L"UTF-8",
                 ::xml_schema::flags = 0);


    void
    SessionData (::std::ostream&,
                 const ::middleware::SessionDataSchema::SessionDataType&, 
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >&,
                 ::xsd::cxx::xml::error_handler< wchar_t >&,
                 const ::std::basic_string< wchar_t >& = L"UTF-8",
                 ::xml_schema::flags = 0);

    void
    SessionData (::std::ostream&,
                 const ::middleware::SessionDataSchema::SessionDataType&, 
                 const ::xsd::cxx::xml::dom::namespace_infomap< wchar_t >&,
                 ::xercesc::DOMErrorHandler&,
                 const ::std::basic_string< wchar_t >& = L"UTF-8",
                 ::xml_schema::flags = 0);


    void
    operator<< (::xercesc::DOMElement&,
                const SessionDataType&);

    void
    operator<< (::xercesc::DOMElement&,
                const IdentityType&);

    void
    operator<< (::xercesc::DOMElement&,
                const AttributeType&);

    void
    operator<< (::xercesc::DOMElement&,
                DataType);

    void
    operator<< (::xercesc::DOMAttr&,
                DataType);

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >&,
                DataType);

    void
    operator<< (::xercesc::DOMElement&,
                const HandlerType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SESSIONDATA_SCHEMA_HXX
