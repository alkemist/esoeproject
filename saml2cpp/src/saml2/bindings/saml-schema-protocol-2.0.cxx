// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "saml2/bindings/saml-schema-protocol-2.0.hxx"

namespace saml2
{
  namespace protocol
  {
    // RequestAbstractType
    // 

    const RequestAbstractType::Issuer_optional& RequestAbstractType::
    Issuer () const
    {
      return this->Issuer_;
    }

    RequestAbstractType::Issuer_optional& RequestAbstractType::
    Issuer ()
    {
      return this->Issuer_;
    }

    void RequestAbstractType::
    Issuer (const Issuer_type& Issuer)
    {
      this->Issuer_.set (Issuer);
    }

    void RequestAbstractType::
    Issuer (const Issuer_optional& Issuer)
    {
      this->Issuer_ = Issuer;
    }

    void RequestAbstractType::
    Issuer (::std::auto_ptr< Issuer_type > Issuer)
    {
      this->Issuer_.set (Issuer);
    }

    const RequestAbstractType::Signature_optional& RequestAbstractType::
    Signature () const
    {
      return this->Signature_;
    }

    RequestAbstractType::Signature_optional& RequestAbstractType::
    Signature ()
    {
      return this->Signature_;
    }

    void RequestAbstractType::
    Signature (const Signature_type& Signature)
    {
      this->Signature_.set (Signature);
    }

    void RequestAbstractType::
    Signature (const Signature_optional& Signature)
    {
      this->Signature_ = Signature;
    }

    void RequestAbstractType::
    Signature (::std::auto_ptr< Signature_type > Signature)
    {
      this->Signature_.set (Signature);
    }

    const RequestAbstractType::Extensions_optional& RequestAbstractType::
    Extensions () const
    {
      return this->Extensions_;
    }

    RequestAbstractType::Extensions_optional& RequestAbstractType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void RequestAbstractType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void RequestAbstractType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void RequestAbstractType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const RequestAbstractType::ID_type& RequestAbstractType::
    ID () const
    {
      return this->ID_.get ();
    }

    RequestAbstractType::ID_type& RequestAbstractType::
    ID ()
    {
      return this->ID_.get ();
    }

    void RequestAbstractType::
    ID (const ID_type& ID)
    {
      this->ID_.set (ID);
    }

    void RequestAbstractType::
    ID (::std::auto_ptr< ID_type > ID)
    {
      this->ID_.set (ID);
    }

    const RequestAbstractType::Version_type& RequestAbstractType::
    Version () const
    {
      return this->Version_.get ();
    }

    RequestAbstractType::Version_type& RequestAbstractType::
    Version ()
    {
      return this->Version_.get ();
    }

    void RequestAbstractType::
    Version (const Version_type& Version)
    {
      this->Version_.set (Version);
    }

    void RequestAbstractType::
    Version (::std::auto_ptr< Version_type > Version)
    {
      this->Version_.set (Version);
    }

    const RequestAbstractType::IssueInstant_type& RequestAbstractType::
    IssueInstant () const
    {
      return this->IssueInstant_.get ();
    }

    RequestAbstractType::IssueInstant_type& RequestAbstractType::
    IssueInstant ()
    {
      return this->IssueInstant_.get ();
    }

    void RequestAbstractType::
    IssueInstant (const IssueInstant_type& IssueInstant)
    {
      this->IssueInstant_.set (IssueInstant);
    }

    void RequestAbstractType::
    IssueInstant (::std::auto_ptr< IssueInstant_type > IssueInstant)
    {
      this->IssueInstant_.set (IssueInstant);
    }

    const RequestAbstractType::Destination_optional& RequestAbstractType::
    Destination () const
    {
      return this->Destination_;
    }

    RequestAbstractType::Destination_optional& RequestAbstractType::
    Destination ()
    {
      return this->Destination_;
    }

    void RequestAbstractType::
    Destination (const Destination_type& Destination)
    {
      this->Destination_.set (Destination);
    }

    void RequestAbstractType::
    Destination (const Destination_optional& Destination)
    {
      this->Destination_ = Destination;
    }

    void RequestAbstractType::
    Destination (::std::auto_ptr< Destination_type > Destination)
    {
      this->Destination_.set (Destination);
    }

    const RequestAbstractType::Consent_optional& RequestAbstractType::
    Consent () const
    {
      return this->Consent_;
    }

    RequestAbstractType::Consent_optional& RequestAbstractType::
    Consent ()
    {
      return this->Consent_;
    }

    void RequestAbstractType::
    Consent (const Consent_type& Consent)
    {
      this->Consent_.set (Consent);
    }

    void RequestAbstractType::
    Consent (const Consent_optional& Consent)
    {
      this->Consent_ = Consent;
    }

    void RequestAbstractType::
    Consent (::std::auto_ptr< Consent_type > Consent)
    {
      this->Consent_.set (Consent);
    }


    // ExtensionsType
    // 

    const ExtensionsType::any_sequence& ExtensionsType::
    any () const
    {
      return this->any_;
    }

    ExtensionsType::any_sequence& ExtensionsType::
    any ()
    {
      return this->any_;
    }

    void ExtensionsType::
    any (const any_sequence& any)
    {
      this->any_ = any;
    }

    const ::xercesc::DOMDocument& ExtensionsType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& ExtensionsType::
    dom_document ()
    {
      return *dom_document_;
    }


    // StatusResponseType
    // 

    const StatusResponseType::Issuer_optional& StatusResponseType::
    Issuer () const
    {
      return this->Issuer_;
    }

    StatusResponseType::Issuer_optional& StatusResponseType::
    Issuer ()
    {
      return this->Issuer_;
    }

    void StatusResponseType::
    Issuer (const Issuer_type& Issuer)
    {
      this->Issuer_.set (Issuer);
    }

    void StatusResponseType::
    Issuer (const Issuer_optional& Issuer)
    {
      this->Issuer_ = Issuer;
    }

    void StatusResponseType::
    Issuer (::std::auto_ptr< Issuer_type > Issuer)
    {
      this->Issuer_.set (Issuer);
    }

    const StatusResponseType::Signature_optional& StatusResponseType::
    Signature () const
    {
      return this->Signature_;
    }

    StatusResponseType::Signature_optional& StatusResponseType::
    Signature ()
    {
      return this->Signature_;
    }

    void StatusResponseType::
    Signature (const Signature_type& Signature)
    {
      this->Signature_.set (Signature);
    }

    void StatusResponseType::
    Signature (const Signature_optional& Signature)
    {
      this->Signature_ = Signature;
    }

    void StatusResponseType::
    Signature (::std::auto_ptr< Signature_type > Signature)
    {
      this->Signature_.set (Signature);
    }

    const StatusResponseType::Extensions_optional& StatusResponseType::
    Extensions () const
    {
      return this->Extensions_;
    }

    StatusResponseType::Extensions_optional& StatusResponseType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void StatusResponseType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void StatusResponseType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void StatusResponseType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const StatusResponseType::Status_type& StatusResponseType::
    Status () const
    {
      return this->Status_.get ();
    }

    StatusResponseType::Status_type& StatusResponseType::
    Status ()
    {
      return this->Status_.get ();
    }

    void StatusResponseType::
    Status (const Status_type& Status)
    {
      this->Status_.set (Status);
    }

    void StatusResponseType::
    Status (::std::auto_ptr< Status_type > Status)
    {
      this->Status_.set (Status);
    }

    const StatusResponseType::ID_type& StatusResponseType::
    ID () const
    {
      return this->ID_.get ();
    }

    StatusResponseType::ID_type& StatusResponseType::
    ID ()
    {
      return this->ID_.get ();
    }

    void StatusResponseType::
    ID (const ID_type& ID)
    {
      this->ID_.set (ID);
    }

    void StatusResponseType::
    ID (::std::auto_ptr< ID_type > ID)
    {
      this->ID_.set (ID);
    }

    const StatusResponseType::InResponseTo_optional& StatusResponseType::
    InResponseTo () const
    {
      return this->InResponseTo_;
    }

    StatusResponseType::InResponseTo_optional& StatusResponseType::
    InResponseTo ()
    {
      return this->InResponseTo_;
    }

    void StatusResponseType::
    InResponseTo (const InResponseTo_type& InResponseTo)
    {
      this->InResponseTo_.set (InResponseTo);
    }

    void StatusResponseType::
    InResponseTo (const InResponseTo_optional& InResponseTo)
    {
      this->InResponseTo_ = InResponseTo;
    }

    void StatusResponseType::
    InResponseTo (::std::auto_ptr< InResponseTo_type > InResponseTo)
    {
      this->InResponseTo_.set (InResponseTo);
    }

    const StatusResponseType::Version_type& StatusResponseType::
    Version () const
    {
      return this->Version_.get ();
    }

    StatusResponseType::Version_type& StatusResponseType::
    Version ()
    {
      return this->Version_.get ();
    }

    void StatusResponseType::
    Version (const Version_type& Version)
    {
      this->Version_.set (Version);
    }

    void StatusResponseType::
    Version (::std::auto_ptr< Version_type > Version)
    {
      this->Version_.set (Version);
    }

    const StatusResponseType::IssueInstant_type& StatusResponseType::
    IssueInstant () const
    {
      return this->IssueInstant_.get ();
    }

    StatusResponseType::IssueInstant_type& StatusResponseType::
    IssueInstant ()
    {
      return this->IssueInstant_.get ();
    }

    void StatusResponseType::
    IssueInstant (const IssueInstant_type& IssueInstant)
    {
      this->IssueInstant_.set (IssueInstant);
    }

    void StatusResponseType::
    IssueInstant (::std::auto_ptr< IssueInstant_type > IssueInstant)
    {
      this->IssueInstant_.set (IssueInstant);
    }

    const StatusResponseType::Destination_optional& StatusResponseType::
    Destination () const
    {
      return this->Destination_;
    }

    StatusResponseType::Destination_optional& StatusResponseType::
    Destination ()
    {
      return this->Destination_;
    }

    void StatusResponseType::
    Destination (const Destination_type& Destination)
    {
      this->Destination_.set (Destination);
    }

    void StatusResponseType::
    Destination (const Destination_optional& Destination)
    {
      this->Destination_ = Destination;
    }

    void StatusResponseType::
    Destination (::std::auto_ptr< Destination_type > Destination)
    {
      this->Destination_.set (Destination);
    }

    const StatusResponseType::Consent_optional& StatusResponseType::
    Consent () const
    {
      return this->Consent_;
    }

    StatusResponseType::Consent_optional& StatusResponseType::
    Consent ()
    {
      return this->Consent_;
    }

    void StatusResponseType::
    Consent (const Consent_type& Consent)
    {
      this->Consent_.set (Consent);
    }

    void StatusResponseType::
    Consent (const Consent_optional& Consent)
    {
      this->Consent_ = Consent;
    }

    void StatusResponseType::
    Consent (::std::auto_ptr< Consent_type > Consent)
    {
      this->Consent_.set (Consent);
    }


    // StatusType
    // 

    const StatusType::StatusCode_type& StatusType::
    StatusCode () const
    {
      return this->StatusCode_.get ();
    }

    StatusType::StatusCode_type& StatusType::
    StatusCode ()
    {
      return this->StatusCode_.get ();
    }

    void StatusType::
    StatusCode (const StatusCode_type& StatusCode)
    {
      this->StatusCode_.set (StatusCode);
    }

    void StatusType::
    StatusCode (::std::auto_ptr< StatusCode_type > StatusCode)
    {
      this->StatusCode_.set (StatusCode);
    }

    const StatusType::StatusMessage_optional& StatusType::
    StatusMessage () const
    {
      return this->StatusMessage_;
    }

    StatusType::StatusMessage_optional& StatusType::
    StatusMessage ()
    {
      return this->StatusMessage_;
    }

    void StatusType::
    StatusMessage (const StatusMessage_type& StatusMessage)
    {
      this->StatusMessage_.set (StatusMessage);
    }

    void StatusType::
    StatusMessage (const StatusMessage_optional& StatusMessage)
    {
      this->StatusMessage_ = StatusMessage;
    }

    void StatusType::
    StatusMessage (::std::auto_ptr< StatusMessage_type > StatusMessage)
    {
      this->StatusMessage_.set (StatusMessage);
    }

    const StatusType::StatusDetail_optional& StatusType::
    StatusDetail () const
    {
      return this->StatusDetail_;
    }

    StatusType::StatusDetail_optional& StatusType::
    StatusDetail ()
    {
      return this->StatusDetail_;
    }

    void StatusType::
    StatusDetail (const StatusDetail_type& StatusDetail)
    {
      this->StatusDetail_.set (StatusDetail);
    }

    void StatusType::
    StatusDetail (const StatusDetail_optional& StatusDetail)
    {
      this->StatusDetail_ = StatusDetail;
    }

    void StatusType::
    StatusDetail (::std::auto_ptr< StatusDetail_type > StatusDetail)
    {
      this->StatusDetail_.set (StatusDetail);
    }


    // StatusCodeType
    // 

    const StatusCodeType::StatusCode_optional& StatusCodeType::
    StatusCode () const
    {
      return this->StatusCode_;
    }

    StatusCodeType::StatusCode_optional& StatusCodeType::
    StatusCode ()
    {
      return this->StatusCode_;
    }

    void StatusCodeType::
    StatusCode (const StatusCode_type& StatusCode)
    {
      this->StatusCode_.set (StatusCode);
    }

    void StatusCodeType::
    StatusCode (const StatusCode_optional& StatusCode)
    {
      this->StatusCode_ = StatusCode;
    }

    void StatusCodeType::
    StatusCode (::std::auto_ptr< StatusCode_type > StatusCode)
    {
      this->StatusCode_.set (StatusCode);
    }

    const StatusCodeType::Value_type& StatusCodeType::
    Value () const
    {
      return this->Value_.get ();
    }

    StatusCodeType::Value_type& StatusCodeType::
    Value ()
    {
      return this->Value_.get ();
    }

    void StatusCodeType::
    Value (const Value_type& Value)
    {
      this->Value_.set (Value);
    }

    void StatusCodeType::
    Value (::std::auto_ptr< Value_type > Value)
    {
      this->Value_.set (Value);
    }


    // StatusDetailType
    // 

    const StatusDetailType::any_sequence& StatusDetailType::
    any () const
    {
      return this->any_;
    }

    StatusDetailType::any_sequence& StatusDetailType::
    any ()
    {
      return this->any_;
    }

    void StatusDetailType::
    any (const any_sequence& any)
    {
      this->any_ = any;
    }

    const ::xercesc::DOMDocument& StatusDetailType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& StatusDetailType::
    dom_document ()
    {
      return *dom_document_;
    }


    // AssertionIDRequestType
    // 

    const AssertionIDRequestType::AssertionIDRef_sequence& AssertionIDRequestType::
    AssertionIDRef () const
    {
      return this->AssertionIDRef_;
    }

    AssertionIDRequestType::AssertionIDRef_sequence& AssertionIDRequestType::
    AssertionIDRef ()
    {
      return this->AssertionIDRef_;
    }

    void AssertionIDRequestType::
    AssertionIDRef (const AssertionIDRef_sequence& AssertionIDRef)
    {
      this->AssertionIDRef_ = AssertionIDRef;
    }


    // SubjectQueryAbstractType
    // 

    const SubjectQueryAbstractType::Subject_type& SubjectQueryAbstractType::
    Subject () const
    {
      return this->Subject_.get ();
    }

    SubjectQueryAbstractType::Subject_type& SubjectQueryAbstractType::
    Subject ()
    {
      return this->Subject_.get ();
    }

    void SubjectQueryAbstractType::
    Subject (const Subject_type& Subject)
    {
      this->Subject_.set (Subject);
    }

    void SubjectQueryAbstractType::
    Subject (::std::auto_ptr< Subject_type > Subject)
    {
      this->Subject_.set (Subject);
    }


    // AuthnQueryType
    // 

    const AuthnQueryType::RequestedAuthnContext_optional& AuthnQueryType::
    RequestedAuthnContext () const
    {
      return this->RequestedAuthnContext_;
    }

    AuthnQueryType::RequestedAuthnContext_optional& AuthnQueryType::
    RequestedAuthnContext ()
    {
      return this->RequestedAuthnContext_;
    }

    void AuthnQueryType::
    RequestedAuthnContext (const RequestedAuthnContext_type& RequestedAuthnContext)
    {
      this->RequestedAuthnContext_.set (RequestedAuthnContext);
    }

    void AuthnQueryType::
    RequestedAuthnContext (const RequestedAuthnContext_optional& RequestedAuthnContext)
    {
      this->RequestedAuthnContext_ = RequestedAuthnContext;
    }

    void AuthnQueryType::
    RequestedAuthnContext (::std::auto_ptr< RequestedAuthnContext_type > RequestedAuthnContext)
    {
      this->RequestedAuthnContext_.set (RequestedAuthnContext);
    }

    const AuthnQueryType::SessionIndex_optional& AuthnQueryType::
    SessionIndex () const
    {
      return this->SessionIndex_;
    }

    AuthnQueryType::SessionIndex_optional& AuthnQueryType::
    SessionIndex ()
    {
      return this->SessionIndex_;
    }

    void AuthnQueryType::
    SessionIndex (const SessionIndex_type& SessionIndex)
    {
      this->SessionIndex_.set (SessionIndex);
    }

    void AuthnQueryType::
    SessionIndex (const SessionIndex_optional& SessionIndex)
    {
      this->SessionIndex_ = SessionIndex;
    }

    void AuthnQueryType::
    SessionIndex (::std::auto_ptr< SessionIndex_type > SessionIndex)
    {
      this->SessionIndex_.set (SessionIndex);
    }


    // RequestedAuthnContextType
    // 

    const RequestedAuthnContextType::AuthnContextClassRef_sequence& RequestedAuthnContextType::
    AuthnContextClassRef () const
    {
      return this->AuthnContextClassRef_;
    }

    RequestedAuthnContextType::AuthnContextClassRef_sequence& RequestedAuthnContextType::
    AuthnContextClassRef ()
    {
      return this->AuthnContextClassRef_;
    }

    void RequestedAuthnContextType::
    AuthnContextClassRef (const AuthnContextClassRef_sequence& AuthnContextClassRef)
    {
      this->AuthnContextClassRef_ = AuthnContextClassRef;
    }

    const RequestedAuthnContextType::AuthnContextDeclRef_sequence& RequestedAuthnContextType::
    AuthnContextDeclRef () const
    {
      return this->AuthnContextDeclRef_;
    }

    RequestedAuthnContextType::AuthnContextDeclRef_sequence& RequestedAuthnContextType::
    AuthnContextDeclRef ()
    {
      return this->AuthnContextDeclRef_;
    }

    void RequestedAuthnContextType::
    AuthnContextDeclRef (const AuthnContextDeclRef_sequence& AuthnContextDeclRef)
    {
      this->AuthnContextDeclRef_ = AuthnContextDeclRef;
    }

    const RequestedAuthnContextType::Comparison_optional& RequestedAuthnContextType::
    Comparison () const
    {
      return this->Comparison_;
    }

    RequestedAuthnContextType::Comparison_optional& RequestedAuthnContextType::
    Comparison ()
    {
      return this->Comparison_;
    }

    void RequestedAuthnContextType::
    Comparison (const Comparison_type& Comparison)
    {
      this->Comparison_.set (Comparison);
    }

    void RequestedAuthnContextType::
    Comparison (const Comparison_optional& Comparison)
    {
      this->Comparison_ = Comparison;
    }

    void RequestedAuthnContextType::
    Comparison (::std::auto_ptr< Comparison_type > Comparison)
    {
      this->Comparison_.set (Comparison);
    }


    // AuthnContextComparisonType
    // 

    AuthnContextComparisonType::
    AuthnContextComparisonType ()
    : ::xml_schema::string ()
    {
    }

    AuthnContextComparisonType::
    AuthnContextComparisonType (value v)
    : ::xml_schema::string (_xsd_AuthnContextComparisonType_literals_[v])
    {
    }

    AuthnContextComparisonType::
    AuthnContextComparisonType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    AuthnContextComparisonType::
    AuthnContextComparisonType (const AuthnContextComparisonType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    AuthnContextComparisonType& AuthnContextComparisonType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_AuthnContextComparisonType_literals_[v]);

      return *this;
    }


    // AttributeQueryType
    // 

    const AttributeQueryType::Attribute_sequence& AttributeQueryType::
    Attribute () const
    {
      return this->Attribute_;
    }

    AttributeQueryType::Attribute_sequence& AttributeQueryType::
    Attribute ()
    {
      return this->Attribute_;
    }

    void AttributeQueryType::
    Attribute (const Attribute_sequence& Attribute)
    {
      this->Attribute_ = Attribute;
    }


    // AuthzDecisionQueryType
    // 

    const AuthzDecisionQueryType::Action_sequence& AuthzDecisionQueryType::
    Action () const
    {
      return this->Action_;
    }

    AuthzDecisionQueryType::Action_sequence& AuthzDecisionQueryType::
    Action ()
    {
      return this->Action_;
    }

    void AuthzDecisionQueryType::
    Action (const Action_sequence& Action)
    {
      this->Action_ = Action;
    }

    const AuthzDecisionQueryType::Evidence_optional& AuthzDecisionQueryType::
    Evidence () const
    {
      return this->Evidence_;
    }

    AuthzDecisionQueryType::Evidence_optional& AuthzDecisionQueryType::
    Evidence ()
    {
      return this->Evidence_;
    }

    void AuthzDecisionQueryType::
    Evidence (const Evidence_type& Evidence)
    {
      this->Evidence_.set (Evidence);
    }

    void AuthzDecisionQueryType::
    Evidence (const Evidence_optional& Evidence)
    {
      this->Evidence_ = Evidence;
    }

    void AuthzDecisionQueryType::
    Evidence (::std::auto_ptr< Evidence_type > Evidence)
    {
      this->Evidence_.set (Evidence);
    }

    const AuthzDecisionQueryType::Resource_type& AuthzDecisionQueryType::
    Resource () const
    {
      return this->Resource_.get ();
    }

    AuthzDecisionQueryType::Resource_type& AuthzDecisionQueryType::
    Resource ()
    {
      return this->Resource_.get ();
    }

    void AuthzDecisionQueryType::
    Resource (const Resource_type& Resource)
    {
      this->Resource_.set (Resource);
    }

    void AuthzDecisionQueryType::
    Resource (::std::auto_ptr< Resource_type > Resource)
    {
      this->Resource_.set (Resource);
    }


    // AuthnRequestType
    // 

    const AuthnRequestType::Subject_optional& AuthnRequestType::
    Subject () const
    {
      return this->Subject_;
    }

    AuthnRequestType::Subject_optional& AuthnRequestType::
    Subject ()
    {
      return this->Subject_;
    }

    void AuthnRequestType::
    Subject (const Subject_type& Subject)
    {
      this->Subject_.set (Subject);
    }

    void AuthnRequestType::
    Subject (const Subject_optional& Subject)
    {
      this->Subject_ = Subject;
    }

    void AuthnRequestType::
    Subject (::std::auto_ptr< Subject_type > Subject)
    {
      this->Subject_.set (Subject);
    }

    const AuthnRequestType::NameIDPolicy_optional& AuthnRequestType::
    NameIDPolicy () const
    {
      return this->NameIDPolicy_;
    }

    AuthnRequestType::NameIDPolicy_optional& AuthnRequestType::
    NameIDPolicy ()
    {
      return this->NameIDPolicy_;
    }

    void AuthnRequestType::
    NameIDPolicy (const NameIDPolicy_type& NameIDPolicy)
    {
      this->NameIDPolicy_.set (NameIDPolicy);
    }

    void AuthnRequestType::
    NameIDPolicy (const NameIDPolicy_optional& NameIDPolicy)
    {
      this->NameIDPolicy_ = NameIDPolicy;
    }

    void AuthnRequestType::
    NameIDPolicy (::std::auto_ptr< NameIDPolicy_type > NameIDPolicy)
    {
      this->NameIDPolicy_.set (NameIDPolicy);
    }

    const AuthnRequestType::Conditions_optional& AuthnRequestType::
    Conditions () const
    {
      return this->Conditions_;
    }

    AuthnRequestType::Conditions_optional& AuthnRequestType::
    Conditions ()
    {
      return this->Conditions_;
    }

    void AuthnRequestType::
    Conditions (const Conditions_type& Conditions)
    {
      this->Conditions_.set (Conditions);
    }

    void AuthnRequestType::
    Conditions (const Conditions_optional& Conditions)
    {
      this->Conditions_ = Conditions;
    }

    void AuthnRequestType::
    Conditions (::std::auto_ptr< Conditions_type > Conditions)
    {
      this->Conditions_.set (Conditions);
    }

    const AuthnRequestType::RequestedAuthnContext_optional& AuthnRequestType::
    RequestedAuthnContext () const
    {
      return this->RequestedAuthnContext_;
    }

    AuthnRequestType::RequestedAuthnContext_optional& AuthnRequestType::
    RequestedAuthnContext ()
    {
      return this->RequestedAuthnContext_;
    }

    void AuthnRequestType::
    RequestedAuthnContext (const RequestedAuthnContext_type& RequestedAuthnContext)
    {
      this->RequestedAuthnContext_.set (RequestedAuthnContext);
    }

    void AuthnRequestType::
    RequestedAuthnContext (const RequestedAuthnContext_optional& RequestedAuthnContext)
    {
      this->RequestedAuthnContext_ = RequestedAuthnContext;
    }

    void AuthnRequestType::
    RequestedAuthnContext (::std::auto_ptr< RequestedAuthnContext_type > RequestedAuthnContext)
    {
      this->RequestedAuthnContext_.set (RequestedAuthnContext);
    }

    const AuthnRequestType::Scoping_optional& AuthnRequestType::
    Scoping () const
    {
      return this->Scoping_;
    }

    AuthnRequestType::Scoping_optional& AuthnRequestType::
    Scoping ()
    {
      return this->Scoping_;
    }

    void AuthnRequestType::
    Scoping (const Scoping_type& Scoping)
    {
      this->Scoping_.set (Scoping);
    }

    void AuthnRequestType::
    Scoping (const Scoping_optional& Scoping)
    {
      this->Scoping_ = Scoping;
    }

    void AuthnRequestType::
    Scoping (::std::auto_ptr< Scoping_type > Scoping)
    {
      this->Scoping_.set (Scoping);
    }

    const AuthnRequestType::ForceAuthn_optional& AuthnRequestType::
    ForceAuthn () const
    {
      return this->ForceAuthn_;
    }

    AuthnRequestType::ForceAuthn_optional& AuthnRequestType::
    ForceAuthn ()
    {
      return this->ForceAuthn_;
    }

    void AuthnRequestType::
    ForceAuthn (const ForceAuthn_type& ForceAuthn)
    {
      this->ForceAuthn_.set (ForceAuthn);
    }

    void AuthnRequestType::
    ForceAuthn (const ForceAuthn_optional& ForceAuthn)
    {
      this->ForceAuthn_ = ForceAuthn;
    }

    const AuthnRequestType::IsPassive_optional& AuthnRequestType::
    IsPassive () const
    {
      return this->IsPassive_;
    }

    AuthnRequestType::IsPassive_optional& AuthnRequestType::
    IsPassive ()
    {
      return this->IsPassive_;
    }

    void AuthnRequestType::
    IsPassive (const IsPassive_type& IsPassive)
    {
      this->IsPassive_.set (IsPassive);
    }

    void AuthnRequestType::
    IsPassive (const IsPassive_optional& IsPassive)
    {
      this->IsPassive_ = IsPassive;
    }

    const AuthnRequestType::ProtocolBinding_optional& AuthnRequestType::
    ProtocolBinding () const
    {
      return this->ProtocolBinding_;
    }

    AuthnRequestType::ProtocolBinding_optional& AuthnRequestType::
    ProtocolBinding ()
    {
      return this->ProtocolBinding_;
    }

    void AuthnRequestType::
    ProtocolBinding (const ProtocolBinding_type& ProtocolBinding)
    {
      this->ProtocolBinding_.set (ProtocolBinding);
    }

    void AuthnRequestType::
    ProtocolBinding (const ProtocolBinding_optional& ProtocolBinding)
    {
      this->ProtocolBinding_ = ProtocolBinding;
    }

    void AuthnRequestType::
    ProtocolBinding (::std::auto_ptr< ProtocolBinding_type > ProtocolBinding)
    {
      this->ProtocolBinding_.set (ProtocolBinding);
    }

    const AuthnRequestType::AssertionConsumerServiceIndex_optional& AuthnRequestType::
    AssertionConsumerServiceIndex () const
    {
      return this->AssertionConsumerServiceIndex_;
    }

    AuthnRequestType::AssertionConsumerServiceIndex_optional& AuthnRequestType::
    AssertionConsumerServiceIndex ()
    {
      return this->AssertionConsumerServiceIndex_;
    }

    void AuthnRequestType::
    AssertionConsumerServiceIndex (const AssertionConsumerServiceIndex_type& AssertionConsumerServiceIndex)
    {
      this->AssertionConsumerServiceIndex_.set (AssertionConsumerServiceIndex);
    }

    void AuthnRequestType::
    AssertionConsumerServiceIndex (const AssertionConsumerServiceIndex_optional& AssertionConsumerServiceIndex)
    {
      this->AssertionConsumerServiceIndex_ = AssertionConsumerServiceIndex;
    }

    const AuthnRequestType::AssertionConsumerServiceURL_optional& AuthnRequestType::
    AssertionConsumerServiceURL () const
    {
      return this->AssertionConsumerServiceURL_;
    }

    AuthnRequestType::AssertionConsumerServiceURL_optional& AuthnRequestType::
    AssertionConsumerServiceURL ()
    {
      return this->AssertionConsumerServiceURL_;
    }

    void AuthnRequestType::
    AssertionConsumerServiceURL (const AssertionConsumerServiceURL_type& AssertionConsumerServiceURL)
    {
      this->AssertionConsumerServiceURL_.set (AssertionConsumerServiceURL);
    }

    void AuthnRequestType::
    AssertionConsumerServiceURL (const AssertionConsumerServiceURL_optional& AssertionConsumerServiceURL)
    {
      this->AssertionConsumerServiceURL_ = AssertionConsumerServiceURL;
    }

    void AuthnRequestType::
    AssertionConsumerServiceURL (::std::auto_ptr< AssertionConsumerServiceURL_type > AssertionConsumerServiceURL)
    {
      this->AssertionConsumerServiceURL_.set (AssertionConsumerServiceURL);
    }

    const AuthnRequestType::AttributeConsumingServiceIndex_optional& AuthnRequestType::
    AttributeConsumingServiceIndex () const
    {
      return this->AttributeConsumingServiceIndex_;
    }

    AuthnRequestType::AttributeConsumingServiceIndex_optional& AuthnRequestType::
    AttributeConsumingServiceIndex ()
    {
      return this->AttributeConsumingServiceIndex_;
    }

    void AuthnRequestType::
    AttributeConsumingServiceIndex (const AttributeConsumingServiceIndex_type& AttributeConsumingServiceIndex)
    {
      this->AttributeConsumingServiceIndex_.set (AttributeConsumingServiceIndex);
    }

    void AuthnRequestType::
    AttributeConsumingServiceIndex (const AttributeConsumingServiceIndex_optional& AttributeConsumingServiceIndex)
    {
      this->AttributeConsumingServiceIndex_ = AttributeConsumingServiceIndex;
    }

    const AuthnRequestType::ProviderName_optional& AuthnRequestType::
    ProviderName () const
    {
      return this->ProviderName_;
    }

    AuthnRequestType::ProviderName_optional& AuthnRequestType::
    ProviderName ()
    {
      return this->ProviderName_;
    }

    void AuthnRequestType::
    ProviderName (const ProviderName_type& ProviderName)
    {
      this->ProviderName_.set (ProviderName);
    }

    void AuthnRequestType::
    ProviderName (const ProviderName_optional& ProviderName)
    {
      this->ProviderName_ = ProviderName;
    }

    void AuthnRequestType::
    ProviderName (::std::auto_ptr< ProviderName_type > ProviderName)
    {
      this->ProviderName_.set (ProviderName);
    }


    // NameIDPolicyType
    // 

    const NameIDPolicyType::Format_optional& NameIDPolicyType::
    Format () const
    {
      return this->Format_;
    }

    NameIDPolicyType::Format_optional& NameIDPolicyType::
    Format ()
    {
      return this->Format_;
    }

    void NameIDPolicyType::
    Format (const Format_type& Format)
    {
      this->Format_.set (Format);
    }

    void NameIDPolicyType::
    Format (const Format_optional& Format)
    {
      this->Format_ = Format;
    }

    void NameIDPolicyType::
    Format (::std::auto_ptr< Format_type > Format)
    {
      this->Format_.set (Format);
    }

    const NameIDPolicyType::SPNameQualifier_optional& NameIDPolicyType::
    SPNameQualifier () const
    {
      return this->SPNameQualifier_;
    }

    NameIDPolicyType::SPNameQualifier_optional& NameIDPolicyType::
    SPNameQualifier ()
    {
      return this->SPNameQualifier_;
    }

    void NameIDPolicyType::
    SPNameQualifier (const SPNameQualifier_type& SPNameQualifier)
    {
      this->SPNameQualifier_.set (SPNameQualifier);
    }

    void NameIDPolicyType::
    SPNameQualifier (const SPNameQualifier_optional& SPNameQualifier)
    {
      this->SPNameQualifier_ = SPNameQualifier;
    }

    void NameIDPolicyType::
    SPNameQualifier (::std::auto_ptr< SPNameQualifier_type > SPNameQualifier)
    {
      this->SPNameQualifier_.set (SPNameQualifier);
    }

    const NameIDPolicyType::AllowCreate_optional& NameIDPolicyType::
    AllowCreate () const
    {
      return this->AllowCreate_;
    }

    NameIDPolicyType::AllowCreate_optional& NameIDPolicyType::
    AllowCreate ()
    {
      return this->AllowCreate_;
    }

    void NameIDPolicyType::
    AllowCreate (const AllowCreate_type& AllowCreate)
    {
      this->AllowCreate_.set (AllowCreate);
    }

    void NameIDPolicyType::
    AllowCreate (const AllowCreate_optional& AllowCreate)
    {
      this->AllowCreate_ = AllowCreate;
    }


    // ScopingType
    // 

    const ScopingType::IDPList_optional& ScopingType::
    IDPList () const
    {
      return this->IDPList_;
    }

    ScopingType::IDPList_optional& ScopingType::
    IDPList ()
    {
      return this->IDPList_;
    }

    void ScopingType::
    IDPList (const IDPList_type& IDPList)
    {
      this->IDPList_.set (IDPList);
    }

    void ScopingType::
    IDPList (const IDPList_optional& IDPList)
    {
      this->IDPList_ = IDPList;
    }

    void ScopingType::
    IDPList (::std::auto_ptr< IDPList_type > IDPList)
    {
      this->IDPList_.set (IDPList);
    }

    const ScopingType::RequesterID_sequence& ScopingType::
    RequesterID () const
    {
      return this->RequesterID_;
    }

    ScopingType::RequesterID_sequence& ScopingType::
    RequesterID ()
    {
      return this->RequesterID_;
    }

    void ScopingType::
    RequesterID (const RequesterID_sequence& RequesterID)
    {
      this->RequesterID_ = RequesterID;
    }

    const ScopingType::ProxyCount_optional& ScopingType::
    ProxyCount () const
    {
      return this->ProxyCount_;
    }

    ScopingType::ProxyCount_optional& ScopingType::
    ProxyCount ()
    {
      return this->ProxyCount_;
    }

    void ScopingType::
    ProxyCount (const ProxyCount_type& ProxyCount)
    {
      this->ProxyCount_.set (ProxyCount);
    }

    void ScopingType::
    ProxyCount (const ProxyCount_optional& ProxyCount)
    {
      this->ProxyCount_ = ProxyCount;
    }


    // IDPListType
    // 

    const IDPListType::IDPEntry_sequence& IDPListType::
    IDPEntry () const
    {
      return this->IDPEntry_;
    }

    IDPListType::IDPEntry_sequence& IDPListType::
    IDPEntry ()
    {
      return this->IDPEntry_;
    }

    void IDPListType::
    IDPEntry (const IDPEntry_sequence& IDPEntry)
    {
      this->IDPEntry_ = IDPEntry;
    }

    const IDPListType::GetComplete_optional& IDPListType::
    GetComplete () const
    {
      return this->GetComplete_;
    }

    IDPListType::GetComplete_optional& IDPListType::
    GetComplete ()
    {
      return this->GetComplete_;
    }

    void IDPListType::
    GetComplete (const GetComplete_type& GetComplete)
    {
      this->GetComplete_.set (GetComplete);
    }

    void IDPListType::
    GetComplete (const GetComplete_optional& GetComplete)
    {
      this->GetComplete_ = GetComplete;
    }

    void IDPListType::
    GetComplete (::std::auto_ptr< GetComplete_type > GetComplete)
    {
      this->GetComplete_.set (GetComplete);
    }


    // IDPEntryType
    // 

    const IDPEntryType::ProviderID_type& IDPEntryType::
    ProviderID () const
    {
      return this->ProviderID_.get ();
    }

    IDPEntryType::ProviderID_type& IDPEntryType::
    ProviderID ()
    {
      return this->ProviderID_.get ();
    }

    void IDPEntryType::
    ProviderID (const ProviderID_type& ProviderID)
    {
      this->ProviderID_.set (ProviderID);
    }

    void IDPEntryType::
    ProviderID (::std::auto_ptr< ProviderID_type > ProviderID)
    {
      this->ProviderID_.set (ProviderID);
    }

    const IDPEntryType::Name_optional& IDPEntryType::
    Name () const
    {
      return this->Name_;
    }

    IDPEntryType::Name_optional& IDPEntryType::
    Name ()
    {
      return this->Name_;
    }

    void IDPEntryType::
    Name (const Name_type& Name)
    {
      this->Name_.set (Name);
    }

    void IDPEntryType::
    Name (const Name_optional& Name)
    {
      this->Name_ = Name;
    }

    void IDPEntryType::
    Name (::std::auto_ptr< Name_type > Name)
    {
      this->Name_.set (Name);
    }

    const IDPEntryType::Loc_optional& IDPEntryType::
    Loc () const
    {
      return this->Loc_;
    }

    IDPEntryType::Loc_optional& IDPEntryType::
    Loc ()
    {
      return this->Loc_;
    }

    void IDPEntryType::
    Loc (const Loc_type& Loc)
    {
      this->Loc_.set (Loc);
    }

    void IDPEntryType::
    Loc (const Loc_optional& Loc)
    {
      this->Loc_ = Loc;
    }

    void IDPEntryType::
    Loc (::std::auto_ptr< Loc_type > Loc)
    {
      this->Loc_.set (Loc);
    }


    // ResponseType
    // 

    const ResponseType::Assertion_sequence& ResponseType::
    Assertion () const
    {
      return this->Assertion_;
    }

    ResponseType::Assertion_sequence& ResponseType::
    Assertion ()
    {
      return this->Assertion_;
    }

    void ResponseType::
    Assertion (const Assertion_sequence& Assertion)
    {
      this->Assertion_ = Assertion;
    }

    const ResponseType::EncryptedAssertion_sequence& ResponseType::
    EncryptedAssertion () const
    {
      return this->EncryptedAssertion_;
    }

    ResponseType::EncryptedAssertion_sequence& ResponseType::
    EncryptedAssertion ()
    {
      return this->EncryptedAssertion_;
    }

    void ResponseType::
    EncryptedAssertion (const EncryptedAssertion_sequence& EncryptedAssertion)
    {
      this->EncryptedAssertion_ = EncryptedAssertion;
    }


    // ArtifactResolveType
    // 

    const ArtifactResolveType::Artifact_type& ArtifactResolveType::
    Artifact () const
    {
      return this->Artifact_.get ();
    }

    ArtifactResolveType::Artifact_type& ArtifactResolveType::
    Artifact ()
    {
      return this->Artifact_.get ();
    }

    void ArtifactResolveType::
    Artifact (const Artifact_type& Artifact)
    {
      this->Artifact_.set (Artifact);
    }

    void ArtifactResolveType::
    Artifact (::std::auto_ptr< Artifact_type > Artifact)
    {
      this->Artifact_.set (Artifact);
    }


    // ArtifactResponseType
    // 

    const ArtifactResponseType::any_optional& ArtifactResponseType::
    any () const
    {
      return this->any_;
    }

    ArtifactResponseType::any_optional& ArtifactResponseType::
    any ()
    {
      return this->any_;
    }

    void ArtifactResponseType::
    any (const ::xercesc::DOMElement& any)
    {
      this->any_.set (any);
    }

    void ArtifactResponseType::
    any (::xercesc::DOMElement* any)
    {
      this->any_.set (any);
    }

    void ArtifactResponseType::
    any (const any_optional& any)
    {
      this->any_ = any;
    }

    const ::xercesc::DOMDocument& ArtifactResponseType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& ArtifactResponseType::
    dom_document ()
    {
      return *dom_document_;
    }


    // ManageNameIDRequestType
    // 

    const ManageNameIDRequestType::NameID_optional& ManageNameIDRequestType::
    NameID () const
    {
      return this->NameID_;
    }

    ManageNameIDRequestType::NameID_optional& ManageNameIDRequestType::
    NameID ()
    {
      return this->NameID_;
    }

    void ManageNameIDRequestType::
    NameID (const NameID_type& NameID)
    {
      this->NameID_.set (NameID);
    }

    void ManageNameIDRequestType::
    NameID (const NameID_optional& NameID)
    {
      this->NameID_ = NameID;
    }

    void ManageNameIDRequestType::
    NameID (::std::auto_ptr< NameID_type > NameID)
    {
      this->NameID_.set (NameID);
    }

    const ManageNameIDRequestType::EncryptedID_optional& ManageNameIDRequestType::
    EncryptedID () const
    {
      return this->EncryptedID_;
    }

    ManageNameIDRequestType::EncryptedID_optional& ManageNameIDRequestType::
    EncryptedID ()
    {
      return this->EncryptedID_;
    }

    void ManageNameIDRequestType::
    EncryptedID (const EncryptedID_type& EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    void ManageNameIDRequestType::
    EncryptedID (const EncryptedID_optional& EncryptedID)
    {
      this->EncryptedID_ = EncryptedID;
    }

    void ManageNameIDRequestType::
    EncryptedID (::std::auto_ptr< EncryptedID_type > EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    const ManageNameIDRequestType::NewID_optional& ManageNameIDRequestType::
    NewID () const
    {
      return this->NewID_;
    }

    ManageNameIDRequestType::NewID_optional& ManageNameIDRequestType::
    NewID ()
    {
      return this->NewID_;
    }

    void ManageNameIDRequestType::
    NewID (const NewID_type& NewID)
    {
      this->NewID_.set (NewID);
    }

    void ManageNameIDRequestType::
    NewID (const NewID_optional& NewID)
    {
      this->NewID_ = NewID;
    }

    void ManageNameIDRequestType::
    NewID (::std::auto_ptr< NewID_type > NewID)
    {
      this->NewID_.set (NewID);
    }

    const ManageNameIDRequestType::NewEncryptedID_optional& ManageNameIDRequestType::
    NewEncryptedID () const
    {
      return this->NewEncryptedID_;
    }

    ManageNameIDRequestType::NewEncryptedID_optional& ManageNameIDRequestType::
    NewEncryptedID ()
    {
      return this->NewEncryptedID_;
    }

    void ManageNameIDRequestType::
    NewEncryptedID (const NewEncryptedID_type& NewEncryptedID)
    {
      this->NewEncryptedID_.set (NewEncryptedID);
    }

    void ManageNameIDRequestType::
    NewEncryptedID (const NewEncryptedID_optional& NewEncryptedID)
    {
      this->NewEncryptedID_ = NewEncryptedID;
    }

    void ManageNameIDRequestType::
    NewEncryptedID (::std::auto_ptr< NewEncryptedID_type > NewEncryptedID)
    {
      this->NewEncryptedID_.set (NewEncryptedID);
    }

    const ManageNameIDRequestType::Terminate_optional& ManageNameIDRequestType::
    Terminate () const
    {
      return this->Terminate_;
    }

    ManageNameIDRequestType::Terminate_optional& ManageNameIDRequestType::
    Terminate ()
    {
      return this->Terminate_;
    }

    void ManageNameIDRequestType::
    Terminate (const Terminate_type& Terminate)
    {
      this->Terminate_.set (Terminate);
    }

    void ManageNameIDRequestType::
    Terminate (const Terminate_optional& Terminate)
    {
      this->Terminate_ = Terminate;
    }

    void ManageNameIDRequestType::
    Terminate (::std::auto_ptr< Terminate_type > Terminate)
    {
      this->Terminate_.set (Terminate);
    }


    // TerminateType
    // 


    // LogoutRequestType
    // 

    const LogoutRequestType::BaseID_optional& LogoutRequestType::
    BaseID () const
    {
      return this->BaseID_;
    }

    LogoutRequestType::BaseID_optional& LogoutRequestType::
    BaseID ()
    {
      return this->BaseID_;
    }

    void LogoutRequestType::
    BaseID (const BaseID_type& BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    void LogoutRequestType::
    BaseID (const BaseID_optional& BaseID)
    {
      this->BaseID_ = BaseID;
    }

    void LogoutRequestType::
    BaseID (::std::auto_ptr< BaseID_type > BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    const LogoutRequestType::NameID_optional& LogoutRequestType::
    NameID () const
    {
      return this->NameID_;
    }

    LogoutRequestType::NameID_optional& LogoutRequestType::
    NameID ()
    {
      return this->NameID_;
    }

    void LogoutRequestType::
    NameID (const NameID_type& NameID)
    {
      this->NameID_.set (NameID);
    }

    void LogoutRequestType::
    NameID (const NameID_optional& NameID)
    {
      this->NameID_ = NameID;
    }

    void LogoutRequestType::
    NameID (::std::auto_ptr< NameID_type > NameID)
    {
      this->NameID_.set (NameID);
    }

    const LogoutRequestType::EncryptedID_optional& LogoutRequestType::
    EncryptedID () const
    {
      return this->EncryptedID_;
    }

    LogoutRequestType::EncryptedID_optional& LogoutRequestType::
    EncryptedID ()
    {
      return this->EncryptedID_;
    }

    void LogoutRequestType::
    EncryptedID (const EncryptedID_type& EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    void LogoutRequestType::
    EncryptedID (const EncryptedID_optional& EncryptedID)
    {
      this->EncryptedID_ = EncryptedID;
    }

    void LogoutRequestType::
    EncryptedID (::std::auto_ptr< EncryptedID_type > EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    const LogoutRequestType::SessionIndex_sequence& LogoutRequestType::
    SessionIndex () const
    {
      return this->SessionIndex_;
    }

    LogoutRequestType::SessionIndex_sequence& LogoutRequestType::
    SessionIndex ()
    {
      return this->SessionIndex_;
    }

    void LogoutRequestType::
    SessionIndex (const SessionIndex_sequence& SessionIndex)
    {
      this->SessionIndex_ = SessionIndex;
    }

    const LogoutRequestType::Reason_optional& LogoutRequestType::
    Reason () const
    {
      return this->Reason_;
    }

    LogoutRequestType::Reason_optional& LogoutRequestType::
    Reason ()
    {
      return this->Reason_;
    }

    void LogoutRequestType::
    Reason (const Reason_type& Reason)
    {
      this->Reason_.set (Reason);
    }

    void LogoutRequestType::
    Reason (const Reason_optional& Reason)
    {
      this->Reason_ = Reason;
    }

    void LogoutRequestType::
    Reason (::std::auto_ptr< Reason_type > Reason)
    {
      this->Reason_.set (Reason);
    }

    const LogoutRequestType::NotOnOrAfter_optional& LogoutRequestType::
    NotOnOrAfter () const
    {
      return this->NotOnOrAfter_;
    }

    LogoutRequestType::NotOnOrAfter_optional& LogoutRequestType::
    NotOnOrAfter ()
    {
      return this->NotOnOrAfter_;
    }

    void LogoutRequestType::
    NotOnOrAfter (const NotOnOrAfter_type& NotOnOrAfter)
    {
      this->NotOnOrAfter_.set (NotOnOrAfter);
    }

    void LogoutRequestType::
    NotOnOrAfter (const NotOnOrAfter_optional& NotOnOrAfter)
    {
      this->NotOnOrAfter_ = NotOnOrAfter;
    }

    void LogoutRequestType::
    NotOnOrAfter (::std::auto_ptr< NotOnOrAfter_type > NotOnOrAfter)
    {
      this->NotOnOrAfter_.set (NotOnOrAfter);
    }


    // NameIDMappingRequestType
    // 

    const NameIDMappingRequestType::BaseID_optional& NameIDMappingRequestType::
    BaseID () const
    {
      return this->BaseID_;
    }

    NameIDMappingRequestType::BaseID_optional& NameIDMappingRequestType::
    BaseID ()
    {
      return this->BaseID_;
    }

    void NameIDMappingRequestType::
    BaseID (const BaseID_type& BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    void NameIDMappingRequestType::
    BaseID (const BaseID_optional& BaseID)
    {
      this->BaseID_ = BaseID;
    }

    void NameIDMappingRequestType::
    BaseID (::std::auto_ptr< BaseID_type > BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    const NameIDMappingRequestType::NameID_optional& NameIDMappingRequestType::
    NameID () const
    {
      return this->NameID_;
    }

    NameIDMappingRequestType::NameID_optional& NameIDMappingRequestType::
    NameID ()
    {
      return this->NameID_;
    }

    void NameIDMappingRequestType::
    NameID (const NameID_type& NameID)
    {
      this->NameID_.set (NameID);
    }

    void NameIDMappingRequestType::
    NameID (const NameID_optional& NameID)
    {
      this->NameID_ = NameID;
    }

    void NameIDMappingRequestType::
    NameID (::std::auto_ptr< NameID_type > NameID)
    {
      this->NameID_.set (NameID);
    }

    const NameIDMappingRequestType::EncryptedID_optional& NameIDMappingRequestType::
    EncryptedID () const
    {
      return this->EncryptedID_;
    }

    NameIDMappingRequestType::EncryptedID_optional& NameIDMappingRequestType::
    EncryptedID ()
    {
      return this->EncryptedID_;
    }

    void NameIDMappingRequestType::
    EncryptedID (const EncryptedID_type& EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    void NameIDMappingRequestType::
    EncryptedID (const EncryptedID_optional& EncryptedID)
    {
      this->EncryptedID_ = EncryptedID;
    }

    void NameIDMappingRequestType::
    EncryptedID (::std::auto_ptr< EncryptedID_type > EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    const NameIDMappingRequestType::NameIDPolicy_type& NameIDMappingRequestType::
    NameIDPolicy () const
    {
      return this->NameIDPolicy_.get ();
    }

    NameIDMappingRequestType::NameIDPolicy_type& NameIDMappingRequestType::
    NameIDPolicy ()
    {
      return this->NameIDPolicy_.get ();
    }

    void NameIDMappingRequestType::
    NameIDPolicy (const NameIDPolicy_type& NameIDPolicy)
    {
      this->NameIDPolicy_.set (NameIDPolicy);
    }

    void NameIDMappingRequestType::
    NameIDPolicy (::std::auto_ptr< NameIDPolicy_type > NameIDPolicy)
    {
      this->NameIDPolicy_.set (NameIDPolicy);
    }


    // NameIDMappingResponseType
    // 

    const NameIDMappingResponseType::NameID_optional& NameIDMappingResponseType::
    NameID () const
    {
      return this->NameID_;
    }

    NameIDMappingResponseType::NameID_optional& NameIDMappingResponseType::
    NameID ()
    {
      return this->NameID_;
    }

    void NameIDMappingResponseType::
    NameID (const NameID_type& NameID)
    {
      this->NameID_.set (NameID);
    }

    void NameIDMappingResponseType::
    NameID (const NameID_optional& NameID)
    {
      this->NameID_ = NameID;
    }

    void NameIDMappingResponseType::
    NameID (::std::auto_ptr< NameID_type > NameID)
    {
      this->NameID_.set (NameID);
    }

    const NameIDMappingResponseType::EncryptedID_optional& NameIDMappingResponseType::
    EncryptedID () const
    {
      return this->EncryptedID_;
    }

    NameIDMappingResponseType::EncryptedID_optional& NameIDMappingResponseType::
    EncryptedID ()
    {
      return this->EncryptedID_;
    }

    void NameIDMappingResponseType::
    EncryptedID (const EncryptedID_type& EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    void NameIDMappingResponseType::
    EncryptedID (const EncryptedID_optional& EncryptedID)
    {
      this->EncryptedID_ = EncryptedID;
    }

    void NameIDMappingResponseType::
    EncryptedID (::std::auto_ptr< EncryptedID_type > EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace saml2
{
  namespace protocol
  {
    // RequestAbstractType
    //

    RequestAbstractType::
    RequestAbstractType ()
    : ::xml_schema::type (),
      Issuer_ (::xml_schema::flags (), this),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      Version_ (::xml_schema::flags (), this),
      IssueInstant_ (::xml_schema::flags (), this),
      Destination_ (::xml_schema::flags (), this),
      Consent_ (::xml_schema::flags (), this)
    {
    }

    RequestAbstractType::
    RequestAbstractType (const ID_type& ID,
                         const Version_type& Version,
                         const IssueInstant_type& IssueInstant)
    : ::xml_schema::type (),
      Issuer_ (::xml_schema::flags (), this),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      ID_ (ID, ::xml_schema::flags (), this),
      Version_ (Version, ::xml_schema::flags (), this),
      IssueInstant_ (IssueInstant, ::xml_schema::flags (), this),
      Destination_ (::xml_schema::flags (), this),
      Consent_ (::xml_schema::flags (), this)
    {
    }

    RequestAbstractType::
    RequestAbstractType (const RequestAbstractType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      Issuer_ (x.Issuer_, f, this),
      Signature_ (x.Signature_, f, this),
      Extensions_ (x.Extensions_, f, this),
      ID_ (x.ID_, f, this),
      Version_ (x.Version_, f, this),
      IssueInstant_ (x.IssueInstant_, f, this),
      Destination_ (x.Destination_, f, this),
      Consent_ (x.Consent_, f, this)
    {
    }

    RequestAbstractType::
    RequestAbstractType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Issuer_ (f, this),
      Signature_ (f, this),
      Extensions_ (f, this),
      ID_ (f, this),
      Version_ (f, this),
      IssueInstant_ (f, this),
      Destination_ (f, this),
      Consent_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void RequestAbstractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Issuer
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Issuer",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Issuer_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Issuer ())
            {
              ::std::auto_ptr< Issuer_type > r (
                dynamic_cast< Issuer_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Issuer (r);
              continue;
            }
          }
        }

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Signature_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Signature ())
            {
              ::std::auto_ptr< Signature_type > r (
                dynamic_cast< Signature_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Signature (r);
              continue;
            }
          }
        }

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"ID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID_type > r (
            ID_traits::create (i, f, this));

          this->ID (r);
          continue;
        }

        if (n.name () == L"Version" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          this->Version (r);
          continue;
        }

        if (n.name () == L"IssueInstant" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IssueInstant_type > r (
            IssueInstant_traits::create (i, f, this));

          this->IssueInstant (r);
          continue;
        }

        if (n.name () == L"Destination" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Destination_type > r (
            Destination_traits::create (i, f, this));

          this->Destination (r);
          continue;
        }

        if (n.name () == L"Consent" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Consent_type > r (
            Consent_traits::create (i, f, this));

          this->Consent (r);
          continue;
        }
      }

      if (!ID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"ID",
          L"");
      }

      if (!Version_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Version",
          L"");
      }

      if (!IssueInstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"IssueInstant",
          L"");
      }
    }

    RequestAbstractType* RequestAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new RequestAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, RequestAbstractType >
    _xsd_RequestAbstractType_type_factory_init (
      L"RequestAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // ExtensionsType
    //

    ExtensionsType::
    ExtensionsType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
    }

    ExtensionsType::
    ExtensionsType (const ExtensionsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ())
    {
    }

    ExtensionsType::
    ExtensionsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ExtensionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:protocol"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any ().push_back (r);
          continue;
        }

        break;
      }
    }

    ExtensionsType* ExtensionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ExtensionsType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ExtensionsType >
    _xsd_ExtensionsType_type_factory_init (
      L"ExtensionsType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // StatusResponseType
    //

    StatusResponseType::
    StatusResponseType ()
    : ::xml_schema::type (),
      Issuer_ (::xml_schema::flags (), this),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      Status_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      InResponseTo_ (::xml_schema::flags (), this),
      Version_ (::xml_schema::flags (), this),
      IssueInstant_ (::xml_schema::flags (), this),
      Destination_ (::xml_schema::flags (), this),
      Consent_ (::xml_schema::flags (), this)
    {
    }

    StatusResponseType::
    StatusResponseType (const Status_type& Status,
                        const ID_type& ID,
                        const Version_type& Version,
                        const IssueInstant_type& IssueInstant)
    : ::xml_schema::type (),
      Issuer_ (::xml_schema::flags (), this),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      Status_ (Status, ::xml_schema::flags (), this),
      ID_ (ID, ::xml_schema::flags (), this),
      InResponseTo_ (::xml_schema::flags (), this),
      Version_ (Version, ::xml_schema::flags (), this),
      IssueInstant_ (IssueInstant, ::xml_schema::flags (), this),
      Destination_ (::xml_schema::flags (), this),
      Consent_ (::xml_schema::flags (), this)
    {
    }

    StatusResponseType::
    StatusResponseType (const StatusResponseType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      Issuer_ (x.Issuer_, f, this),
      Signature_ (x.Signature_, f, this),
      Extensions_ (x.Extensions_, f, this),
      Status_ (x.Status_, f, this),
      ID_ (x.ID_, f, this),
      InResponseTo_ (x.InResponseTo_, f, this),
      Version_ (x.Version_, f, this),
      IssueInstant_ (x.IssueInstant_, f, this),
      Destination_ (x.Destination_, f, this),
      Consent_ (x.Consent_, f, this)
    {
    }

    StatusResponseType::
    StatusResponseType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Issuer_ (f, this),
      Signature_ (f, this),
      Extensions_ (f, this),
      Status_ (f, this),
      ID_ (f, this),
      InResponseTo_ (f, this),
      Version_ (f, this),
      IssueInstant_ (f, this),
      Destination_ (f, this),
      Consent_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void StatusResponseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Issuer
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Issuer",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Issuer_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Issuer ())
            {
              ::std::auto_ptr< Issuer_type > r (
                dynamic_cast< Issuer_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Issuer (r);
              continue;
            }
          }
        }

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Signature_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Signature ())
            {
              ::std::auto_ptr< Signature_type > r (
                dynamic_cast< Signature_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Signature (r);
              continue;
            }
          }
        }

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        // Status
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Status",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< Status_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Status_.present ())
            {
              ::std::auto_ptr< Status_type > r (
                dynamic_cast< Status_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Status (r);
              continue;
            }
          }
        }

        break;
      }

      if (!Status_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Status",
          L"urn:oasis:names:tc:SAML:2.0:protocol");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"ID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID_type > r (
            ID_traits::create (i, f, this));

          this->ID (r);
          continue;
        }

        if (n.name () == L"InResponseTo" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< InResponseTo_type > r (
            InResponseTo_traits::create (i, f, this));

          this->InResponseTo (r);
          continue;
        }

        if (n.name () == L"Version" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          this->Version (r);
          continue;
        }

        if (n.name () == L"IssueInstant" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IssueInstant_type > r (
            IssueInstant_traits::create (i, f, this));

          this->IssueInstant (r);
          continue;
        }

        if (n.name () == L"Destination" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Destination_type > r (
            Destination_traits::create (i, f, this));

          this->Destination (r);
          continue;
        }

        if (n.name () == L"Consent" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Consent_type > r (
            Consent_traits::create (i, f, this));

          this->Consent (r);
          continue;
        }
      }

      if (!ID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"ID",
          L"");
      }

      if (!Version_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Version",
          L"");
      }

      if (!IssueInstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"IssueInstant",
          L"");
      }
    }

    StatusResponseType* StatusResponseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new StatusResponseType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StatusResponseType >
    _xsd_StatusResponseType_type_factory_init (
      L"StatusResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // StatusType
    //

    StatusType::
    StatusType ()
    : ::xml_schema::type (),
      StatusCode_ (::xml_schema::flags (), this),
      StatusMessage_ (::xml_schema::flags (), this),
      StatusDetail_ (::xml_schema::flags (), this)
    {
    }

    StatusType::
    StatusType (const StatusCode_type& StatusCode)
    : ::xml_schema::type (),
      StatusCode_ (StatusCode, ::xml_schema::flags (), this),
      StatusMessage_ (::xml_schema::flags (), this),
      StatusDetail_ (::xml_schema::flags (), this)
    {
    }

    StatusType::
    StatusType (const StatusType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      StatusCode_ (x.StatusCode_, f, this),
      StatusMessage_ (x.StatusMessage_, f, this),
      StatusDetail_ (x.StatusDetail_, f, this)
    {
    }

    StatusType::
    StatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StatusCode_ (f, this),
      StatusMessage_ (f, this),
      StatusDetail_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void StatusType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StatusCode
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"StatusCode",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< StatusCode_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!StatusCode_.present ())
            {
              ::std::auto_ptr< StatusCode_type > r (
                dynamic_cast< StatusCode_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->StatusCode (r);
              continue;
            }
          }
        }

        // StatusMessage
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"StatusMessage",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< StatusMessage_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->StatusMessage ())
            {
              ::std::auto_ptr< StatusMessage_type > r (
                dynamic_cast< StatusMessage_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->StatusMessage (r);
              continue;
            }
          }
        }

        // StatusDetail
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"StatusDetail",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< StatusDetail_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->StatusDetail ())
            {
              ::std::auto_ptr< StatusDetail_type > r (
                dynamic_cast< StatusDetail_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->StatusDetail (r);
              continue;
            }
          }
        }

        break;
      }

      if (!StatusCode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"StatusCode",
          L"urn:oasis:names:tc:SAML:2.0:protocol");
      }
    }

    StatusType* StatusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new StatusType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StatusType >
    _xsd_StatusType_type_factory_init (
      L"StatusType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // StatusCodeType
    //

    StatusCodeType::
    StatusCodeType ()
    : ::xml_schema::type (),
      StatusCode_ (::xml_schema::flags (), this),
      Value_ (::xml_schema::flags (), this)
    {
    }

    StatusCodeType::
    StatusCodeType (const Value_type& Value)
    : ::xml_schema::type (),
      StatusCode_ (::xml_schema::flags (), this),
      Value_ (Value, ::xml_schema::flags (), this)
    {
    }

    StatusCodeType::
    StatusCodeType (const StatusCodeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      StatusCode_ (x.StatusCode_, f, this),
      Value_ (x.Value_, f, this)
    {
    }

    StatusCodeType::
    StatusCodeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StatusCode_ (f, this),
      Value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void StatusCodeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // StatusCode
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"StatusCode",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< StatusCode_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->StatusCode ())
            {
              ::std::auto_ptr< StatusCode_type > r (
                dynamic_cast< StatusCode_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->StatusCode (r);
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Value" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Value_type > r (
            Value_traits::create (i, f, this));

          this->Value (r);
          continue;
        }
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Value",
          L"");
      }
    }

    StatusCodeType* StatusCodeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new StatusCodeType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StatusCodeType >
    _xsd_StatusCodeType_type_factory_init (
      L"StatusCodeType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // StatusDetailType
    //

    StatusDetailType::
    StatusDetailType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
    }

    StatusDetailType::
    StatusDetailType (const StatusDetailType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ())
    {
    }

    StatusDetailType::
    StatusDetailType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void StatusDetailType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any ().push_back (r);
          continue;
        }

        break;
      }
    }

    StatusDetailType* StatusDetailType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new StatusDetailType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StatusDetailType >
    _xsd_StatusDetailType_type_factory_init (
      L"StatusDetailType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // AssertionIDRequestType
    //

    AssertionIDRequestType::
    AssertionIDRequestType ()
    : ::saml2::protocol::RequestAbstractType (),
      AssertionIDRef_ (::xml_schema::flags (), this)
    {
    }

    AssertionIDRequestType::
    AssertionIDRequestType (const ID_type& ID,
                            const Version_type& Version,
                            const IssueInstant_type& IssueInstant)
    : ::saml2::protocol::RequestAbstractType (ID,
                                              Version,
                                              IssueInstant),
      AssertionIDRef_ (::xml_schema::flags (), this)
    {
    }

    AssertionIDRequestType::
    AssertionIDRequestType (const AssertionIDRequestType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (x, f, c),
      AssertionIDRef_ (x.AssertionIDRef_, f, this)
    {
    }

    AssertionIDRequestType::
    AssertionIDRequestType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (e, f | ::xml_schema::flags::base, c),
      AssertionIDRef_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AssertionIDRequestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::RequestAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AssertionIDRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AssertionIDRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionIDRef_type > r (
              dynamic_cast< AssertionIDRef_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionIDRef ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AssertionIDRequestType* AssertionIDRequestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AssertionIDRequestType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AssertionIDRequestType >
    _xsd_AssertionIDRequestType_type_factory_init (
      L"AssertionIDRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // SubjectQueryAbstractType
    //

    SubjectQueryAbstractType::
    SubjectQueryAbstractType ()
    : ::saml2::protocol::RequestAbstractType (),
      Subject_ (::xml_schema::flags (), this)
    {
    }

    SubjectQueryAbstractType::
    SubjectQueryAbstractType (const ID_type& ID,
                              const Version_type& Version,
                              const IssueInstant_type& IssueInstant,
                              const Subject_type& Subject)
    : ::saml2::protocol::RequestAbstractType (ID,
                                              Version,
                                              IssueInstant),
      Subject_ (Subject, ::xml_schema::flags (), this)
    {
    }

    SubjectQueryAbstractType::
    SubjectQueryAbstractType (const SubjectQueryAbstractType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (x, f, c),
      Subject_ (x.Subject_, f, this)
    {
    }

    SubjectQueryAbstractType::
    SubjectQueryAbstractType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (e, f | ::xml_schema::flags::base, c),
      Subject_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void SubjectQueryAbstractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::RequestAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Subject
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Subject",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Subject_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Subject_.present ())
            {
              ::std::auto_ptr< Subject_type > r (
                dynamic_cast< Subject_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Subject (r);
              continue;
            }
          }
        }

        break;
      }

      if (!Subject_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Subject",
          L"urn:oasis:names:tc:SAML:2.0:assertion");
      }
    }

    SubjectQueryAbstractType* SubjectQueryAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectQueryAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectQueryAbstractType >
    _xsd_SubjectQueryAbstractType_type_factory_init (
      L"SubjectQueryAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // AuthnQueryType
    //

    AuthnQueryType::
    AuthnQueryType ()
    : ::saml2::protocol::SubjectQueryAbstractType (),
      RequestedAuthnContext_ (::xml_schema::flags (), this),
      SessionIndex_ (::xml_schema::flags (), this)
    {
    }

    AuthnQueryType::
    AuthnQueryType (const ID_type& ID,
                    const Version_type& Version,
                    const IssueInstant_type& IssueInstant,
                    const Subject_type& Subject)
    : ::saml2::protocol::SubjectQueryAbstractType (ID,
                                                   Version,
                                                   IssueInstant,
                                                   Subject),
      RequestedAuthnContext_ (::xml_schema::flags (), this),
      SessionIndex_ (::xml_schema::flags (), this)
    {
    }

    AuthnQueryType::
    AuthnQueryType (const AuthnQueryType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::protocol::SubjectQueryAbstractType (x, f, c),
      RequestedAuthnContext_ (x.RequestedAuthnContext_, f, this),
      SessionIndex_ (x.SessionIndex_, f, this)
    {
    }

    AuthnQueryType::
    AuthnQueryType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::protocol::SubjectQueryAbstractType (e, f | ::xml_schema::flags::base, c),
      RequestedAuthnContext_ (f, this),
      SessionIndex_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AuthnQueryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::SubjectQueryAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // RequestedAuthnContext
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"RequestedAuthnContext",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< RequestedAuthnContext_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->RequestedAuthnContext ())
            {
              ::std::auto_ptr< RequestedAuthnContext_type > r (
                dynamic_cast< RequestedAuthnContext_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->RequestedAuthnContext (r);
              continue;
            }
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"SessionIndex" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SessionIndex_type > r (
            SessionIndex_traits::create (i, f, this));

          this->SessionIndex (r);
          continue;
        }
      }
    }

    AuthnQueryType* AuthnQueryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnQueryType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnQueryType >
    _xsd_AuthnQueryType_type_factory_init (
      L"AuthnQueryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // RequestedAuthnContextType
    //

    RequestedAuthnContextType::
    RequestedAuthnContextType ()
    : ::xml_schema::type (),
      AuthnContextClassRef_ (::xml_schema::flags (), this),
      AuthnContextDeclRef_ (::xml_schema::flags (), this),
      Comparison_ (::xml_schema::flags (), this)
    {
    }

    RequestedAuthnContextType::
    RequestedAuthnContextType (const RequestedAuthnContextType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      AuthnContextClassRef_ (x.AuthnContextClassRef_, f, this),
      AuthnContextDeclRef_ (x.AuthnContextDeclRef_, f, this),
      Comparison_ (x.Comparison_, f, this)
    {
    }

    RequestedAuthnContextType::
    RequestedAuthnContextType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AuthnContextClassRef_ (f, this),
      AuthnContextDeclRef_ (f, this),
      Comparison_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void RequestedAuthnContextType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AuthnContextClassRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnContextClassRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthnContextClassRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthnContextClassRef_type > r (
              dynamic_cast< AuthnContextClassRef_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthnContextClassRef ().push_back (r);
            continue;
          }
        }

        // AuthnContextDeclRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnContextDeclRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthnContextDeclRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthnContextDeclRef_type > r (
              dynamic_cast< AuthnContextDeclRef_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthnContextDeclRef ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Comparison" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Comparison_type > r (
            Comparison_traits::create (i, f, this));

          this->Comparison (r);
          continue;
        }
      }
    }

    RequestedAuthnContextType* RequestedAuthnContextType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new RequestedAuthnContextType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, RequestedAuthnContextType >
    _xsd_RequestedAuthnContextType_type_factory_init (
      L"RequestedAuthnContextType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // AuthnContextComparisonType
    //

    AuthnContextComparisonType::
    AuthnContextComparisonType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_AuthnContextComparisonType_convert ();
    }

    AuthnContextComparisonType::
    AuthnContextComparisonType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_AuthnContextComparisonType_convert ();
    }

    AuthnContextComparisonType::
    AuthnContextComparisonType (const ::std::wstring& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_AuthnContextComparisonType_convert ();
    }

    AuthnContextComparisonType* AuthnContextComparisonType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnContextComparisonType (*this, f, c);
    }

    AuthnContextComparisonType::value AuthnContextComparisonType::
    _xsd_AuthnContextComparisonType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_AuthnContextComparisonType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AuthnContextComparisonType_indexes_,
                        _xsd_AuthnContextComparisonType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_AuthnContextComparisonType_indexes_ + 4 || _xsd_AuthnContextComparisonType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const AuthnContextComparisonType::
    _xsd_AuthnContextComparisonType_literals_[4] =
    {
      L"exact",
      L"minimum",
      L"maximum",
      L"better"
    };

    const AuthnContextComparisonType::value AuthnContextComparisonType::
    _xsd_AuthnContextComparisonType_indexes_[4] =
    {
      ::saml2::protocol::AuthnContextComparisonType::better,
      ::saml2::protocol::AuthnContextComparisonType::exact,
      ::saml2::protocol::AuthnContextComparisonType::maximum,
      ::saml2::protocol::AuthnContextComparisonType::minimum
    };

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnContextComparisonType >
    _xsd_AuthnContextComparisonType_type_factory_init (
      L"AuthnContextComparisonType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // AttributeQueryType
    //

    AttributeQueryType::
    AttributeQueryType ()
    : ::saml2::protocol::SubjectQueryAbstractType (),
      Attribute_ (::xml_schema::flags (), this)
    {
    }

    AttributeQueryType::
    AttributeQueryType (const ID_type& ID,
                        const Version_type& Version,
                        const IssueInstant_type& IssueInstant,
                        const Subject_type& Subject)
    : ::saml2::protocol::SubjectQueryAbstractType (ID,
                                                   Version,
                                                   IssueInstant,
                                                   Subject),
      Attribute_ (::xml_schema::flags (), this)
    {
    }

    AttributeQueryType::
    AttributeQueryType (const AttributeQueryType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::saml2::protocol::SubjectQueryAbstractType (x, f, c),
      Attribute_ (x.Attribute_, f, this)
    {
    }

    AttributeQueryType::
    AttributeQueryType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::saml2::protocol::SubjectQueryAbstractType (e, f | ::xml_schema::flags::base, c),
      Attribute_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AttributeQueryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::SubjectQueryAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Attribute_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Attribute_type > r (
              dynamic_cast< Attribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Attribute ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AttributeQueryType* AttributeQueryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AttributeQueryType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeQueryType >
    _xsd_AttributeQueryType_type_factory_init (
      L"AttributeQueryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // AuthzDecisionQueryType
    //

    AuthzDecisionQueryType::
    AuthzDecisionQueryType ()
    : ::saml2::protocol::SubjectQueryAbstractType (),
      Action_ (::xml_schema::flags (), this),
      Evidence_ (::xml_schema::flags (), this),
      Resource_ (::xml_schema::flags (), this)
    {
    }

    AuthzDecisionQueryType::
    AuthzDecisionQueryType (const ID_type& ID,
                            const Version_type& Version,
                            const IssueInstant_type& IssueInstant,
                            const Subject_type& Subject,
                            const Resource_type& Resource)
    : ::saml2::protocol::SubjectQueryAbstractType (ID,
                                                   Version,
                                                   IssueInstant,
                                                   Subject),
      Action_ (::xml_schema::flags (), this),
      Evidence_ (::xml_schema::flags (), this),
      Resource_ (Resource, ::xml_schema::flags (), this)
    {
    }

    AuthzDecisionQueryType::
    AuthzDecisionQueryType (const AuthzDecisionQueryType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::protocol::SubjectQueryAbstractType (x, f, c),
      Action_ (x.Action_, f, this),
      Evidence_ (x.Evidence_, f, this),
      Resource_ (x.Resource_, f, this)
    {
    }

    AuthzDecisionQueryType::
    AuthzDecisionQueryType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::protocol::SubjectQueryAbstractType (e, f | ::xml_schema::flags::base, c),
      Action_ (f, this),
      Evidence_ (f, this),
      Resource_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AuthzDecisionQueryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::SubjectQueryAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Action
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Action",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Action_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Action_type > r (
              dynamic_cast< Action_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Action ().push_back (r);
            continue;
          }
        }

        // Evidence
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Evidence",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Evidence_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Evidence ())
            {
              ::std::auto_ptr< Evidence_type > r (
                dynamic_cast< Evidence_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Evidence (r);
              continue;
            }
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Resource" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Resource_type > r (
            Resource_traits::create (i, f, this));

          this->Resource (r);
          continue;
        }
      }

      if (!Resource_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Resource",
          L"");
      }
    }

    AuthzDecisionQueryType* AuthzDecisionQueryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthzDecisionQueryType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthzDecisionQueryType >
    _xsd_AuthzDecisionQueryType_type_factory_init (
      L"AuthzDecisionQueryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // AuthnRequestType
    //

    AuthnRequestType::
    AuthnRequestType ()
    : ::saml2::protocol::RequestAbstractType (),
      Subject_ (::xml_schema::flags (), this),
      NameIDPolicy_ (::xml_schema::flags (), this),
      Conditions_ (::xml_schema::flags (), this),
      RequestedAuthnContext_ (::xml_schema::flags (), this),
      Scoping_ (::xml_schema::flags (), this),
      ForceAuthn_ (::xml_schema::flags (), this),
      IsPassive_ (::xml_schema::flags (), this),
      ProtocolBinding_ (::xml_schema::flags (), this),
      AssertionConsumerServiceIndex_ (::xml_schema::flags (), this),
      AssertionConsumerServiceURL_ (::xml_schema::flags (), this),
      AttributeConsumingServiceIndex_ (::xml_schema::flags (), this),
      ProviderName_ (::xml_schema::flags (), this)
    {
    }

    AuthnRequestType::
    AuthnRequestType (const ID_type& ID,
                      const Version_type& Version,
                      const IssueInstant_type& IssueInstant)
    : ::saml2::protocol::RequestAbstractType (ID,
                                              Version,
                                              IssueInstant),
      Subject_ (::xml_schema::flags (), this),
      NameIDPolicy_ (::xml_schema::flags (), this),
      Conditions_ (::xml_schema::flags (), this),
      RequestedAuthnContext_ (::xml_schema::flags (), this),
      Scoping_ (::xml_schema::flags (), this),
      ForceAuthn_ (::xml_schema::flags (), this),
      IsPassive_ (::xml_schema::flags (), this),
      ProtocolBinding_ (::xml_schema::flags (), this),
      AssertionConsumerServiceIndex_ (::xml_schema::flags (), this),
      AssertionConsumerServiceURL_ (::xml_schema::flags (), this),
      AttributeConsumingServiceIndex_ (::xml_schema::flags (), this),
      ProviderName_ (::xml_schema::flags (), this)
    {
    }

    AuthnRequestType::
    AuthnRequestType (const AuthnRequestType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (x, f, c),
      Subject_ (x.Subject_, f, this),
      NameIDPolicy_ (x.NameIDPolicy_, f, this),
      Conditions_ (x.Conditions_, f, this),
      RequestedAuthnContext_ (x.RequestedAuthnContext_, f, this),
      Scoping_ (x.Scoping_, f, this),
      ForceAuthn_ (x.ForceAuthn_, f, this),
      IsPassive_ (x.IsPassive_, f, this),
      ProtocolBinding_ (x.ProtocolBinding_, f, this),
      AssertionConsumerServiceIndex_ (x.AssertionConsumerServiceIndex_, f, this),
      AssertionConsumerServiceURL_ (x.AssertionConsumerServiceURL_, f, this),
      AttributeConsumingServiceIndex_ (x.AttributeConsumingServiceIndex_, f, this),
      ProviderName_ (x.ProviderName_, f, this)
    {
    }

    AuthnRequestType::
    AuthnRequestType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (e, f | ::xml_schema::flags::base, c),
      Subject_ (f, this),
      NameIDPolicy_ (f, this),
      Conditions_ (f, this),
      RequestedAuthnContext_ (f, this),
      Scoping_ (f, this),
      ForceAuthn_ (f, this),
      IsPassive_ (f, this),
      ProtocolBinding_ (f, this),
      AssertionConsumerServiceIndex_ (f, this),
      AssertionConsumerServiceURL_ (f, this),
      AttributeConsumingServiceIndex_ (f, this),
      ProviderName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AuthnRequestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::RequestAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Subject
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Subject",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Subject_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Subject ())
            {
              ::std::auto_ptr< Subject_type > r (
                dynamic_cast< Subject_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Subject (r);
              continue;
            }
          }
        }

        // NameIDPolicy
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameIDPolicy",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< NameIDPolicy_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NameIDPolicy ())
            {
              ::std::auto_ptr< NameIDPolicy_type > r (
                dynamic_cast< NameIDPolicy_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameIDPolicy (r);
              continue;
            }
          }
        }

        // Conditions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Conditions",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Conditions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Conditions ())
            {
              ::std::auto_ptr< Conditions_type > r (
                dynamic_cast< Conditions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Conditions (r);
              continue;
            }
          }
        }

        // RequestedAuthnContext
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"RequestedAuthnContext",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< RequestedAuthnContext_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->RequestedAuthnContext ())
            {
              ::std::auto_ptr< RequestedAuthnContext_type > r (
                dynamic_cast< RequestedAuthnContext_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->RequestedAuthnContext (r);
              continue;
            }
          }
        }

        // Scoping
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Scoping",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< Scoping_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Scoping ())
            {
              ::std::auto_ptr< Scoping_type > r (
                dynamic_cast< Scoping_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Scoping (r);
              continue;
            }
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"ForceAuthn" && n.namespace_ ().empty ())
        {
          this->ForceAuthn (ForceAuthn_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"IsPassive" && n.namespace_ ().empty ())
        {
          this->IsPassive (IsPassive_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ProtocolBinding" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ProtocolBinding_type > r (
            ProtocolBinding_traits::create (i, f, this));

          this->ProtocolBinding (r);
          continue;
        }

        if (n.name () == L"AssertionConsumerServiceIndex" && n.namespace_ ().empty ())
        {
          this->AssertionConsumerServiceIndex (AssertionConsumerServiceIndex_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"AssertionConsumerServiceURL" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AssertionConsumerServiceURL_type > r (
            AssertionConsumerServiceURL_traits::create (i, f, this));

          this->AssertionConsumerServiceURL (r);
          continue;
        }

        if (n.name () == L"AttributeConsumingServiceIndex" && n.namespace_ ().empty ())
        {
          this->AttributeConsumingServiceIndex (AttributeConsumingServiceIndex_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"ProviderName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ProviderName_type > r (
            ProviderName_traits::create (i, f, this));

          this->ProviderName (r);
          continue;
        }
      }
    }

    AuthnRequestType* AuthnRequestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnRequestType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnRequestType >
    _xsd_AuthnRequestType_type_factory_init (
      L"AuthnRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // NameIDPolicyType
    //

    NameIDPolicyType::
    NameIDPolicyType ()
    : ::xml_schema::type (),
      Format_ (::xml_schema::flags (), this),
      SPNameQualifier_ (::xml_schema::flags (), this),
      AllowCreate_ (::xml_schema::flags (), this)
    {
    }

    NameIDPolicyType::
    NameIDPolicyType (const NameIDPolicyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      Format_ (x.Format_, f, this),
      SPNameQualifier_ (x.SPNameQualifier_, f, this),
      AllowCreate_ (x.AllowCreate_, f, this)
    {
    }

    NameIDPolicyType::
    NameIDPolicyType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Format_ (f, this),
      SPNameQualifier_ (f, this),
      AllowCreate_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void NameIDPolicyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Format" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Format_type > r (
            Format_traits::create (i, f, this));

          this->Format (r);
          continue;
        }

        if (n.name () == L"SPNameQualifier" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SPNameQualifier_type > r (
            SPNameQualifier_traits::create (i, f, this));

          this->SPNameQualifier (r);
          continue;
        }

        if (n.name () == L"AllowCreate" && n.namespace_ ().empty ())
        {
          this->AllowCreate (AllowCreate_traits::create (i, f, this));
          continue;
        }
      }
    }

    NameIDPolicyType* NameIDPolicyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new NameIDPolicyType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NameIDPolicyType >
    _xsd_NameIDPolicyType_type_factory_init (
      L"NameIDPolicyType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // ScopingType
    //

    ScopingType::
    ScopingType ()
    : ::xml_schema::type (),
      IDPList_ (::xml_schema::flags (), this),
      RequesterID_ (::xml_schema::flags (), this),
      ProxyCount_ (::xml_schema::flags (), this)
    {
    }

    ScopingType::
    ScopingType (const ScopingType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      IDPList_ (x.IDPList_, f, this),
      RequesterID_ (x.RequesterID_, f, this),
      ProxyCount_ (x.ProxyCount_, f, this)
    {
    }

    ScopingType::
    ScopingType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IDPList_ (f, this),
      RequesterID_ (f, this),
      ProxyCount_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ScopingType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IDPList
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"IDPList",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< IDPList_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->IDPList ())
            {
              ::std::auto_ptr< IDPList_type > r (
                dynamic_cast< IDPList_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->IDPList (r);
              continue;
            }
          }
        }

        // RequesterID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"RequesterID",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< RequesterID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< RequesterID_type > r (
              dynamic_cast< RequesterID_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->RequesterID ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"ProxyCount" && n.namespace_ ().empty ())
        {
          this->ProxyCount (ProxyCount_traits::create (i, f, this));
          continue;
        }
      }
    }

    ScopingType* ScopingType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ScopingType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ScopingType >
    _xsd_ScopingType_type_factory_init (
      L"ScopingType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // IDPListType
    //

    IDPListType::
    IDPListType ()
    : ::xml_schema::type (),
      IDPEntry_ (::xml_schema::flags (), this),
      GetComplete_ (::xml_schema::flags (), this)
    {
    }

    IDPListType::
    IDPListType (const IDPListType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      IDPEntry_ (x.IDPEntry_, f, this),
      GetComplete_ (x.GetComplete_, f, this)
    {
    }

    IDPListType::
    IDPListType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IDPEntry_ (f, this),
      GetComplete_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void IDPListType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // IDPEntry
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"IDPEntry",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< IDPEntry_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< IDPEntry_type > r (
              dynamic_cast< IDPEntry_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->IDPEntry ().push_back (r);
            continue;
          }
        }

        // GetComplete
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"GetComplete",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< GetComplete_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->GetComplete ())
            {
              ::std::auto_ptr< GetComplete_type > r (
                dynamic_cast< GetComplete_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->GetComplete (r);
              continue;
            }
          }
        }

        break;
      }
    }

    IDPListType* IDPListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new IDPListType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IDPListType >
    _xsd_IDPListType_type_factory_init (
      L"IDPListType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // IDPEntryType
    //

    IDPEntryType::
    IDPEntryType ()
    : ::xml_schema::type (),
      ProviderID_ (::xml_schema::flags (), this),
      Name_ (::xml_schema::flags (), this),
      Loc_ (::xml_schema::flags (), this)
    {
    }

    IDPEntryType::
    IDPEntryType (const ProviderID_type& ProviderID)
    : ::xml_schema::type (),
      ProviderID_ (ProviderID, ::xml_schema::flags (), this),
      Name_ (::xml_schema::flags (), this),
      Loc_ (::xml_schema::flags (), this)
    {
    }

    IDPEntryType::
    IDPEntryType (const IDPEntryType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      ProviderID_ (x.ProviderID_, f, this),
      Name_ (x.Name_, f, this),
      Loc_ (x.Loc_, f, this)
    {
    }

    IDPEntryType::
    IDPEntryType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ProviderID_ (f, this),
      Name_ (f, this),
      Loc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void IDPEntryType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"ProviderID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ProviderID_type > r (
            ProviderID_traits::create (i, f, this));

          this->ProviderID (r);
          continue;
        }

        if (n.name () == L"Name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          this->Name (r);
          continue;
        }

        if (n.name () == L"Loc" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Loc_type > r (
            Loc_traits::create (i, f, this));

          this->Loc (r);
          continue;
        }
      }

      if (!ProviderID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"ProviderID",
          L"");
      }
    }

    IDPEntryType* IDPEntryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new IDPEntryType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IDPEntryType >
    _xsd_IDPEntryType_type_factory_init (
      L"IDPEntryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // ResponseType
    //

    ResponseType::
    ResponseType ()
    : ::saml2::protocol::StatusResponseType (),
      Assertion_ (::xml_schema::flags (), this),
      EncryptedAssertion_ (::xml_schema::flags (), this)
    {
    }

    ResponseType::
    ResponseType (const Status_type& Status,
                  const ID_type& ID,
                  const Version_type& Version,
                  const IssueInstant_type& IssueInstant)
    : ::saml2::protocol::StatusResponseType (Status,
                                             ID,
                                             Version,
                                             IssueInstant),
      Assertion_ (::xml_schema::flags (), this),
      EncryptedAssertion_ (::xml_schema::flags (), this)
    {
    }

    ResponseType::
    ResponseType (const ResponseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::saml2::protocol::StatusResponseType (x, f, c),
      Assertion_ (x.Assertion_, f, this),
      EncryptedAssertion_ (x.EncryptedAssertion_, f, this)
    {
    }

    ResponseType::
    ResponseType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::saml2::protocol::StatusResponseType (e, f | ::xml_schema::flags::base, c),
      Assertion_ (f, this),
      EncryptedAssertion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ResponseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::StatusResponseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Assertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Assertion_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Assertion_type > r (
              dynamic_cast< Assertion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Assertion ().push_back (r);
            continue;
          }
        }

        // EncryptedAssertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedAssertion_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EncryptedAssertion_type > r (
              dynamic_cast< EncryptedAssertion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EncryptedAssertion ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    ResponseType* ResponseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ResponseType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ResponseType >
    _xsd_ResponseType_type_factory_init (
      L"ResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // ArtifactResolveType
    //

    ArtifactResolveType::
    ArtifactResolveType ()
    : ::saml2::protocol::RequestAbstractType (),
      Artifact_ (::xml_schema::flags (), this)
    {
    }

    ArtifactResolveType::
    ArtifactResolveType (const ID_type& ID,
                         const Version_type& Version,
                         const IssueInstant_type& IssueInstant,
                         const Artifact_type& Artifact)
    : ::saml2::protocol::RequestAbstractType (ID,
                                              Version,
                                              IssueInstant),
      Artifact_ (Artifact, ::xml_schema::flags (), this)
    {
    }

    ArtifactResolveType::
    ArtifactResolveType (const ArtifactResolveType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (x, f, c),
      Artifact_ (x.Artifact_, f, this)
    {
    }

    ArtifactResolveType::
    ArtifactResolveType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (e, f | ::xml_schema::flags::base, c),
      Artifact_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ArtifactResolveType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::RequestAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Artifact
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Artifact",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< Artifact_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Artifact_.present ())
            {
              ::std::auto_ptr< Artifact_type > r (
                dynamic_cast< Artifact_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Artifact (r);
              continue;
            }
          }
        }

        break;
      }

      if (!Artifact_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Artifact",
          L"urn:oasis:names:tc:SAML:2.0:protocol");
      }
    }

    ArtifactResolveType* ArtifactResolveType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ArtifactResolveType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArtifactResolveType >
    _xsd_ArtifactResolveType_type_factory_init (
      L"ArtifactResolveType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // ArtifactResponseType
    //

    ArtifactResponseType::
    ArtifactResponseType ()
    : ::saml2::protocol::StatusResponseType (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
    }

    ArtifactResponseType::
    ArtifactResponseType (const Status_type& Status,
                          const ID_type& ID,
                          const Version_type& Version,
                          const IssueInstant_type& IssueInstant)
    : ::saml2::protocol::StatusResponseType (Status,
                                             ID,
                                             Version,
                                             IssueInstant),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
    }

    ArtifactResponseType::
    ArtifactResponseType (const ArtifactResponseType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::protocol::StatusResponseType (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ())
    {
    }

    ArtifactResponseType::
    ArtifactResponseType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::protocol::StatusResponseType (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ArtifactResponseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::StatusResponseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          if (!this->any ())
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->dom_document ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any (r);
            continue;
          }
        }

        break;
      }
    }

    ArtifactResponseType* ArtifactResponseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ArtifactResponseType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ArtifactResponseType >
    _xsd_ArtifactResponseType_type_factory_init (
      L"ArtifactResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // ManageNameIDRequestType
    //

    ManageNameIDRequestType::
    ManageNameIDRequestType ()
    : ::saml2::protocol::RequestAbstractType (),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      NewID_ (::xml_schema::flags (), this),
      NewEncryptedID_ (::xml_schema::flags (), this),
      Terminate_ (::xml_schema::flags (), this)
    {
    }

    ManageNameIDRequestType::
    ManageNameIDRequestType (const ID_type& ID,
                             const Version_type& Version,
                             const IssueInstant_type& IssueInstant)
    : ::saml2::protocol::RequestAbstractType (ID,
                                              Version,
                                              IssueInstant),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      NewID_ (::xml_schema::flags (), this),
      NewEncryptedID_ (::xml_schema::flags (), this),
      Terminate_ (::xml_schema::flags (), this)
    {
    }

    ManageNameIDRequestType::
    ManageNameIDRequestType (const ManageNameIDRequestType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (x, f, c),
      NameID_ (x.NameID_, f, this),
      EncryptedID_ (x.EncryptedID_, f, this),
      NewID_ (x.NewID_, f, this),
      NewEncryptedID_ (x.NewEncryptedID_, f, this),
      Terminate_ (x.Terminate_, f, this)
    {
    }

    ManageNameIDRequestType::
    ManageNameIDRequestType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (e, f | ::xml_schema::flags::base, c),
      NameID_ (f, this),
      EncryptedID_ (f, this),
      NewID_ (f, this),
      NewEncryptedID_ (f, this),
      Terminate_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ManageNameIDRequestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::RequestAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< NameID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NameID ())
            {
              ::std::auto_ptr< NameID_type > r (
                dynamic_cast< NameID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameID (r);
              continue;
            }
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptedID ())
            {
              ::std::auto_ptr< EncryptedID_type > r (
                dynamic_cast< EncryptedID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptedID (r);
              continue;
            }
          }
        }

        // NewID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NewID",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< NewID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NewID ())
            {
              ::std::auto_ptr< NewID_type > r (
                dynamic_cast< NewID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NewID (r);
              continue;
            }
          }
        }

        // NewEncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NewEncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< NewEncryptedID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NewEncryptedID ())
            {
              ::std::auto_ptr< NewEncryptedID_type > r (
                dynamic_cast< NewEncryptedID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NewEncryptedID (r);
              continue;
            }
          }
        }

        // Terminate
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Terminate",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< Terminate_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Terminate ())
            {
              ::std::auto_ptr< Terminate_type > r (
                dynamic_cast< Terminate_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Terminate (r);
              continue;
            }
          }
        }

        break;
      }
    }

    ManageNameIDRequestType* ManageNameIDRequestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ManageNameIDRequestType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ManageNameIDRequestType >
    _xsd_ManageNameIDRequestType_type_factory_init (
      L"ManageNameIDRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // TerminateType
    //

    TerminateType::
    TerminateType ()
    : ::xml_schema::type ()
    {
    }

    TerminateType::
    TerminateType (const TerminateType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    TerminateType::
    TerminateType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    TerminateType::
    TerminateType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    TerminateType::
    TerminateType (const ::std::wstring& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    TerminateType* TerminateType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new TerminateType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TerminateType >
    _xsd_TerminateType_type_factory_init (
      L"TerminateType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // LogoutRequestType
    //

    LogoutRequestType::
    LogoutRequestType ()
    : ::saml2::protocol::RequestAbstractType (),
      BaseID_ (::xml_schema::flags (), this),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      SessionIndex_ (::xml_schema::flags (), this),
      Reason_ (::xml_schema::flags (), this),
      NotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    LogoutRequestType::
    LogoutRequestType (const ID_type& ID,
                       const Version_type& Version,
                       const IssueInstant_type& IssueInstant)
    : ::saml2::protocol::RequestAbstractType (ID,
                                              Version,
                                              IssueInstant),
      BaseID_ (::xml_schema::flags (), this),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      SessionIndex_ (::xml_schema::flags (), this),
      Reason_ (::xml_schema::flags (), this),
      NotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    LogoutRequestType::
    LogoutRequestType (const LogoutRequestType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (x, f, c),
      BaseID_ (x.BaseID_, f, this),
      NameID_ (x.NameID_, f, this),
      EncryptedID_ (x.EncryptedID_, f, this),
      SessionIndex_ (x.SessionIndex_, f, this),
      Reason_ (x.Reason_, f, this),
      NotOnOrAfter_ (x.NotOnOrAfter_, f, this)
    {
    }

    LogoutRequestType::
    LogoutRequestType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (e, f | ::xml_schema::flags::base, c),
      BaseID_ (f, this),
      NameID_ (f, this),
      EncryptedID_ (f, this),
      SessionIndex_ (f, this),
      Reason_ (f, this),
      NotOnOrAfter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void LogoutRequestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::RequestAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< BaseID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->BaseID ())
            {
              ::std::auto_ptr< BaseID_type > r (
                dynamic_cast< BaseID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BaseID (r);
              continue;
            }
          }
        }

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< NameID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NameID ())
            {
              ::std::auto_ptr< NameID_type > r (
                dynamic_cast< NameID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameID (r);
              continue;
            }
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptedID ())
            {
              ::std::auto_ptr< EncryptedID_type > r (
                dynamic_cast< EncryptedID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptedID (r);
              continue;
            }
          }
        }

        // SessionIndex
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SessionIndex",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< SessionIndex_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< SessionIndex_type > r (
              dynamic_cast< SessionIndex_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->SessionIndex ().push_back (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Reason" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Reason_type > r (
            Reason_traits::create (i, f, this));

          this->Reason (r);
          continue;
        }

        if (n.name () == L"NotOnOrAfter" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotOnOrAfter_type > r (
            NotOnOrAfter_traits::create (i, f, this));

          this->NotOnOrAfter (r);
          continue;
        }
      }
    }

    LogoutRequestType* LogoutRequestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new LogoutRequestType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, LogoutRequestType >
    _xsd_LogoutRequestType_type_factory_init (
      L"LogoutRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // NameIDMappingRequestType
    //

    NameIDMappingRequestType::
    NameIDMappingRequestType ()
    : ::saml2::protocol::RequestAbstractType (),
      BaseID_ (::xml_schema::flags (), this),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      NameIDPolicy_ (::xml_schema::flags (), this)
    {
    }

    NameIDMappingRequestType::
    NameIDMappingRequestType (const ID_type& ID,
                              const Version_type& Version,
                              const IssueInstant_type& IssueInstant,
                              const NameIDPolicy_type& NameIDPolicy)
    : ::saml2::protocol::RequestAbstractType (ID,
                                              Version,
                                              IssueInstant),
      BaseID_ (::xml_schema::flags (), this),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      NameIDPolicy_ (NameIDPolicy, ::xml_schema::flags (), this)
    {
    }

    NameIDMappingRequestType::
    NameIDMappingRequestType (const NameIDMappingRequestType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (x, f, c),
      BaseID_ (x.BaseID_, f, this),
      NameID_ (x.NameID_, f, this),
      EncryptedID_ (x.EncryptedID_, f, this),
      NameIDPolicy_ (x.NameIDPolicy_, f, this)
    {
    }

    NameIDMappingRequestType::
    NameIDMappingRequestType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::type* c)
    : ::saml2::protocol::RequestAbstractType (e, f | ::xml_schema::flags::base, c),
      BaseID_ (f, this),
      NameID_ (f, this),
      EncryptedID_ (f, this),
      NameIDPolicy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void NameIDMappingRequestType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::RequestAbstractType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< BaseID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->BaseID ())
            {
              ::std::auto_ptr< BaseID_type > r (
                dynamic_cast< BaseID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BaseID (r);
              continue;
            }
          }
        }

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< NameID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NameID ())
            {
              ::std::auto_ptr< NameID_type > r (
                dynamic_cast< NameID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameID (r);
              continue;
            }
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptedID ())
            {
              ::std::auto_ptr< EncryptedID_type > r (
                dynamic_cast< EncryptedID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptedID (r);
              continue;
            }
          }
        }

        // NameIDPolicy
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameIDPolicy",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              &::xsd::cxx::tree::factory_impl< NameIDPolicy_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!NameIDPolicy_.present ())
            {
              ::std::auto_ptr< NameIDPolicy_type > r (
                dynamic_cast< NameIDPolicy_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameIDPolicy (r);
              continue;
            }
          }
        }

        break;
      }

      if (!NameIDPolicy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"NameIDPolicy",
          L"urn:oasis:names:tc:SAML:2.0:protocol");
      }
    }

    NameIDMappingRequestType* NameIDMappingRequestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new NameIDMappingRequestType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NameIDMappingRequestType >
    _xsd_NameIDMappingRequestType_type_factory_init (
      L"NameIDMappingRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    // NameIDMappingResponseType
    //

    NameIDMappingResponseType::
    NameIDMappingResponseType ()
    : ::saml2::protocol::StatusResponseType (),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this)
    {
    }

    NameIDMappingResponseType::
    NameIDMappingResponseType (const Status_type& Status,
                               const ID_type& ID,
                               const Version_type& Version,
                               const IssueInstant_type& IssueInstant)
    : ::saml2::protocol::StatusResponseType (Status,
                                             ID,
                                             Version,
                                             IssueInstant),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this)
    {
    }

    NameIDMappingResponseType::
    NameIDMappingResponseType (const NameIDMappingResponseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
    : ::saml2::protocol::StatusResponseType (x, f, c),
      NameID_ (x.NameID_, f, this),
      EncryptedID_ (x.EncryptedID_, f, this)
    {
    }

    NameIDMappingResponseType::
    NameIDMappingResponseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
    : ::saml2::protocol::StatusResponseType (e, f | ::xml_schema::flags::base, c),
      NameID_ (f, this),
      EncryptedID_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void NameIDMappingResponseType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::protocol::StatusResponseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< NameID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NameID ())
            {
              ::std::auto_ptr< NameID_type > r (
                dynamic_cast< NameID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameID (r);
              continue;
            }
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptedID ())
            {
              ::std::auto_ptr< EncryptedID_type > r (
                dynamic_cast< EncryptedID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptedID (r);
              continue;
            }
          }
        }

        break;
      }
    }

    NameIDMappingResponseType* NameIDMappingResponseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new NameIDMappingResponseType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NameIDMappingResponseType >
    _xsd_NameIDMappingResponseType_type_factory_init (
      L"NameIDMappingResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace saml2
{
  namespace protocol
  {
    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (const ::std::wstring& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
        ::saml2::protocol::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (const ::std::wstring& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
        ::saml2::protocol::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (const ::std::wstring& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
        ::saml2::protocol::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Extensions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Extensions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (::std::istream& is,
                const ::std::wstring& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
        ::saml2::protocol::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (const ::xercesc::DOMInputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
        ::saml2::protocol::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
        ::saml2::protocol::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
          ::saml2::protocol::Extensions (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Extensions",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ExtensionsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
          dynamic_cast< ::saml2::protocol::ExtensionsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Extensions",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ExtensionsType >
    Extensions (::xercesc::DOMDocument* d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Extensions",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ExtensionsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::ExtensionsType > r (
          dynamic_cast< ::saml2::protocol::ExtensionsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Extensions",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusType > r (
        ::saml2::protocol::Status (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusType > r (
        ::saml2::protocol::Status (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusType > r (
        ::saml2::protocol::Status (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Status (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Status (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Status (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Status (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Status (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Status (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusType > r (
        ::saml2::protocol::Status (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (const ::xercesc::DOMInputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusType > r (
        ::saml2::protocol::Status (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusType > r (
        ::saml2::protocol::Status (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::StatusType > r (
          ::saml2::protocol::Status (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Status",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::StatusType > r (
          dynamic_cast< ::saml2::protocol::StatusType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Status",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusType >
    Status (::xercesc::DOMDocument* d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Status",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::StatusType > r (
          dynamic_cast< ::saml2::protocol::StatusType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Status",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (const ::std::wstring& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
        ::saml2::protocol::StatusCode (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (const ::std::wstring& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
        ::saml2::protocol::StatusCode (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (const ::std::wstring& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
        ::saml2::protocol::StatusCode (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusCode (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusCode (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusCode (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusCode (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusCode (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (::std::istream& is,
                const ::std::wstring& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusCode (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
        ::saml2::protocol::StatusCode (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (const ::xercesc::DOMInputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
        ::saml2::protocol::StatusCode (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
        ::saml2::protocol::StatusCode (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
          ::saml2::protocol::StatusCode (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"StatusCode",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusCodeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
          dynamic_cast< ::saml2::protocol::StatusCodeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"StatusCode",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusCodeType >
    StatusCode (::xercesc::DOMDocument* d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"StatusCode",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusCodeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::StatusCodeType > r (
          dynamic_cast< ::saml2::protocol::StatusCodeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"StatusCode",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (const ::std::wstring& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::StatusMessage (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (const ::std::wstring& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::StatusMessage (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (const ::std::wstring& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::StatusMessage (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusMessage (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusMessage (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusMessage (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusMessage (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusMessage (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusMessage (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::StatusMessage (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::StatusMessage (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (const ::xercesc::DOMInputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::StatusMessage (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::protocol::StatusMessage (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"StatusMessage",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"StatusMessage",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    StatusMessage (::xercesc::DOMDocument* d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"StatusMessage",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"StatusMessage",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
        ::saml2::protocol::StatusDetail (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
        ::saml2::protocol::StatusDetail (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
        ::saml2::protocol::StatusDetail (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusDetail (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusDetail (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusDetail (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusDetail (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusDetail (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::StatusDetail (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
        ::saml2::protocol::StatusDetail (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
        ::saml2::protocol::StatusDetail (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
        ::saml2::protocol::StatusDetail (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
          ::saml2::protocol::StatusDetail (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"StatusDetail",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusDetailType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
          dynamic_cast< ::saml2::protocol::StatusDetailType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"StatusDetail",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusDetailType >
    StatusDetail (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"StatusDetail",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusDetailType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::StatusDetailType > r (
          dynamic_cast< ::saml2::protocol::StatusDetailType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"StatusDetail",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
        ::saml2::protocol::AssertionIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
        ::saml2::protocol::AssertionIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
        ::saml2::protocol::AssertionIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AssertionIDRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AssertionIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AssertionIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AssertionIDRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AssertionIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AssertionIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
        ::saml2::protocol::AssertionIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
        ::saml2::protocol::AssertionIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
        ::saml2::protocol::AssertionIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
          ::saml2::protocol::AssertionIDRequest (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionIDRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AssertionIDRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
          dynamic_cast< ::saml2::protocol::AssertionIDRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionIDRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType >
    AssertionIDRequest (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionIDRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AssertionIDRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::AssertionIDRequestType > r (
          dynamic_cast< ::saml2::protocol::AssertionIDRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionIDRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
        ::saml2::protocol::SubjectQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
        ::saml2::protocol::SubjectQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
        ::saml2::protocol::SubjectQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SubjectQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SubjectQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SubjectQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SubjectQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SubjectQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SubjectQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
        ::saml2::protocol::SubjectQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
        ::saml2::protocol::SubjectQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
        ::saml2::protocol::SubjectQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
          ::saml2::protocol::SubjectQuery (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::SubjectQueryAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
          dynamic_cast< ::saml2::protocol::SubjectQueryAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType >
    SubjectQuery (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::SubjectQueryAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::SubjectQueryAbstractType > r (
          dynamic_cast< ::saml2::protocol::SubjectQueryAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (const ::std::wstring& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
        ::saml2::protocol::AuthnQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (const ::std::wstring& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
        ::saml2::protocol::AuthnQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (const ::std::wstring& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
        ::saml2::protocol::AuthnQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (::std::istream& is,
                const ::std::wstring& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
        ::saml2::protocol::AuthnQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (const ::xercesc::DOMInputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
        ::saml2::protocol::AuthnQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
        ::saml2::protocol::AuthnQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
          ::saml2::protocol::AuthnQuery (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AuthnQueryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
          dynamic_cast< ::saml2::protocol::AuthnQueryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnQueryType >
    AuthnQuery (::xercesc::DOMDocument* d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AuthnQueryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::AuthnQueryType > r (
          dynamic_cast< ::saml2::protocol::AuthnQueryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (const ::std::wstring& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
        ::saml2::protocol::RequestedAuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (const ::std::wstring& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
        ::saml2::protocol::RequestedAuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (const ::std::wstring& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
        ::saml2::protocol::RequestedAuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequestedAuthnContext (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequestedAuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequestedAuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequestedAuthnContext (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequestedAuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequestedAuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (const ::xercesc::DOMInputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
        ::saml2::protocol::RequestedAuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (const ::xercesc::DOMInputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
        ::saml2::protocol::RequestedAuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (const ::xercesc::DOMInputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
        ::saml2::protocol::RequestedAuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
          ::saml2::protocol::RequestedAuthnContext (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RequestedAuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::RequestedAuthnContextType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
          dynamic_cast< ::saml2::protocol::RequestedAuthnContextType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RequestedAuthnContext",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType >
    RequestedAuthnContext (::xercesc::DOMDocument* d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RequestedAuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::RequestedAuthnContextType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::RequestedAuthnContextType > r (
          dynamic_cast< ::saml2::protocol::RequestedAuthnContextType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RequestedAuthnContext",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
        ::saml2::protocol::AttributeQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
        ::saml2::protocol::AttributeQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
        ::saml2::protocol::AttributeQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AttributeQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AttributeQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AttributeQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AttributeQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AttributeQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AttributeQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
        ::saml2::protocol::AttributeQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
        ::saml2::protocol::AttributeQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
        ::saml2::protocol::AttributeQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
          ::saml2::protocol::AttributeQuery (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AttributeQueryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
          dynamic_cast< ::saml2::protocol::AttributeQueryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AttributeQueryType >
    AttributeQuery (::xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AttributeQueryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::AttributeQueryType > r (
          dynamic_cast< ::saml2::protocol::AttributeQueryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
        ::saml2::protocol::AuthzDecisionQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
        ::saml2::protocol::AuthzDecisionQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
        ::saml2::protocol::AuthzDecisionQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthzDecisionQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthzDecisionQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthzDecisionQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthzDecisionQuery (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthzDecisionQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthzDecisionQuery (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
        ::saml2::protocol::AuthzDecisionQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
        ::saml2::protocol::AuthzDecisionQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
        ::saml2::protocol::AuthzDecisionQuery (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
          ::saml2::protocol::AuthzDecisionQuery (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthzDecisionQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AuthzDecisionQueryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
          dynamic_cast< ::saml2::protocol::AuthzDecisionQueryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthzDecisionQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType >
    AuthzDecisionQuery (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthzDecisionQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AuthzDecisionQueryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::AuthzDecisionQueryType > r (
          dynamic_cast< ::saml2::protocol::AuthzDecisionQueryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthzDecisionQuery",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
        ::saml2::protocol::AuthnRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
        ::saml2::protocol::AuthnRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
        ::saml2::protocol::AuthnRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::AuthnRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
        ::saml2::protocol::AuthnRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
        ::saml2::protocol::AuthnRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
        ::saml2::protocol::AuthnRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
          ::saml2::protocol::AuthnRequest (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AuthnRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
          dynamic_cast< ::saml2::protocol::AuthnRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::AuthnRequestType >
    AuthnRequest (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::AuthnRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::AuthnRequestType > r (
          dynamic_cast< ::saml2::protocol::AuthnRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
        ::saml2::protocol::NameIDPolicy (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
        ::saml2::protocol::NameIDPolicy (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
        ::saml2::protocol::NameIDPolicy (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDPolicy (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDPolicy (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDPolicy (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDPolicy (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDPolicy (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDPolicy (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
        ::saml2::protocol::NameIDPolicy (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
        ::saml2::protocol::NameIDPolicy (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
        ::saml2::protocol::NameIDPolicy (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
          ::saml2::protocol::NameIDPolicy (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDPolicy",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::NameIDPolicyType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
          dynamic_cast< ::saml2::protocol::NameIDPolicyType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDPolicy",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType >
    NameIDPolicy (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDPolicy",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::NameIDPolicyType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::NameIDPolicyType > r (
          dynamic_cast< ::saml2::protocol::NameIDPolicyType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDPolicy",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
        ::saml2::protocol::Scoping (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
        ::saml2::protocol::Scoping (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
        ::saml2::protocol::Scoping (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Scoping (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Scoping (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Scoping (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Scoping (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Scoping (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Scoping (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
        ::saml2::protocol::Scoping (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (const ::xercesc::DOMInputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
        ::saml2::protocol::Scoping (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
        ::saml2::protocol::Scoping (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
          ::saml2::protocol::Scoping (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Scoping",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ScopingType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
          dynamic_cast< ::saml2::protocol::ScopingType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Scoping",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ScopingType >
    Scoping (::xercesc::DOMDocument* d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Scoping",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ScopingType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::ScopingType > r (
          dynamic_cast< ::saml2::protocol::ScopingType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Scoping",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (const ::std::wstring& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::RequesterID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (const ::std::wstring& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::RequesterID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (const ::std::wstring& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::RequesterID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequesterID (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequesterID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequesterID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequesterID (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequesterID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::RequesterID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::RequesterID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::RequesterID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (const ::xercesc::DOMInputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::RequesterID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::protocol::RequesterID (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RequesterID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RequesterID",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    RequesterID (::xercesc::DOMDocument* d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RequesterID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RequesterID",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
        ::saml2::protocol::IDPList (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
        ::saml2::protocol::IDPList (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
        ::saml2::protocol::IDPList (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPList (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPList (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPList (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPList (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPList (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPList (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
        ::saml2::protocol::IDPList (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (const ::xercesc::DOMInputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
        ::saml2::protocol::IDPList (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
        ::saml2::protocol::IDPList (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
          ::saml2::protocol::IDPList (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"IDPList",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::IDPListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
          dynamic_cast< ::saml2::protocol::IDPListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"IDPList",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::IDPListType >
    IDPList (::xercesc::DOMDocument* d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"IDPList",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::IDPListType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::IDPListType > r (
          dynamic_cast< ::saml2::protocol::IDPListType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"IDPList",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (const ::std::wstring& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
        ::saml2::protocol::IDPEntry (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (const ::std::wstring& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
        ::saml2::protocol::IDPEntry (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (const ::std::wstring& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
        ::saml2::protocol::IDPEntry (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPEntry (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPEntry (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPEntry (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPEntry (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPEntry (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (::std::istream& is,
              const ::std::wstring& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::IDPEntry (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
        ::saml2::protocol::IDPEntry (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (const ::xercesc::DOMInputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
        ::saml2::protocol::IDPEntry (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
        ::saml2::protocol::IDPEntry (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
          ::saml2::protocol::IDPEntry (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"IDPEntry",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::IDPEntryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
          dynamic_cast< ::saml2::protocol::IDPEntryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"IDPEntry",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::IDPEntryType >
    IDPEntry (::xercesc::DOMDocument* d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"IDPEntry",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::IDPEntryType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::IDPEntryType > r (
          dynamic_cast< ::saml2::protocol::IDPEntryType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"IDPEntry",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (const ::std::wstring& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::GetComplete (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (const ::std::wstring& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::GetComplete (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (const ::std::wstring& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::GetComplete (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::GetComplete (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::GetComplete (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::GetComplete (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::GetComplete (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::GetComplete (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::GetComplete (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::GetComplete (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::GetComplete (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (const ::xercesc::DOMInputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::protocol::GetComplete (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::protocol::GetComplete (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"GetComplete",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"GetComplete",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    GetComplete (::xercesc::DOMDocument* d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"GetComplete",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"GetComplete",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (const ::std::wstring& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
        ::saml2::protocol::Response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (const ::std::wstring& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
        ::saml2::protocol::Response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (const ::std::wstring& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
        ::saml2::protocol::Response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Response (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Response (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Response (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Response (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Response (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (::std::istream& is,
              const ::std::wstring& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Response (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
        ::saml2::protocol::Response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (const ::xercesc::DOMInputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
        ::saml2::protocol::Response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
        ::saml2::protocol::Response (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
          ::saml2::protocol::Response (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Response",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
          dynamic_cast< ::saml2::protocol::ResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Response",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ResponseType >
    Response (::xercesc::DOMDocument* d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Response",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::ResponseType > r (
          dynamic_cast< ::saml2::protocol::ResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Response",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
        ::saml2::protocol::ArtifactResolve (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
        ::saml2::protocol::ArtifactResolve (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
        ::saml2::protocol::ArtifactResolve (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResolve (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResolve (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResolve (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResolve (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResolve (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResolve (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
        ::saml2::protocol::ArtifactResolve (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
        ::saml2::protocol::ArtifactResolve (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
        ::saml2::protocol::ArtifactResolve (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
          ::saml2::protocol::ArtifactResolve (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ArtifactResolve",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ArtifactResolveType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
          dynamic_cast< ::saml2::protocol::ArtifactResolveType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ArtifactResolve",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType >
    ArtifactResolve (::xercesc::DOMDocument* d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ArtifactResolve",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ArtifactResolveType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::ArtifactResolveType > r (
          dynamic_cast< ::saml2::protocol::ArtifactResolveType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ArtifactResolve",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (const ::std::wstring& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::Artifact (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (const ::std::wstring& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::Artifact (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (const ::std::wstring& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::Artifact (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Artifact (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Artifact (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Artifact (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Artifact (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Artifact (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (::std::istream& is,
              const ::std::wstring& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Artifact (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::Artifact (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (const ::xercesc::DOMInputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::Artifact (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::Artifact (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::protocol::Artifact (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Artifact",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Artifact",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    Artifact (::xercesc::DOMDocument* d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Artifact",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Artifact",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
        ::saml2::protocol::ArtifactResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
        ::saml2::protocol::ArtifactResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
        ::saml2::protocol::ArtifactResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ArtifactResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
        ::saml2::protocol::ArtifactResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
        ::saml2::protocol::ArtifactResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
        ::saml2::protocol::ArtifactResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
          ::saml2::protocol::ArtifactResponse (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ArtifactResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ArtifactResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
          dynamic_cast< ::saml2::protocol::ArtifactResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ArtifactResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType >
    ArtifactResponse (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ArtifactResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ArtifactResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::ArtifactResponseType > r (
          dynamic_cast< ::saml2::protocol::ArtifactResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ArtifactResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (const ::std::wstring& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
        ::saml2::protocol::ManageNameIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (const ::std::wstring& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
        ::saml2::protocol::ManageNameIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (const ::std::wstring& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
        ::saml2::protocol::ManageNameIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
        ::saml2::protocol::ManageNameIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
        ::saml2::protocol::ManageNameIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
        ::saml2::protocol::ManageNameIDRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
          ::saml2::protocol::ManageNameIDRequest (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ManageNameIDRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ManageNameIDRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
          dynamic_cast< ::saml2::protocol::ManageNameIDRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ManageNameIDRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType >
    ManageNameIDRequest (::xercesc::DOMDocument* d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ManageNameIDRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::ManageNameIDRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::ManageNameIDRequestType > r (
          dynamic_cast< ::saml2::protocol::ManageNameIDRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ManageNameIDRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (const ::std::wstring& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::NewID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (const ::std::wstring& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::NewID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (const ::std::wstring& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::NewID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewID (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (::std::istream& is,
           const ::std::wstring& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewID (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (::std::istream& is,
           const ::std::wstring& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (::std::istream& is,
           const ::std::wstring& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (const ::xercesc::DOMInputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::NewID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (const ::xercesc::DOMInputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::NewID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (const ::xercesc::DOMInputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::NewID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::protocol::NewID (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NewID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NewID",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    NewID (::xercesc::DOMDocument* d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NewID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NewID",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::protocol::NewEncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::protocol::NewEncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::protocol::NewEncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewEncryptedID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewEncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewEncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewEncryptedID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewEncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NewEncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::protocol::NewEncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::protocol::NewEncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::protocol::NewEncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          ::saml2::protocol::NewEncryptedID (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NewEncryptedID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NewEncryptedID",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    NewEncryptedID (::xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NewEncryptedID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NewEncryptedID",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
        ::saml2::protocol::Terminate (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
        ::saml2::protocol::Terminate (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
        ::saml2::protocol::Terminate (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Terminate (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Terminate (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Terminate (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Terminate (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Terminate (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::Terminate (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
        ::saml2::protocol::Terminate (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (const ::xercesc::DOMInputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
        ::saml2::protocol::Terminate (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
        ::saml2::protocol::Terminate (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
          ::saml2::protocol::Terminate (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Terminate",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::TerminateType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
          dynamic_cast< ::saml2::protocol::TerminateType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Terminate",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::TerminateType >
    Terminate (::xercesc::DOMDocument* d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Terminate",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::TerminateType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::TerminateType > r (
          dynamic_cast< ::saml2::protocol::TerminateType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Terminate",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (const ::std::wstring& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::ManageNameIDResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (const ::std::wstring& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::ManageNameIDResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (const ::std::wstring& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::ManageNameIDResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::ManageNameIDResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::ManageNameIDResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::ManageNameIDResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (const ::xercesc::DOMInputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::ManageNameIDResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
          ::saml2::protocol::ManageNameIDResponse (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ManageNameIDResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
          dynamic_cast< ::saml2::protocol::StatusResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ManageNameIDResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    ManageNameIDResponse (::xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ManageNameIDResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
          dynamic_cast< ::saml2::protocol::StatusResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ManageNameIDResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (const ::std::wstring& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
        ::saml2::protocol::LogoutRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (const ::std::wstring& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
        ::saml2::protocol::LogoutRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (const ::std::wstring& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
        ::saml2::protocol::LogoutRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
        ::saml2::protocol::LogoutRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
        ::saml2::protocol::LogoutRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (const ::xercesc::DOMInputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
        ::saml2::protocol::LogoutRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
          ::saml2::protocol::LogoutRequest (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"LogoutRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::LogoutRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
          dynamic_cast< ::saml2::protocol::LogoutRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"LogoutRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::LogoutRequestType >
    LogoutRequest (::xercesc::DOMDocument* d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"LogoutRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::LogoutRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::LogoutRequestType > r (
          dynamic_cast< ::saml2::protocol::LogoutRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"LogoutRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::SessionIndex (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::SessionIndex (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::SessionIndex (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SessionIndex (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SessionIndex (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SessionIndex (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SessionIndex (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SessionIndex (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::SessionIndex (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::SessionIndex (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::SessionIndex (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::protocol::SessionIndex (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::protocol::SessionIndex (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SessionIndex",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SessionIndex",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::xml_schema::string >
    SessionIndex (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SessionIndex",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SessionIndex",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::LogoutResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::LogoutResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::LogoutResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::LogoutResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::LogoutResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::LogoutResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
        ::saml2::protocol::LogoutResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
          ::saml2::protocol::LogoutResponse (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"LogoutResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
          dynamic_cast< ::saml2::protocol::StatusResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"LogoutResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::StatusResponseType >
    LogoutResponse (::xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"LogoutResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::StatusResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::StatusResponseType > r (
          dynamic_cast< ::saml2::protocol::StatusResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"LogoutResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (const ::std::wstring& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
        ::saml2::protocol::NameIDMappingRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (const ::std::wstring& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
        ::saml2::protocol::NameIDMappingRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (const ::std::wstring& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
        ::saml2::protocol::NameIDMappingRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingRequest (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingRequest (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
        ::saml2::protocol::NameIDMappingRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
        ::saml2::protocol::NameIDMappingRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (const ::xercesc::DOMInputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
        ::saml2::protocol::NameIDMappingRequest (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
          ::saml2::protocol::NameIDMappingRequest (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDMappingRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::NameIDMappingRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
          dynamic_cast< ::saml2::protocol::NameIDMappingRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDMappingRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType >
    NameIDMappingRequest (::xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDMappingRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::NameIDMappingRequestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::NameIDMappingRequestType > r (
          dynamic_cast< ::saml2::protocol::NameIDMappingRequestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDMappingRequest",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (const ::std::wstring& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
        ::saml2::protocol::NameIDMappingResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (const ::std::wstring& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
        ::saml2::protocol::NameIDMappingResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (const ::std::wstring& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
        ::saml2::protocol::NameIDMappingResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingResponse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::protocol::NameIDMappingResponse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (const ::xercesc::DOMInputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
        ::saml2::protocol::NameIDMappingResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (const ::xercesc::DOMInputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
        ::saml2::protocol::NameIDMappingResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (const ::xercesc::DOMInputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
        ::saml2::protocol::NameIDMappingResponse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
          ::saml2::protocol::NameIDMappingResponse (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDMappingResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::NameIDMappingResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
          dynamic_cast< ::saml2::protocol::NameIDMappingResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDMappingResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }

    ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType >
    NameIDMappingResponse (::xercesc::DOMDocument* d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDMappingResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          &::xsd::cxx::tree::factory_impl< ::saml2::protocol::NameIDMappingResponseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::protocol::NameIDMappingResponseType > r (
          dynamic_cast< ::saml2::protocol::NameIDMappingResponseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDMappingResponse",
        L"urn:oasis:names:tc:SAML:2.0:protocol");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace saml2
{
  namespace protocol
  {
    void
    operator<< (::xercesc::DOMElement& e, const RequestAbstractType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Issuer
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Issuer ())
        {
          const RequestAbstractType::Issuer_type& x (*i.Issuer ());
          if (typeid (RequestAbstractType::Issuer_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Issuer",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Issuer",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Signature
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          const RequestAbstractType::Signature_type& x (*i.Signature ());
          if (typeid (RequestAbstractType::Signature_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Signature",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const RequestAbstractType::Extensions_type& x (*i.Extensions ());
          if (typeid (RequestAbstractType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // ID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ID",
            e));

        a << i.ID ();
      }

      // Version
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Version",
            e));

        a << i.Version ();
      }

      // IssueInstant
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"IssueInstant",
            e));

        a << i.IssueInstant ();
      }

      // Destination
      //
      if (i.Destination ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Destination",
            e));

        a << *i.Destination ();
      }

      // Consent
      //
      if (i.Consent ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Consent",
            e));

        a << *i.Consent ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, RequestAbstractType >
    _xsd_RequestAbstractType_type_serializer_init (
      L"RequestAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    Extensions (::std::ostream& o,
                const ::saml2::protocol::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Extensions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Extensions (::std::ostream& o,
                const ::saml2::protocol::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Extensions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::std::ostream& o,
                const ::saml2::protocol::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Extensions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Extensions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Extensions (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Extensions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Extensions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::xercesc::DOMDocument& d,
                const ::saml2::protocol::ExtensionsType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::ExtensionsType) == typeid (s))
      {
        if (n.name () == L"Extensions" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Extensions",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Extensions",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Extensions (const ::saml2::protocol::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::ExtensionsType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Extensions",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Extensions",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::Extensions (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtensionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any
      //
      for (ExtensionsType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ExtensionsType >
    _xsd_ExtensionsType_type_serializer_init (
      L"ExtensionsType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    operator<< (::xercesc::DOMElement& e, const StatusResponseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Issuer
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Issuer ())
        {
          const StatusResponseType::Issuer_type& x (*i.Issuer ());
          if (typeid (StatusResponseType::Issuer_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Issuer",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Issuer",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Signature
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          const StatusResponseType::Signature_type& x (*i.Signature ());
          if (typeid (StatusResponseType::Signature_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Signature",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const StatusResponseType::Extensions_type& x (*i.Extensions ());
          if (typeid (StatusResponseType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // Status
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const StatusResponseType::Status_type& x (i.Status ());
        if (typeid (StatusResponseType::Status_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Status",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Status",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            true, true, e, x);
      }

      // ID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ID",
            e));

        a << i.ID ();
      }

      // InResponseTo
      //
      if (i.InResponseTo ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"InResponseTo",
            e));

        a << *i.InResponseTo ();
      }

      // Version
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Version",
            e));

        a << i.Version ();
      }

      // IssueInstant
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"IssueInstant",
            e));

        a << i.IssueInstant ();
      }

      // Destination
      //
      if (i.Destination ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Destination",
            e));

        a << *i.Destination ();
      }

      // Consent
      //
      if (i.Consent ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Consent",
            e));

        a << *i.Consent ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StatusResponseType >
    _xsd_StatusResponseType_type_serializer_init (
      L"StatusResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    Status (::std::ostream& o,
            const ::saml2::protocol::StatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Status (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Status (::std::ostream& o,
            const ::saml2::protocol::StatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Status (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Status (::std::ostream& o,
            const ::saml2::protocol::StatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Status (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Status (::xercesc::XMLFormatTarget& t,
            const ::saml2::protocol::StatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Status (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Status (::xercesc::XMLFormatTarget& t,
            const ::saml2::protocol::StatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Status (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Status (::xercesc::XMLFormatTarget& t,
            const ::saml2::protocol::StatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Status (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Status (::xercesc::DOMDocument& d,
            const ::saml2::protocol::StatusType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::StatusType) == typeid (s))
      {
        if (n.name () == L"Status" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Status",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Status",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Status (const ::saml2::protocol::StatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::StatusType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Status",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Status",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::Status (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const StatusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StatusCode
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const StatusType::StatusCode_type& x (i.StatusCode ());
        if (typeid (StatusType::StatusCode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"StatusCode",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"StatusCode",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            true, true, e, x);
      }

      // StatusMessage
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.StatusMessage ())
        {
          const StatusType::StatusMessage_type& x (*i.StatusMessage ());
          if (typeid (StatusType::StatusMessage_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"StatusMessage",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"StatusMessage",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // StatusDetail
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.StatusDetail ())
        {
          const StatusType::StatusDetail_type& x (*i.StatusDetail ());
          if (typeid (StatusType::StatusDetail_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"StatusDetail",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"StatusDetail",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StatusType >
    _xsd_StatusType_type_serializer_init (
      L"StatusType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    StatusCode (::std::ostream& o,
                const ::saml2::protocol::StatusCodeType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusCode (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    StatusCode (::std::ostream& o,
                const ::saml2::protocol::StatusCodeType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusCode (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusCode (::std::ostream& o,
                const ::saml2::protocol::StatusCodeType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusCode (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusCode (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::StatusCodeType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusCode (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    StatusCode (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::StatusCodeType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusCode (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusCode (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::StatusCodeType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusCode (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusCode (::xercesc::DOMDocument& d,
                const ::saml2::protocol::StatusCodeType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::StatusCodeType) == typeid (s))
      {
        if (n.name () == L"StatusCode" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"StatusCode",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"StatusCode",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    StatusCode (const ::saml2::protocol::StatusCodeType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::StatusCodeType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"StatusCode",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"StatusCode",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::StatusCode (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const StatusCodeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StatusCode
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.StatusCode ())
        {
          const StatusCodeType::StatusCode_type& x (*i.StatusCode ());
          if (typeid (StatusCodeType::StatusCode_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"StatusCode",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"StatusCode",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // Value
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Value",
            e));

        a << i.Value ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StatusCodeType >
    _xsd_StatusCodeType_type_serializer_init (
      L"StatusCodeType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    StatusMessage (::std::ostream& o,
                   const ::xml_schema::string& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusMessage (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    StatusMessage (::std::ostream& o,
                   const ::xml_schema::string& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusMessage (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusMessage (::std::ostream& o,
                   const ::xml_schema::string& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusMessage (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusMessage (::xercesc::XMLFormatTarget& t,
                   const ::xml_schema::string& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusMessage (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    StatusMessage (::xercesc::XMLFormatTarget& t,
                   const ::xml_schema::string& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusMessage (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusMessage (::xercesc::XMLFormatTarget& t,
                   const ::xml_schema::string& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusMessage (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusMessage (::xercesc::DOMDocument& d,
                   const ::xml_schema::string& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"StatusMessage" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"StatusMessage",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"StatusMessage",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    StatusMessage (const ::xml_schema::string& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"StatusMessage",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"StatusMessage",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::StatusMessage (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    StatusDetail (::std::ostream& o,
                  const ::saml2::protocol::StatusDetailType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusDetail (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    StatusDetail (::std::ostream& o,
                  const ::saml2::protocol::StatusDetailType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusDetail (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusDetail (::std::ostream& o,
                  const ::saml2::protocol::StatusDetailType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusDetail (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusDetail (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::StatusDetailType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusDetail (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    StatusDetail (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::StatusDetailType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusDetail (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusDetail (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::StatusDetailType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::StatusDetail (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    StatusDetail (::xercesc::DOMDocument& d,
                  const ::saml2::protocol::StatusDetailType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::StatusDetailType) == typeid (s))
      {
        if (n.name () == L"StatusDetail" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"StatusDetail",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"StatusDetail",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    StatusDetail (const ::saml2::protocol::StatusDetailType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::StatusDetailType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"StatusDetail",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"StatusDetail",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::StatusDetail (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const StatusDetailType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any
      //
      for (StatusDetailType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StatusDetailType >
    _xsd_StatusDetailType_type_serializer_init (
      L"StatusDetailType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    AssertionIDRequest (::std::ostream& o,
                        const ::saml2::protocol::AssertionIDRequestType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AssertionIDRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRequest (::std::ostream& o,
                        const ::saml2::protocol::AssertionIDRequestType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AssertionIDRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequest (::std::ostream& o,
                        const ::saml2::protocol::AssertionIDRequestType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AssertionIDRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequest (::xercesc::XMLFormatTarget& t,
                        const ::saml2::protocol::AssertionIDRequestType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AssertionIDRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRequest (::xercesc::XMLFormatTarget& t,
                        const ::saml2::protocol::AssertionIDRequestType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AssertionIDRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequest (::xercesc::XMLFormatTarget& t,
                        const ::saml2::protocol::AssertionIDRequestType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AssertionIDRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequest (::xercesc::DOMDocument& d,
                        const ::saml2::protocol::AssertionIDRequestType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::AssertionIDRequestType) == typeid (s))
      {
        if (n.name () == L"AssertionIDRequest" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AssertionIDRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AssertionIDRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AssertionIDRequest (const ::saml2::protocol::AssertionIDRequestType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::AssertionIDRequestType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AssertionIDRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AssertionIDRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::AssertionIDRequest (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AssertionIDRequestType& i)
    {
      e << static_cast< const ::saml2::protocol::RequestAbstractType& > (i);

      // AssertionIDRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionIDRequestType::AssertionIDRef_const_iterator
             b (i.AssertionIDRef ().begin ()), n (i.AssertionIDRef ().end ());
             b != n; ++b)
        {
          if (typeid (AssertionIDRequestType::AssertionIDRef_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionIDRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AssertionIDRequestType >
    _xsd_AssertionIDRequestType_type_serializer_init (
      L"AssertionIDRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    SubjectQuery (::std::ostream& o,
                  const ::saml2::protocol::SubjectQueryAbstractType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SubjectQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectQuery (::std::ostream& o,
                  const ::saml2::protocol::SubjectQueryAbstractType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SubjectQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectQuery (::std::ostream& o,
                  const ::saml2::protocol::SubjectQueryAbstractType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SubjectQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectQuery (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::SubjectQueryAbstractType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SubjectQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectQuery (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::SubjectQueryAbstractType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SubjectQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectQuery (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::SubjectQueryAbstractType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SubjectQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectQuery (::xercesc::DOMDocument& d,
                  const ::saml2::protocol::SubjectQueryAbstractType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::SubjectQueryAbstractType) == typeid (s))
      {
        if (n.name () == L"SubjectQuery" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SubjectQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SubjectQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SubjectQuery (const ::saml2::protocol::SubjectQueryAbstractType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::SubjectQueryAbstractType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SubjectQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SubjectQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::SubjectQuery (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SubjectQueryAbstractType& i)
    {
      e << static_cast< const ::saml2::protocol::RequestAbstractType& > (i);

      // Subject
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const SubjectQueryAbstractType::Subject_type& x (i.Subject ());
        if (typeid (SubjectQueryAbstractType::Subject_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Subject",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Subject",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true, true, e, x);
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectQueryAbstractType >
    _xsd_SubjectQueryAbstractType_type_serializer_init (
      L"SubjectQueryAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    AuthnQuery (::std::ostream& o,
                const ::saml2::protocol::AuthnQueryType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnQuery (::std::ostream& o,
                const ::saml2::protocol::AuthnQueryType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQuery (::std::ostream& o,
                const ::saml2::protocol::AuthnQueryType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQuery (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::AuthnQueryType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnQuery (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::AuthnQueryType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQuery (::xercesc::XMLFormatTarget& t,
                const ::saml2::protocol::AuthnQueryType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQuery (::xercesc::DOMDocument& d,
                const ::saml2::protocol::AuthnQueryType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::AuthnQueryType) == typeid (s))
      {
        if (n.name () == L"AuthnQuery" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnQuery (const ::saml2::protocol::AuthnQueryType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::AuthnQueryType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::AuthnQuery (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AuthnQueryType& i)
    {
      e << static_cast< const ::saml2::protocol::SubjectQueryAbstractType& > (i);

      // RequestedAuthnContext
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.RequestedAuthnContext ())
        {
          const AuthnQueryType::RequestedAuthnContext_type& x (*i.RequestedAuthnContext ());
          if (typeid (AuthnQueryType::RequestedAuthnContext_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"RequestedAuthnContext",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"RequestedAuthnContext",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // SessionIndex
      //
      if (i.SessionIndex ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"SessionIndex",
            e));

        a << *i.SessionIndex ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnQueryType >
    _xsd_AuthnQueryType_type_serializer_init (
      L"AuthnQueryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    RequestedAuthnContext (::std::ostream& o,
                           const ::saml2::protocol::RequestedAuthnContextType& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequestedAuthnContext (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RequestedAuthnContext (::std::ostream& o,
                           const ::saml2::protocol::RequestedAuthnContextType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::error_handler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequestedAuthnContext (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAuthnContext (::std::ostream& o,
                           const ::saml2::protocol::RequestedAuthnContextType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xercesc::DOMErrorHandler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequestedAuthnContext (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAuthnContext (::xercesc::XMLFormatTarget& t,
                           const ::saml2::protocol::RequestedAuthnContextType& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequestedAuthnContext (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RequestedAuthnContext (::xercesc::XMLFormatTarget& t,
                           const ::saml2::protocol::RequestedAuthnContextType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::error_handler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequestedAuthnContext (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAuthnContext (::xercesc::XMLFormatTarget& t,
                           const ::saml2::protocol::RequestedAuthnContextType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xercesc::DOMErrorHandler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequestedAuthnContext (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAuthnContext (::xercesc::DOMDocument& d,
                           const ::saml2::protocol::RequestedAuthnContextType& s,
                           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::RequestedAuthnContextType) == typeid (s))
      {
        if (n.name () == L"RequestedAuthnContext" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"RequestedAuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"RequestedAuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    RequestedAuthnContext (const ::saml2::protocol::RequestedAuthnContextType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::RequestedAuthnContextType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"RequestedAuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"RequestedAuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::RequestedAuthnContext (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RequestedAuthnContextType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AuthnContextClassRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (RequestedAuthnContextType::AuthnContextClassRef_const_iterator
             b (i.AuthnContextClassRef ().begin ()), n (i.AuthnContextClassRef ().end ());
             b != n; ++b)
        {
          if (typeid (RequestedAuthnContextType::AuthnContextClassRef_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnContextClassRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthnContextClassRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // AuthnContextDeclRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (RequestedAuthnContextType::AuthnContextDeclRef_const_iterator
             b (i.AuthnContextDeclRef ().begin ()), n (i.AuthnContextDeclRef ().end ());
             b != n; ++b)
        {
          if (typeid (RequestedAuthnContextType::AuthnContextDeclRef_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnContextDeclRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthnContextDeclRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Comparison
      //
      if (i.Comparison ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Comparison",
            e));

        a << *i.Comparison ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, RequestedAuthnContextType >
    _xsd_RequestedAuthnContextType_type_serializer_init (
      L"RequestedAuthnContextType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    operator<< (::xercesc::DOMElement& e, const AuthnContextComparisonType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const AuthnContextComparisonType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const AuthnContextComparisonType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnContextComparisonType >
    _xsd_AuthnContextComparisonType_type_serializer_init (
      L"AuthnContextComparisonType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    AttributeQuery (::std::ostream& o,
                    const ::saml2::protocol::AttributeQueryType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AttributeQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeQuery (::std::ostream& o,
                    const ::saml2::protocol::AttributeQueryType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AttributeQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeQuery (::std::ostream& o,
                    const ::saml2::protocol::AttributeQueryType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AttributeQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeQuery (::xercesc::XMLFormatTarget& t,
                    const ::saml2::protocol::AttributeQueryType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AttributeQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeQuery (::xercesc::XMLFormatTarget& t,
                    const ::saml2::protocol::AttributeQueryType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AttributeQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeQuery (::xercesc::XMLFormatTarget& t,
                    const ::saml2::protocol::AttributeQueryType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AttributeQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeQuery (::xercesc::DOMDocument& d,
                    const ::saml2::protocol::AttributeQueryType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::AttributeQueryType) == typeid (s))
      {
        if (n.name () == L"AttributeQuery" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AttributeQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AttributeQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeQuery (const ::saml2::protocol::AttributeQueryType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::AttributeQueryType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AttributeQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AttributeQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::AttributeQuery (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AttributeQueryType& i)
    {
      e << static_cast< const ::saml2::protocol::SubjectQueryAbstractType& > (i);

      // Attribute
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeQueryType::Attribute_const_iterator
             b (i.Attribute ().begin ()), n (i.Attribute ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeQueryType::Attribute_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Attribute",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeQueryType >
    _xsd_AttributeQueryType_type_serializer_init (
      L"AttributeQueryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    AuthzDecisionQuery (::std::ostream& o,
                        const ::saml2::protocol::AuthzDecisionQueryType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthzDecisionQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzDecisionQuery (::std::ostream& o,
                        const ::saml2::protocol::AuthzDecisionQueryType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthzDecisionQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionQuery (::std::ostream& o,
                        const ::saml2::protocol::AuthzDecisionQueryType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthzDecisionQuery (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionQuery (::xercesc::XMLFormatTarget& t,
                        const ::saml2::protocol::AuthzDecisionQueryType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthzDecisionQuery (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzDecisionQuery (::xercesc::XMLFormatTarget& t,
                        const ::saml2::protocol::AuthzDecisionQueryType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthzDecisionQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionQuery (::xercesc::XMLFormatTarget& t,
                        const ::saml2::protocol::AuthzDecisionQueryType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthzDecisionQuery (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionQuery (::xercesc::DOMDocument& d,
                        const ::saml2::protocol::AuthzDecisionQueryType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::AuthzDecisionQueryType) == typeid (s))
      {
        if (n.name () == L"AuthzDecisionQuery" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthzDecisionQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthzDecisionQuery",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthzDecisionQuery (const ::saml2::protocol::AuthzDecisionQueryType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::AuthzDecisionQueryType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthzDecisionQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthzDecisionQuery",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::AuthzDecisionQuery (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AuthzDecisionQueryType& i)
    {
      e << static_cast< const ::saml2::protocol::SubjectQueryAbstractType& > (i);

      // Action
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthzDecisionQueryType::Action_const_iterator
             b (i.Action ().begin ()), n (i.Action ().end ());
             b != n; ++b)
        {
          if (typeid (AuthzDecisionQueryType::Action_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Action",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Action",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Evidence
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Evidence ())
        {
          const AuthzDecisionQueryType::Evidence_type& x (*i.Evidence ());
          if (typeid (AuthzDecisionQueryType::Evidence_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Evidence",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Evidence",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Resource
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Resource",
            e));

        a << i.Resource ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthzDecisionQueryType >
    _xsd_AuthzDecisionQueryType_type_serializer_init (
      L"AuthzDecisionQueryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    AuthnRequest (::std::ostream& o,
                  const ::saml2::protocol::AuthnRequestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnRequest (::std::ostream& o,
                  const ::saml2::protocol::AuthnRequestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnRequest (::std::ostream& o,
                  const ::saml2::protocol::AuthnRequestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnRequest (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::AuthnRequestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnRequest (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::AuthnRequestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnRequest (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::AuthnRequestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::AuthnRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnRequest (::xercesc::DOMDocument& d,
                  const ::saml2::protocol::AuthnRequestType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::AuthnRequestType) == typeid (s))
      {
        if (n.name () == L"AuthnRequest" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnRequest (const ::saml2::protocol::AuthnRequestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::AuthnRequestType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::AuthnRequest (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AuthnRequestType& i)
    {
      e << static_cast< const ::saml2::protocol::RequestAbstractType& > (i);

      // Subject
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Subject ())
        {
          const AuthnRequestType::Subject_type& x (*i.Subject ());
          if (typeid (AuthnRequestType::Subject_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Subject",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Subject",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // NameIDPolicy
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameIDPolicy ())
        {
          const AuthnRequestType::NameIDPolicy_type& x (*i.NameIDPolicy ());
          if (typeid (AuthnRequestType::NameIDPolicy_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameIDPolicy",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NameIDPolicy",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // Conditions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Conditions ())
        {
          const AuthnRequestType::Conditions_type& x (*i.Conditions ());
          if (typeid (AuthnRequestType::Conditions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Conditions",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Conditions",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // RequestedAuthnContext
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.RequestedAuthnContext ())
        {
          const AuthnRequestType::RequestedAuthnContext_type& x (*i.RequestedAuthnContext ());
          if (typeid (AuthnRequestType::RequestedAuthnContext_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"RequestedAuthnContext",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"RequestedAuthnContext",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // Scoping
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Scoping ())
        {
          const AuthnRequestType::Scoping_type& x (*i.Scoping ());
          if (typeid (AuthnRequestType::Scoping_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Scoping",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Scoping",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // ForceAuthn
      //
      if (i.ForceAuthn ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ForceAuthn",
            e));

        a << *i.ForceAuthn ();
      }

      // IsPassive
      //
      if (i.IsPassive ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"IsPassive",
            e));

        a << *i.IsPassive ();
      }

      // ProtocolBinding
      //
      if (i.ProtocolBinding ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ProtocolBinding",
            e));

        a << *i.ProtocolBinding ();
      }

      // AssertionConsumerServiceIndex
      //
      if (i.AssertionConsumerServiceIndex ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"AssertionConsumerServiceIndex",
            e));

        a << *i.AssertionConsumerServiceIndex ();
      }

      // AssertionConsumerServiceURL
      //
      if (i.AssertionConsumerServiceURL ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"AssertionConsumerServiceURL",
            e));

        a << *i.AssertionConsumerServiceURL ();
      }

      // AttributeConsumingServiceIndex
      //
      if (i.AttributeConsumingServiceIndex ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"AttributeConsumingServiceIndex",
            e));

        a << *i.AttributeConsumingServiceIndex ();
      }

      // ProviderName
      //
      if (i.ProviderName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ProviderName",
            e));

        a << *i.ProviderName ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnRequestType >
    _xsd_AuthnRequestType_type_serializer_init (
      L"AuthnRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    NameIDPolicy (::std::ostream& o,
                  const ::saml2::protocol::NameIDPolicyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDPolicy (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDPolicy (::std::ostream& o,
                  const ::saml2::protocol::NameIDPolicyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDPolicy (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDPolicy (::std::ostream& o,
                  const ::saml2::protocol::NameIDPolicyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDPolicy (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDPolicy (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::NameIDPolicyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDPolicy (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDPolicy (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::NameIDPolicyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDPolicy (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDPolicy (::xercesc::XMLFormatTarget& t,
                  const ::saml2::protocol::NameIDPolicyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDPolicy (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDPolicy (::xercesc::DOMDocument& d,
                  const ::saml2::protocol::NameIDPolicyType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::NameIDPolicyType) == typeid (s))
      {
        if (n.name () == L"NameIDPolicy" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NameIDPolicy",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NameIDPolicy",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NameIDPolicy (const ::saml2::protocol::NameIDPolicyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::NameIDPolicyType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NameIDPolicy",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NameIDPolicy",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::NameIDPolicy (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NameIDPolicyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Format
      //
      if (i.Format ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Format",
            e));

        a << *i.Format ();
      }

      // SPNameQualifier
      //
      if (i.SPNameQualifier ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"SPNameQualifier",
            e));

        a << *i.SPNameQualifier ();
      }

      // AllowCreate
      //
      if (i.AllowCreate ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"AllowCreate",
            e));

        a << *i.AllowCreate ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NameIDPolicyType >
    _xsd_NameIDPolicyType_type_serializer_init (
      L"NameIDPolicyType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    Scoping (::std::ostream& o,
             const ::saml2::protocol::ScopingType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Scoping (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Scoping (::std::ostream& o,
             const ::saml2::protocol::ScopingType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Scoping (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Scoping (::std::ostream& o,
             const ::saml2::protocol::ScopingType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Scoping (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Scoping (::xercesc::XMLFormatTarget& t,
             const ::saml2::protocol::ScopingType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Scoping (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Scoping (::xercesc::XMLFormatTarget& t,
             const ::saml2::protocol::ScopingType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Scoping (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Scoping (::xercesc::XMLFormatTarget& t,
             const ::saml2::protocol::ScopingType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Scoping (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Scoping (::xercesc::DOMDocument& d,
             const ::saml2::protocol::ScopingType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::ScopingType) == typeid (s))
      {
        if (n.name () == L"Scoping" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Scoping",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Scoping",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Scoping (const ::saml2::protocol::ScopingType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::ScopingType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Scoping",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Scoping",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::Scoping (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ScopingType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IDPList
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.IDPList ())
        {
          const ScopingType::IDPList_type& x (*i.IDPList ());
          if (typeid (ScopingType::IDPList_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"IDPList",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"IDPList",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // RequesterID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ScopingType::RequesterID_const_iterator
             b (i.RequesterID ().begin ()), n (i.RequesterID ().end ());
             b != n; ++b)
        {
          if (typeid (ScopingType::RequesterID_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"RequesterID",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"RequesterID",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, *b);
        }
      }

      // ProxyCount
      //
      if (i.ProxyCount ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ProxyCount",
            e));

        a << *i.ProxyCount ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ScopingType >
    _xsd_ScopingType_type_serializer_init (
      L"ScopingType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    RequesterID (::std::ostream& o,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequesterID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RequesterID (::std::ostream& o,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequesterID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequesterID (::std::ostream& o,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequesterID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequesterID (::xercesc::XMLFormatTarget& t,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequesterID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RequesterID (::xercesc::XMLFormatTarget& t,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequesterID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequesterID (::xercesc::XMLFormatTarget& t,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::RequesterID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequesterID (::xercesc::DOMDocument& d,
                 const ::xml_schema::uri& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"RequesterID" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"RequesterID",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"RequesterID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    RequesterID (const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"RequesterID",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"RequesterID",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::RequesterID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    IDPList (::std::ostream& o,
             const ::saml2::protocol::IDPListType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPList (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    IDPList (::std::ostream& o,
             const ::saml2::protocol::IDPListType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPList (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPList (::std::ostream& o,
             const ::saml2::protocol::IDPListType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPList (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPList (::xercesc::XMLFormatTarget& t,
             const ::saml2::protocol::IDPListType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPList (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    IDPList (::xercesc::XMLFormatTarget& t,
             const ::saml2::protocol::IDPListType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPList (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPList (::xercesc::XMLFormatTarget& t,
             const ::saml2::protocol::IDPListType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPList (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPList (::xercesc::DOMDocument& d,
             const ::saml2::protocol::IDPListType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::IDPListType) == typeid (s))
      {
        if (n.name () == L"IDPList" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"IDPList",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"IDPList",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    IDPList (const ::saml2::protocol::IDPListType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::IDPListType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"IDPList",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"IDPList",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::IDPList (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IDPListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IDPEntry
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (IDPListType::IDPEntry_const_iterator
             b (i.IDPEntry ().begin ()), n (i.IDPEntry ().end ());
             b != n; ++b)
        {
          if (typeid (IDPListType::IDPEntry_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"IDPEntry",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"IDPEntry",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, *b);
        }
      }

      // GetComplete
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.GetComplete ())
        {
          const IDPListType::GetComplete_type& x (*i.GetComplete ());
          if (typeid (IDPListType::GetComplete_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"GetComplete",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"GetComplete",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IDPListType >
    _xsd_IDPListType_type_serializer_init (
      L"IDPListType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    IDPEntry (::std::ostream& o,
              const ::saml2::protocol::IDPEntryType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPEntry (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    IDPEntry (::std::ostream& o,
              const ::saml2::protocol::IDPEntryType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPEntry (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPEntry (::std::ostream& o,
              const ::saml2::protocol::IDPEntryType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPEntry (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPEntry (::xercesc::XMLFormatTarget& t,
              const ::saml2::protocol::IDPEntryType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPEntry (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    IDPEntry (::xercesc::XMLFormatTarget& t,
              const ::saml2::protocol::IDPEntryType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPEntry (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPEntry (::xercesc::XMLFormatTarget& t,
              const ::saml2::protocol::IDPEntryType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::IDPEntry (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPEntry (::xercesc::DOMDocument& d,
              const ::saml2::protocol::IDPEntryType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::IDPEntryType) == typeid (s))
      {
        if (n.name () == L"IDPEntry" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"IDPEntry",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"IDPEntry",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    IDPEntry (const ::saml2::protocol::IDPEntryType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::IDPEntryType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"IDPEntry",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"IDPEntry",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::IDPEntry (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IDPEntryType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ProviderID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ProviderID",
            e));

        a << i.ProviderID ();
      }

      // Name
      //
      if (i.Name ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Name",
            e));

        a << *i.Name ();
      }

      // Loc
      //
      if (i.Loc ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Loc",
            e));

        a << *i.Loc ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IDPEntryType >
    _xsd_IDPEntryType_type_serializer_init (
      L"IDPEntryType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    GetComplete (::std::ostream& o,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::GetComplete (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    GetComplete (::std::ostream& o,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::GetComplete (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GetComplete (::std::ostream& o,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::GetComplete (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GetComplete (::xercesc::XMLFormatTarget& t,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::GetComplete (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    GetComplete (::xercesc::XMLFormatTarget& t,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::GetComplete (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GetComplete (::xercesc::XMLFormatTarget& t,
                 const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::GetComplete (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GetComplete (::xercesc::DOMDocument& d,
                 const ::xml_schema::uri& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"GetComplete" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"GetComplete",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"GetComplete",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    GetComplete (const ::xml_schema::uri& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"GetComplete",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"GetComplete",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::GetComplete (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Response (::std::ostream& o,
              const ::saml2::protocol::ResponseType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Response (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Response (::std::ostream& o,
              const ::saml2::protocol::ResponseType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Response (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Response (::std::ostream& o,
              const ::saml2::protocol::ResponseType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Response (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Response (::xercesc::XMLFormatTarget& t,
              const ::saml2::protocol::ResponseType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Response (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Response (::xercesc::XMLFormatTarget& t,
              const ::saml2::protocol::ResponseType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Response (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Response (::xercesc::XMLFormatTarget& t,
              const ::saml2::protocol::ResponseType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Response (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Response (::xercesc::DOMDocument& d,
              const ::saml2::protocol::ResponseType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::ResponseType) == typeid (s))
      {
        if (n.name () == L"Response" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Response",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Response",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Response (const ::saml2::protocol::ResponseType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::ResponseType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Response",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Response",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::Response (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResponseType& i)
    {
      e << static_cast< const ::saml2::protocol::StatusResponseType& > (i);

      // Assertion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ResponseType::Assertion_const_iterator
             b (i.Assertion ().begin ()), n (i.Assertion ().end ());
             b != n; ++b)
        {
          if (typeid (ResponseType::Assertion_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Assertion",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // EncryptedAssertion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ResponseType::EncryptedAssertion_const_iterator
             b (i.EncryptedAssertion ().begin ()), n (i.EncryptedAssertion ().end ());
             b != n; ++b)
        {
          if (typeid (ResponseType::EncryptedAssertion_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedAssertion",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ResponseType >
    _xsd_ResponseType_type_serializer_init (
      L"ResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    ArtifactResolve (::std::ostream& o,
                     const ::saml2::protocol::ArtifactResolveType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResolve (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ArtifactResolve (::std::ostream& o,
                     const ::saml2::protocol::ArtifactResolveType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResolve (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolve (::std::ostream& o,
                     const ::saml2::protocol::ArtifactResolveType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResolve (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolve (::xercesc::XMLFormatTarget& t,
                     const ::saml2::protocol::ArtifactResolveType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResolve (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ArtifactResolve (::xercesc::XMLFormatTarget& t,
                     const ::saml2::protocol::ArtifactResolveType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResolve (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolve (::xercesc::XMLFormatTarget& t,
                     const ::saml2::protocol::ArtifactResolveType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResolve (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolve (::xercesc::DOMDocument& d,
                     const ::saml2::protocol::ArtifactResolveType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::ArtifactResolveType) == typeid (s))
      {
        if (n.name () == L"ArtifactResolve" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ArtifactResolve",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ArtifactResolve",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ArtifactResolve (const ::saml2::protocol::ArtifactResolveType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::ArtifactResolveType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ArtifactResolve",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ArtifactResolve",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::ArtifactResolve (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArtifactResolveType& i)
    {
      e << static_cast< const ::saml2::protocol::RequestAbstractType& > (i);

      // Artifact
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const ArtifactResolveType::Artifact_type& x (i.Artifact ());
        if (typeid (ArtifactResolveType::Artifact_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Artifact",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Artifact",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            true, true, e, x);
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArtifactResolveType >
    _xsd_ArtifactResolveType_type_serializer_init (
      L"ArtifactResolveType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    Artifact (::std::ostream& o,
              const ::xml_schema::string& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Artifact (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Artifact (::std::ostream& o,
              const ::xml_schema::string& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Artifact (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Artifact (::std::ostream& o,
              const ::xml_schema::string& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Artifact (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Artifact (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::string& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Artifact (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Artifact (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::string& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Artifact (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Artifact (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::string& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Artifact (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Artifact (::xercesc::DOMDocument& d,
              const ::xml_schema::string& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"Artifact" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Artifact",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Artifact",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Artifact (const ::xml_schema::string& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Artifact",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Artifact",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::Artifact (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    ArtifactResponse (::std::ostream& o,
                      const ::saml2::protocol::ArtifactResponseType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ArtifactResponse (::std::ostream& o,
                      const ::saml2::protocol::ArtifactResponseType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResponse (::std::ostream& o,
                      const ::saml2::protocol::ArtifactResponseType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResponse (::xercesc::XMLFormatTarget& t,
                      const ::saml2::protocol::ArtifactResponseType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ArtifactResponse (::xercesc::XMLFormatTarget& t,
                      const ::saml2::protocol::ArtifactResponseType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResponse (::xercesc::XMLFormatTarget& t,
                      const ::saml2::protocol::ArtifactResponseType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ArtifactResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResponse (::xercesc::DOMDocument& d,
                      const ::saml2::protocol::ArtifactResponseType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::ArtifactResponseType) == typeid (s))
      {
        if (n.name () == L"ArtifactResponse" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ArtifactResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ArtifactResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ArtifactResponse (const ::saml2::protocol::ArtifactResponseType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::ArtifactResponseType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ArtifactResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ArtifactResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::ArtifactResponse (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArtifactResponseType& i)
    {
      e << static_cast< const ::saml2::protocol::StatusResponseType& > (i);

      // any
      //
      if (i.any ())
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*i.any ())), true));
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ArtifactResponseType >
    _xsd_ArtifactResponseType_type_serializer_init (
      L"ArtifactResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    ManageNameIDRequest (::std::ostream& o,
                         const ::saml2::protocol::ManageNameIDRequestType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ManageNameIDRequest (::std::ostream& o,
                         const ::saml2::protocol::ManageNameIDRequestType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDRequest (::std::ostream& o,
                         const ::saml2::protocol::ManageNameIDRequestType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDRequest (::xercesc::XMLFormatTarget& t,
                         const ::saml2::protocol::ManageNameIDRequestType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ManageNameIDRequest (::xercesc::XMLFormatTarget& t,
                         const ::saml2::protocol::ManageNameIDRequestType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDRequest (::xercesc::XMLFormatTarget& t,
                         const ::saml2::protocol::ManageNameIDRequestType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDRequest (::xercesc::DOMDocument& d,
                         const ::saml2::protocol::ManageNameIDRequestType& s,
                         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::ManageNameIDRequestType) == typeid (s))
      {
        if (n.name () == L"ManageNameIDRequest" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ManageNameIDRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ManageNameIDRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ManageNameIDRequest (const ::saml2::protocol::ManageNameIDRequestType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::ManageNameIDRequestType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ManageNameIDRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ManageNameIDRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::ManageNameIDRequest (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ManageNameIDRequestType& i)
    {
      e << static_cast< const ::saml2::protocol::RequestAbstractType& > (i);

      // NameID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          const ManageNameIDRequestType::NameID_type& x (*i.NameID ());
          if (typeid (ManageNameIDRequestType::NameID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // EncryptedID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          const ManageNameIDRequestType::EncryptedID_type& x (*i.EncryptedID ());
          if (typeid (ManageNameIDRequestType::EncryptedID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // NewID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NewID ())
        {
          const ManageNameIDRequestType::NewID_type& x (*i.NewID ());
          if (typeid (ManageNameIDRequestType::NewID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NewID",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NewID",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // NewEncryptedID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NewEncryptedID ())
        {
          const ManageNameIDRequestType::NewEncryptedID_type& x (*i.NewEncryptedID ());
          if (typeid (ManageNameIDRequestType::NewEncryptedID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NewEncryptedID",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NewEncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }

      // Terminate
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Terminate ())
        {
          const ManageNameIDRequestType::Terminate_type& x (*i.Terminate ());
          if (typeid (ManageNameIDRequestType::Terminate_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Terminate",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Terminate",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, x);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ManageNameIDRequestType >
    _xsd_ManageNameIDRequestType_type_serializer_init (
      L"ManageNameIDRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    NewID (::std::ostream& o,
           const ::xml_schema::string& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NewID (::std::ostream& o,
           const ::xml_schema::string& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::error_handler& h,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewID (::std::ostream& o,
           const ::xml_schema::string& s,
           const ::xml_schema::namespace_infomap& m,
           ::xercesc::DOMErrorHandler& h,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewID (::xercesc::XMLFormatTarget& t,
           const ::xml_schema::string& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NewID (::xercesc::XMLFormatTarget& t,
           const ::xml_schema::string& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::error_handler& h,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewID (::xercesc::XMLFormatTarget& t,
           const ::xml_schema::string& s,
           const ::xml_schema::namespace_infomap& m,
           ::xercesc::DOMErrorHandler& h,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewID (::xercesc::DOMDocument& d,
           const ::xml_schema::string& s,
           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"NewID" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NewID",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NewID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NewID (const ::xml_schema::string& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NewID",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NewID",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::NewID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    NewEncryptedID (::std::ostream& o,
                    const ::saml2::assertion::EncryptedElementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewEncryptedID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NewEncryptedID (::std::ostream& o,
                    const ::saml2::assertion::EncryptedElementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewEncryptedID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewEncryptedID (::std::ostream& o,
                    const ::saml2::assertion::EncryptedElementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewEncryptedID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewEncryptedID (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::EncryptedElementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewEncryptedID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NewEncryptedID (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::EncryptedElementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewEncryptedID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewEncryptedID (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::EncryptedElementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NewEncryptedID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NewEncryptedID (::xercesc::DOMDocument& d,
                    const ::saml2::assertion::EncryptedElementType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
      {
        if (n.name () == L"NewEncryptedID" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NewEncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NewEncryptedID",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NewEncryptedID (const ::saml2::assertion::EncryptedElementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NewEncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NewEncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::NewEncryptedID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Terminate (::std::ostream& o,
               const ::saml2::protocol::TerminateType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Terminate (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Terminate (::std::ostream& o,
               const ::saml2::protocol::TerminateType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Terminate (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Terminate (::std::ostream& o,
               const ::saml2::protocol::TerminateType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Terminate (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Terminate (::xercesc::XMLFormatTarget& t,
               const ::saml2::protocol::TerminateType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Terminate (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Terminate (::xercesc::XMLFormatTarget& t,
               const ::saml2::protocol::TerminateType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Terminate (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Terminate (::xercesc::XMLFormatTarget& t,
               const ::saml2::protocol::TerminateType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::Terminate (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Terminate (::xercesc::DOMDocument& d,
               const ::saml2::protocol::TerminateType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::TerminateType) == typeid (s))
      {
        if (n.name () == L"Terminate" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Terminate",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Terminate",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Terminate (const ::saml2::protocol::TerminateType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::TerminateType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Terminate",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Terminate",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::Terminate (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TerminateType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&,const TerminateType&)
    {
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >&,
                const TerminateType&)
    {
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TerminateType >
    _xsd_TerminateType_type_serializer_init (
      L"TerminateType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    ManageNameIDResponse (::std::ostream& o,
                          const ::saml2::protocol::StatusResponseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ManageNameIDResponse (::std::ostream& o,
                          const ::saml2::protocol::StatusResponseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDResponse (::std::ostream& o,
                          const ::saml2::protocol::StatusResponseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDResponse (::xercesc::XMLFormatTarget& t,
                          const ::saml2::protocol::StatusResponseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ManageNameIDResponse (::xercesc::XMLFormatTarget& t,
                          const ::saml2::protocol::StatusResponseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDResponse (::xercesc::XMLFormatTarget& t,
                          const ::saml2::protocol::StatusResponseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::ManageNameIDResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDResponse (::xercesc::DOMDocument& d,
                          const ::saml2::protocol::StatusResponseType& s,
                          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::StatusResponseType) == typeid (s))
      {
        if (n.name () == L"ManageNameIDResponse" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ManageNameIDResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ManageNameIDResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ManageNameIDResponse (const ::saml2::protocol::StatusResponseType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::StatusResponseType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ManageNameIDResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ManageNameIDResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::ManageNameIDResponse (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    LogoutRequest (::std::ostream& o,
                   const ::saml2::protocol::LogoutRequestType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    LogoutRequest (::std::ostream& o,
                   const ::saml2::protocol::LogoutRequestType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutRequest (::std::ostream& o,
                   const ::saml2::protocol::LogoutRequestType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutRequest (::xercesc::XMLFormatTarget& t,
                   const ::saml2::protocol::LogoutRequestType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    LogoutRequest (::xercesc::XMLFormatTarget& t,
                   const ::saml2::protocol::LogoutRequestType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutRequest (::xercesc::XMLFormatTarget& t,
                   const ::saml2::protocol::LogoutRequestType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutRequest (::xercesc::DOMDocument& d,
                   const ::saml2::protocol::LogoutRequestType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::LogoutRequestType) == typeid (s))
      {
        if (n.name () == L"LogoutRequest" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"LogoutRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"LogoutRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    LogoutRequest (const ::saml2::protocol::LogoutRequestType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::LogoutRequestType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"LogoutRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"LogoutRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::LogoutRequest (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LogoutRequestType& i)
    {
      e << static_cast< const ::saml2::protocol::RequestAbstractType& > (i);

      // BaseID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BaseID ())
        {
          const LogoutRequestType::BaseID_type& x (*i.BaseID ());
          if (typeid (LogoutRequestType::BaseID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BaseID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // NameID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          const LogoutRequestType::NameID_type& x (*i.NameID ());
          if (typeid (LogoutRequestType::NameID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // EncryptedID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          const LogoutRequestType::EncryptedID_type& x (*i.EncryptedID ());
          if (typeid (LogoutRequestType::EncryptedID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // SessionIndex
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (LogoutRequestType::SessionIndex_const_iterator
             b (i.SessionIndex ().begin ()), n (i.SessionIndex ().end ());
             b != n; ++b)
        {
          if (typeid (LogoutRequestType::SessionIndex_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SessionIndex",
                L"urn:oasis:names:tc:SAML:2.0:protocol",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"SessionIndex",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              true, true, e, *b);
        }
      }

      // Reason
      //
      if (i.Reason ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Reason",
            e));

        a << *i.Reason ();
      }

      // NotOnOrAfter
      //
      if (i.NotOnOrAfter ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NotOnOrAfter",
            e));

        a << *i.NotOnOrAfter ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, LogoutRequestType >
    _xsd_LogoutRequestType_type_serializer_init (
      L"LogoutRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    SessionIndex (::std::ostream& o,
                  const ::xml_schema::string& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SessionIndex (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SessionIndex (::std::ostream& o,
                  const ::xml_schema::string& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SessionIndex (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SessionIndex (::std::ostream& o,
                  const ::xml_schema::string& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SessionIndex (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SessionIndex (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::string& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SessionIndex (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SessionIndex (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::string& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SessionIndex (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SessionIndex (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::string& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::SessionIndex (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SessionIndex (::xercesc::DOMDocument& d,
                  const ::xml_schema::string& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"SessionIndex" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SessionIndex",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SessionIndex",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SessionIndex (const ::xml_schema::string& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SessionIndex",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SessionIndex",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::SessionIndex (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    LogoutResponse (::std::ostream& o,
                    const ::saml2::protocol::StatusResponseType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    LogoutResponse (::std::ostream& o,
                    const ::saml2::protocol::StatusResponseType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutResponse (::std::ostream& o,
                    const ::saml2::protocol::StatusResponseType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutResponse (::xercesc::XMLFormatTarget& t,
                    const ::saml2::protocol::StatusResponseType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    LogoutResponse (::xercesc::XMLFormatTarget& t,
                    const ::saml2::protocol::StatusResponseType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutResponse (::xercesc::XMLFormatTarget& t,
                    const ::saml2::protocol::StatusResponseType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::LogoutResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    LogoutResponse (::xercesc::DOMDocument& d,
                    const ::saml2::protocol::StatusResponseType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::StatusResponseType) == typeid (s))
      {
        if (n.name () == L"LogoutResponse" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"LogoutResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"LogoutResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    LogoutResponse (const ::saml2::protocol::StatusResponseType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::StatusResponseType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"LogoutResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"LogoutResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::LogoutResponse (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    NameIDMappingRequest (::std::ostream& o,
                          const ::saml2::protocol::NameIDMappingRequestType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDMappingRequest (::std::ostream& o,
                          const ::saml2::protocol::NameIDMappingRequestType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingRequest (::std::ostream& o,
                          const ::saml2::protocol::NameIDMappingRequestType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingRequest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingRequest (::xercesc::XMLFormatTarget& t,
                          const ::saml2::protocol::NameIDMappingRequestType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingRequest (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDMappingRequest (::xercesc::XMLFormatTarget& t,
                          const ::saml2::protocol::NameIDMappingRequestType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingRequest (::xercesc::XMLFormatTarget& t,
                          const ::saml2::protocol::NameIDMappingRequestType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingRequest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingRequest (::xercesc::DOMDocument& d,
                          const ::saml2::protocol::NameIDMappingRequestType& s,
                          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::NameIDMappingRequestType) == typeid (s))
      {
        if (n.name () == L"NameIDMappingRequest" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NameIDMappingRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NameIDMappingRequest",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NameIDMappingRequest (const ::saml2::protocol::NameIDMappingRequestType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::NameIDMappingRequestType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NameIDMappingRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NameIDMappingRequest",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::NameIDMappingRequest (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NameIDMappingRequestType& i)
    {
      e << static_cast< const ::saml2::protocol::RequestAbstractType& > (i);

      // BaseID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BaseID ())
        {
          const NameIDMappingRequestType::BaseID_type& x (*i.BaseID ());
          if (typeid (NameIDMappingRequestType::BaseID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BaseID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // NameID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          const NameIDMappingRequestType::NameID_type& x (*i.NameID ());
          if (typeid (NameIDMappingRequestType::NameID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // EncryptedID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          const NameIDMappingRequestType::EncryptedID_type& x (*i.EncryptedID ());
          if (typeid (NameIDMappingRequestType::EncryptedID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // NameIDPolicy
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const NameIDMappingRequestType::NameIDPolicy_type& x (i.NameIDPolicy ());
        if (typeid (NameIDMappingRequestType::NameIDPolicy_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"NameIDPolicy",
              L"urn:oasis:names:tc:SAML:2.0:protocol",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"NameIDPolicy",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            true, true, e, x);
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NameIDMappingRequestType >
    _xsd_NameIDMappingRequestType_type_serializer_init (
      L"NameIDMappingRequestType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");


    void
    NameIDMappingResponse (::std::ostream& o,
                           const ::saml2::protocol::NameIDMappingResponseType& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDMappingResponse (::std::ostream& o,
                           const ::saml2::protocol::NameIDMappingResponseType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::error_handler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingResponse (::std::ostream& o,
                           const ::saml2::protocol::NameIDMappingResponseType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xercesc::DOMErrorHandler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingResponse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingResponse (::xercesc::XMLFormatTarget& t,
                           const ::saml2::protocol::NameIDMappingResponseType& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingResponse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDMappingResponse (::xercesc::XMLFormatTarget& t,
                           const ::saml2::protocol::NameIDMappingResponseType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::error_handler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingResponse (::xercesc::XMLFormatTarget& t,
                           const ::saml2::protocol::NameIDMappingResponseType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xercesc::DOMErrorHandler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::protocol::NameIDMappingResponse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingResponse (::xercesc::DOMDocument& d,
                           const ::saml2::protocol::NameIDMappingResponseType& s,
                           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::protocol::NameIDMappingResponseType) == typeid (s))
      {
        if (n.name () == L"NameIDMappingResponse" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:protocol")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NameIDMappingResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NameIDMappingResponse",
          L"urn:oasis:names:tc:SAML:2.0:protocol",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NameIDMappingResponse (const ::saml2::protocol::NameIDMappingResponseType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::protocol::NameIDMappingResponseType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NameIDMappingResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NameIDMappingResponse",
            L"urn:oasis:names:tc:SAML:2.0:protocol",
            m, s, f);
        }

        ::saml2::protocol::NameIDMappingResponse (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NameIDMappingResponseType& i)
    {
      e << static_cast< const ::saml2::protocol::StatusResponseType& > (i);

      // NameID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          const NameIDMappingResponseType::NameID_type& x (*i.NameID ());
          if (typeid (NameIDMappingResponseType::NameID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // EncryptedID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          const NameIDMappingResponseType::EncryptedID_type& x (*i.EncryptedID ());
          if (typeid (NameIDMappingResponseType::EncryptedID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NameIDMappingResponseType >
    _xsd_NameIDMappingResponseType_type_serializer_init (
      L"NameIDMappingResponseType",
      L"urn:oasis:names:tc:SAML:2.0:protocol");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

