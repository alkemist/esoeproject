// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "saml2/bindings/saml-schema-metadata-2.0.hxx"

namespace saml2
{
  namespace metadata
  {
    // entityIDType
    // 


    // localizedNameType
    // 

    const localizedNameType::lang_type& localizedNameType::
    lang () const
    {
      return this->lang_.get ();
    }

    localizedNameType::lang_type& localizedNameType::
    lang ()
    {
      return this->lang_.get ();
    }

    void localizedNameType::
    lang (const lang_type& lang)
    {
      this->lang_.set (lang);
    }

    void localizedNameType::
    lang (::std::auto_ptr< lang_type > lang)
    {
      this->lang_.set (lang);
    }


    // localizedURIType
    // 

    const localizedURIType::lang_type& localizedURIType::
    lang () const
    {
      return this->lang_.get ();
    }

    localizedURIType::lang_type& localizedURIType::
    lang ()
    {
      return this->lang_.get ();
    }

    void localizedURIType::
    lang (const lang_type& lang)
    {
      this->lang_.set (lang);
    }

    void localizedURIType::
    lang (::std::auto_ptr< lang_type > lang)
    {
      this->lang_.set (lang);
    }


    // ExtensionsType
    // 

    const ExtensionsType::any_sequence& ExtensionsType::
    any () const
    {
      return this->any_;
    }

    ExtensionsType::any_sequence& ExtensionsType::
    any ()
    {
      return this->any_;
    }

    void ExtensionsType::
    any (const any_sequence& any)
    {
      this->any_ = any;
    }

    const ::xercesc::DOMDocument& ExtensionsType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& ExtensionsType::
    dom_document ()
    {
      return *dom_document_;
    }


    // EndpointType
    // 

    const EndpointType::any_sequence& EndpointType::
    any () const
    {
      return this->any_;
    }

    EndpointType::any_sequence& EndpointType::
    any ()
    {
      return this->any_;
    }

    void EndpointType::
    any (const any_sequence& any)
    {
      this->any_ = any;
    }

    const EndpointType::Binding_type& EndpointType::
    Binding () const
    {
      return this->Binding_.get ();
    }

    EndpointType::Binding_type& EndpointType::
    Binding ()
    {
      return this->Binding_.get ();
    }

    void EndpointType::
    Binding (const Binding_type& Binding)
    {
      this->Binding_.set (Binding);
    }

    void EndpointType::
    Binding (::std::auto_ptr< Binding_type > Binding)
    {
      this->Binding_.set (Binding);
    }

    const EndpointType::Location_type& EndpointType::
    Location () const
    {
      return this->Location_.get ();
    }

    EndpointType::Location_type& EndpointType::
    Location ()
    {
      return this->Location_.get ();
    }

    void EndpointType::
    Location (const Location_type& Location)
    {
      this->Location_.set (Location);
    }

    void EndpointType::
    Location (::std::auto_ptr< Location_type > Location)
    {
      this->Location_.set (Location);
    }

    const EndpointType::ResponseLocation_optional& EndpointType::
    ResponseLocation () const
    {
      return this->ResponseLocation_;
    }

    EndpointType::ResponseLocation_optional& EndpointType::
    ResponseLocation ()
    {
      return this->ResponseLocation_;
    }

    void EndpointType::
    ResponseLocation (const ResponseLocation_type& ResponseLocation)
    {
      this->ResponseLocation_.set (ResponseLocation);
    }

    void EndpointType::
    ResponseLocation (const ResponseLocation_optional& ResponseLocation)
    {
      this->ResponseLocation_ = ResponseLocation;
    }

    void EndpointType::
    ResponseLocation (::std::auto_ptr< ResponseLocation_type > ResponseLocation)
    {
      this->ResponseLocation_.set (ResponseLocation);
    }

    const EndpointType::any_attribute_set& EndpointType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    EndpointType::any_attribute_set& EndpointType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void EndpointType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& EndpointType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& EndpointType::
    dom_document ()
    {
      return *dom_document_;
    }


    // IndexedEndpointType
    // 

    const IndexedEndpointType::index_type& IndexedEndpointType::
    index () const
    {
      return this->index_.get ();
    }

    IndexedEndpointType::index_type& IndexedEndpointType::
    index ()
    {
      return this->index_.get ();
    }

    void IndexedEndpointType::
    index (const index_type& index)
    {
      this->index_.set (index);
    }

    const IndexedEndpointType::isDefault_optional& IndexedEndpointType::
    isDefault () const
    {
      return this->isDefault_;
    }

    IndexedEndpointType::isDefault_optional& IndexedEndpointType::
    isDefault ()
    {
      return this->isDefault_;
    }

    void IndexedEndpointType::
    isDefault (const isDefault_type& isDefault)
    {
      this->isDefault_.set (isDefault);
    }

    void IndexedEndpointType::
    isDefault (const isDefault_optional& isDefault)
    {
      this->isDefault_ = isDefault;
    }


    // EntitiesDescriptorType
    // 

    const EntitiesDescriptorType::Signature_optional& EntitiesDescriptorType::
    Signature () const
    {
      return this->Signature_;
    }

    EntitiesDescriptorType::Signature_optional& EntitiesDescriptorType::
    Signature ()
    {
      return this->Signature_;
    }

    void EntitiesDescriptorType::
    Signature (const Signature_type& Signature)
    {
      this->Signature_.set (Signature);
    }

    void EntitiesDescriptorType::
    Signature (const Signature_optional& Signature)
    {
      this->Signature_ = Signature;
    }

    void EntitiesDescriptorType::
    Signature (::std::auto_ptr< Signature_type > Signature)
    {
      this->Signature_.set (Signature);
    }

    const EntitiesDescriptorType::Extensions_optional& EntitiesDescriptorType::
    Extensions () const
    {
      return this->Extensions_;
    }

    EntitiesDescriptorType::Extensions_optional& EntitiesDescriptorType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void EntitiesDescriptorType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void EntitiesDescriptorType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void EntitiesDescriptorType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const EntitiesDescriptorType::EntityDescriptor_sequence& EntitiesDescriptorType::
    EntityDescriptor () const
    {
      return this->EntityDescriptor_;
    }

    EntitiesDescriptorType::EntityDescriptor_sequence& EntitiesDescriptorType::
    EntityDescriptor ()
    {
      return this->EntityDescriptor_;
    }

    void EntitiesDescriptorType::
    EntityDescriptor (const EntityDescriptor_sequence& EntityDescriptor)
    {
      this->EntityDescriptor_ = EntityDescriptor;
    }

    const EntitiesDescriptorType::EntitiesDescriptor_sequence& EntitiesDescriptorType::
    EntitiesDescriptor () const
    {
      return this->EntitiesDescriptor_;
    }

    EntitiesDescriptorType::EntitiesDescriptor_sequence& EntitiesDescriptorType::
    EntitiesDescriptor ()
    {
      return this->EntitiesDescriptor_;
    }

    void EntitiesDescriptorType::
    EntitiesDescriptor (const EntitiesDescriptor_sequence& EntitiesDescriptor)
    {
      this->EntitiesDescriptor_ = EntitiesDescriptor;
    }

    const EntitiesDescriptorType::validUntil_optional& EntitiesDescriptorType::
    validUntil () const
    {
      return this->validUntil_;
    }

    EntitiesDescriptorType::validUntil_optional& EntitiesDescriptorType::
    validUntil ()
    {
      return this->validUntil_;
    }

    void EntitiesDescriptorType::
    validUntil (const validUntil_type& validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    void EntitiesDescriptorType::
    validUntil (const validUntil_optional& validUntil)
    {
      this->validUntil_ = validUntil;
    }

    void EntitiesDescriptorType::
    validUntil (::std::auto_ptr< validUntil_type > validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    const EntitiesDescriptorType::cacheDuration_optional& EntitiesDescriptorType::
    cacheDuration () const
    {
      return this->cacheDuration_;
    }

    EntitiesDescriptorType::cacheDuration_optional& EntitiesDescriptorType::
    cacheDuration ()
    {
      return this->cacheDuration_;
    }

    void EntitiesDescriptorType::
    cacheDuration (const cacheDuration_type& cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    void EntitiesDescriptorType::
    cacheDuration (const cacheDuration_optional& cacheDuration)
    {
      this->cacheDuration_ = cacheDuration;
    }

    void EntitiesDescriptorType::
    cacheDuration (::std::auto_ptr< cacheDuration_type > cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    const EntitiesDescriptorType::ID_optional& EntitiesDescriptorType::
    ID () const
    {
      return this->ID_;
    }

    EntitiesDescriptorType::ID_optional& EntitiesDescriptorType::
    ID ()
    {
      return this->ID_;
    }

    void EntitiesDescriptorType::
    ID (const ID_type& ID)
    {
      this->ID_.set (ID);
    }

    void EntitiesDescriptorType::
    ID (const ID_optional& ID)
    {
      this->ID_ = ID;
    }

    void EntitiesDescriptorType::
    ID (::std::auto_ptr< ID_type > ID)
    {
      this->ID_.set (ID);
    }

    const EntitiesDescriptorType::Name_optional& EntitiesDescriptorType::
    Name () const
    {
      return this->Name_;
    }

    EntitiesDescriptorType::Name_optional& EntitiesDescriptorType::
    Name ()
    {
      return this->Name_;
    }

    void EntitiesDescriptorType::
    Name (const Name_type& Name)
    {
      this->Name_.set (Name);
    }

    void EntitiesDescriptorType::
    Name (const Name_optional& Name)
    {
      this->Name_ = Name;
    }

    void EntitiesDescriptorType::
    Name (::std::auto_ptr< Name_type > Name)
    {
      this->Name_.set (Name);
    }


    // EntityDescriptorType
    // 

    const EntityDescriptorType::Signature_optional& EntityDescriptorType::
    Signature () const
    {
      return this->Signature_;
    }

    EntityDescriptorType::Signature_optional& EntityDescriptorType::
    Signature ()
    {
      return this->Signature_;
    }

    void EntityDescriptorType::
    Signature (const Signature_type& Signature)
    {
      this->Signature_.set (Signature);
    }

    void EntityDescriptorType::
    Signature (const Signature_optional& Signature)
    {
      this->Signature_ = Signature;
    }

    void EntityDescriptorType::
    Signature (::std::auto_ptr< Signature_type > Signature)
    {
      this->Signature_.set (Signature);
    }

    const EntityDescriptorType::Extensions_optional& EntityDescriptorType::
    Extensions () const
    {
      return this->Extensions_;
    }

    EntityDescriptorType::Extensions_optional& EntityDescriptorType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void EntityDescriptorType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void EntityDescriptorType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void EntityDescriptorType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const EntityDescriptorType::RoleDescriptor_sequence& EntityDescriptorType::
    RoleDescriptor () const
    {
      return this->RoleDescriptor_;
    }

    EntityDescriptorType::RoleDescriptor_sequence& EntityDescriptorType::
    RoleDescriptor ()
    {
      return this->RoleDescriptor_;
    }

    void EntityDescriptorType::
    RoleDescriptor (const RoleDescriptor_sequence& RoleDescriptor)
    {
      this->RoleDescriptor_ = RoleDescriptor;
    }

    const EntityDescriptorType::IDPSSODescriptor_sequence& EntityDescriptorType::
    IDPSSODescriptor () const
    {
      return this->IDPSSODescriptor_;
    }

    EntityDescriptorType::IDPSSODescriptor_sequence& EntityDescriptorType::
    IDPSSODescriptor ()
    {
      return this->IDPSSODescriptor_;
    }

    void EntityDescriptorType::
    IDPSSODescriptor (const IDPSSODescriptor_sequence& IDPSSODescriptor)
    {
      this->IDPSSODescriptor_ = IDPSSODescriptor;
    }

    const EntityDescriptorType::SPSSODescriptor_sequence& EntityDescriptorType::
    SPSSODescriptor () const
    {
      return this->SPSSODescriptor_;
    }

    EntityDescriptorType::SPSSODescriptor_sequence& EntityDescriptorType::
    SPSSODescriptor ()
    {
      return this->SPSSODescriptor_;
    }

    void EntityDescriptorType::
    SPSSODescriptor (const SPSSODescriptor_sequence& SPSSODescriptor)
    {
      this->SPSSODescriptor_ = SPSSODescriptor;
    }

    const EntityDescriptorType::AuthnAuthorityDescriptor_sequence& EntityDescriptorType::
    AuthnAuthorityDescriptor () const
    {
      return this->AuthnAuthorityDescriptor_;
    }

    EntityDescriptorType::AuthnAuthorityDescriptor_sequence& EntityDescriptorType::
    AuthnAuthorityDescriptor ()
    {
      return this->AuthnAuthorityDescriptor_;
    }

    void EntityDescriptorType::
    AuthnAuthorityDescriptor (const AuthnAuthorityDescriptor_sequence& AuthnAuthorityDescriptor)
    {
      this->AuthnAuthorityDescriptor_ = AuthnAuthorityDescriptor;
    }

    const EntityDescriptorType::AttributeAuthorityDescriptor_sequence& EntityDescriptorType::
    AttributeAuthorityDescriptor () const
    {
      return this->AttributeAuthorityDescriptor_;
    }

    EntityDescriptorType::AttributeAuthorityDescriptor_sequence& EntityDescriptorType::
    AttributeAuthorityDescriptor ()
    {
      return this->AttributeAuthorityDescriptor_;
    }

    void EntityDescriptorType::
    AttributeAuthorityDescriptor (const AttributeAuthorityDescriptor_sequence& AttributeAuthorityDescriptor)
    {
      this->AttributeAuthorityDescriptor_ = AttributeAuthorityDescriptor;
    }

    const EntityDescriptorType::PDPDescriptor_sequence& EntityDescriptorType::
    PDPDescriptor () const
    {
      return this->PDPDescriptor_;
    }

    EntityDescriptorType::PDPDescriptor_sequence& EntityDescriptorType::
    PDPDescriptor ()
    {
      return this->PDPDescriptor_;
    }

    void EntityDescriptorType::
    PDPDescriptor (const PDPDescriptor_sequence& PDPDescriptor)
    {
      this->PDPDescriptor_ = PDPDescriptor;
    }

    const EntityDescriptorType::AffiliationDescriptor_optional& EntityDescriptorType::
    AffiliationDescriptor () const
    {
      return this->AffiliationDescriptor_;
    }

    EntityDescriptorType::AffiliationDescriptor_optional& EntityDescriptorType::
    AffiliationDescriptor ()
    {
      return this->AffiliationDescriptor_;
    }

    void EntityDescriptorType::
    AffiliationDescriptor (const AffiliationDescriptor_type& AffiliationDescriptor)
    {
      this->AffiliationDescriptor_.set (AffiliationDescriptor);
    }

    void EntityDescriptorType::
    AffiliationDescriptor (const AffiliationDescriptor_optional& AffiliationDescriptor)
    {
      this->AffiliationDescriptor_ = AffiliationDescriptor;
    }

    void EntityDescriptorType::
    AffiliationDescriptor (::std::auto_ptr< AffiliationDescriptor_type > AffiliationDescriptor)
    {
      this->AffiliationDescriptor_.set (AffiliationDescriptor);
    }

    const EntityDescriptorType::Organization_optional& EntityDescriptorType::
    Organization () const
    {
      return this->Organization_;
    }

    EntityDescriptorType::Organization_optional& EntityDescriptorType::
    Organization ()
    {
      return this->Organization_;
    }

    void EntityDescriptorType::
    Organization (const Organization_type& Organization)
    {
      this->Organization_.set (Organization);
    }

    void EntityDescriptorType::
    Organization (const Organization_optional& Organization)
    {
      this->Organization_ = Organization;
    }

    void EntityDescriptorType::
    Organization (::std::auto_ptr< Organization_type > Organization)
    {
      this->Organization_.set (Organization);
    }

    const EntityDescriptorType::ContactPerson_sequence& EntityDescriptorType::
    ContactPerson () const
    {
      return this->ContactPerson_;
    }

    EntityDescriptorType::ContactPerson_sequence& EntityDescriptorType::
    ContactPerson ()
    {
      return this->ContactPerson_;
    }

    void EntityDescriptorType::
    ContactPerson (const ContactPerson_sequence& ContactPerson)
    {
      this->ContactPerson_ = ContactPerson;
    }

    const EntityDescriptorType::AdditionalMetadataLocation_sequence& EntityDescriptorType::
    AdditionalMetadataLocation () const
    {
      return this->AdditionalMetadataLocation_;
    }

    EntityDescriptorType::AdditionalMetadataLocation_sequence& EntityDescriptorType::
    AdditionalMetadataLocation ()
    {
      return this->AdditionalMetadataLocation_;
    }

    void EntityDescriptorType::
    AdditionalMetadataLocation (const AdditionalMetadataLocation_sequence& AdditionalMetadataLocation)
    {
      this->AdditionalMetadataLocation_ = AdditionalMetadataLocation;
    }

    const EntityDescriptorType::entityID_type& EntityDescriptorType::
    entityID () const
    {
      return this->entityID_.get ();
    }

    EntityDescriptorType::entityID_type& EntityDescriptorType::
    entityID ()
    {
      return this->entityID_.get ();
    }

    void EntityDescriptorType::
    entityID (const entityID_type& entityID)
    {
      this->entityID_.set (entityID);
    }

    void EntityDescriptorType::
    entityID (::std::auto_ptr< entityID_type > entityID)
    {
      this->entityID_.set (entityID);
    }

    const EntityDescriptorType::validUntil_optional& EntityDescriptorType::
    validUntil () const
    {
      return this->validUntil_;
    }

    EntityDescriptorType::validUntil_optional& EntityDescriptorType::
    validUntil ()
    {
      return this->validUntil_;
    }

    void EntityDescriptorType::
    validUntil (const validUntil_type& validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    void EntityDescriptorType::
    validUntil (const validUntil_optional& validUntil)
    {
      this->validUntil_ = validUntil;
    }

    void EntityDescriptorType::
    validUntil (::std::auto_ptr< validUntil_type > validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    const EntityDescriptorType::cacheDuration_optional& EntityDescriptorType::
    cacheDuration () const
    {
      return this->cacheDuration_;
    }

    EntityDescriptorType::cacheDuration_optional& EntityDescriptorType::
    cacheDuration ()
    {
      return this->cacheDuration_;
    }

    void EntityDescriptorType::
    cacheDuration (const cacheDuration_type& cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    void EntityDescriptorType::
    cacheDuration (const cacheDuration_optional& cacheDuration)
    {
      this->cacheDuration_ = cacheDuration;
    }

    void EntityDescriptorType::
    cacheDuration (::std::auto_ptr< cacheDuration_type > cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    const EntityDescriptorType::ID_optional& EntityDescriptorType::
    ID () const
    {
      return this->ID_;
    }

    EntityDescriptorType::ID_optional& EntityDescriptorType::
    ID ()
    {
      return this->ID_;
    }

    void EntityDescriptorType::
    ID (const ID_type& ID)
    {
      this->ID_.set (ID);
    }

    void EntityDescriptorType::
    ID (const ID_optional& ID)
    {
      this->ID_ = ID;
    }

    void EntityDescriptorType::
    ID (::std::auto_ptr< ID_type > ID)
    {
      this->ID_.set (ID);
    }

    const EntityDescriptorType::any_attribute_set& EntityDescriptorType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    EntityDescriptorType::any_attribute_set& EntityDescriptorType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void EntityDescriptorType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& EntityDescriptorType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& EntityDescriptorType::
    dom_document ()
    {
      return *dom_document_;
    }


    // OrganizationType
    // 

    const OrganizationType::Extensions_optional& OrganizationType::
    Extensions () const
    {
      return this->Extensions_;
    }

    OrganizationType::Extensions_optional& OrganizationType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void OrganizationType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void OrganizationType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void OrganizationType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const OrganizationType::OrganizationName_sequence& OrganizationType::
    OrganizationName () const
    {
      return this->OrganizationName_;
    }

    OrganizationType::OrganizationName_sequence& OrganizationType::
    OrganizationName ()
    {
      return this->OrganizationName_;
    }

    void OrganizationType::
    OrganizationName (const OrganizationName_sequence& OrganizationName)
    {
      this->OrganizationName_ = OrganizationName;
    }

    const OrganizationType::OrganizationDisplayName_sequence& OrganizationType::
    OrganizationDisplayName () const
    {
      return this->OrganizationDisplayName_;
    }

    OrganizationType::OrganizationDisplayName_sequence& OrganizationType::
    OrganizationDisplayName ()
    {
      return this->OrganizationDisplayName_;
    }

    void OrganizationType::
    OrganizationDisplayName (const OrganizationDisplayName_sequence& OrganizationDisplayName)
    {
      this->OrganizationDisplayName_ = OrganizationDisplayName;
    }

    const OrganizationType::OrganizationURL_sequence& OrganizationType::
    OrganizationURL () const
    {
      return this->OrganizationURL_;
    }

    OrganizationType::OrganizationURL_sequence& OrganizationType::
    OrganizationURL ()
    {
      return this->OrganizationURL_;
    }

    void OrganizationType::
    OrganizationURL (const OrganizationURL_sequence& OrganizationURL)
    {
      this->OrganizationURL_ = OrganizationURL;
    }

    const OrganizationType::any_attribute_set& OrganizationType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    OrganizationType::any_attribute_set& OrganizationType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void OrganizationType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& OrganizationType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& OrganizationType::
    dom_document ()
    {
      return *dom_document_;
    }


    // ContactType
    // 

    const ContactType::Extensions_optional& ContactType::
    Extensions () const
    {
      return this->Extensions_;
    }

    ContactType::Extensions_optional& ContactType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void ContactType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void ContactType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void ContactType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const ContactType::Company_optional& ContactType::
    Company () const
    {
      return this->Company_;
    }

    ContactType::Company_optional& ContactType::
    Company ()
    {
      return this->Company_;
    }

    void ContactType::
    Company (const Company_type& Company)
    {
      this->Company_.set (Company);
    }

    void ContactType::
    Company (const Company_optional& Company)
    {
      this->Company_ = Company;
    }

    void ContactType::
    Company (::std::auto_ptr< Company_type > Company)
    {
      this->Company_.set (Company);
    }

    const ContactType::GivenName_optional& ContactType::
    GivenName () const
    {
      return this->GivenName_;
    }

    ContactType::GivenName_optional& ContactType::
    GivenName ()
    {
      return this->GivenName_;
    }

    void ContactType::
    GivenName (const GivenName_type& GivenName)
    {
      this->GivenName_.set (GivenName);
    }

    void ContactType::
    GivenName (const GivenName_optional& GivenName)
    {
      this->GivenName_ = GivenName;
    }

    void ContactType::
    GivenName (::std::auto_ptr< GivenName_type > GivenName)
    {
      this->GivenName_.set (GivenName);
    }

    const ContactType::SurName_optional& ContactType::
    SurName () const
    {
      return this->SurName_;
    }

    ContactType::SurName_optional& ContactType::
    SurName ()
    {
      return this->SurName_;
    }

    void ContactType::
    SurName (const SurName_type& SurName)
    {
      this->SurName_.set (SurName);
    }

    void ContactType::
    SurName (const SurName_optional& SurName)
    {
      this->SurName_ = SurName;
    }

    void ContactType::
    SurName (::std::auto_ptr< SurName_type > SurName)
    {
      this->SurName_.set (SurName);
    }

    const ContactType::EmailAddress_sequence& ContactType::
    EmailAddress () const
    {
      return this->EmailAddress_;
    }

    ContactType::EmailAddress_sequence& ContactType::
    EmailAddress ()
    {
      return this->EmailAddress_;
    }

    void ContactType::
    EmailAddress (const EmailAddress_sequence& EmailAddress)
    {
      this->EmailAddress_ = EmailAddress;
    }

    const ContactType::TelephoneNumber_sequence& ContactType::
    TelephoneNumber () const
    {
      return this->TelephoneNumber_;
    }

    ContactType::TelephoneNumber_sequence& ContactType::
    TelephoneNumber ()
    {
      return this->TelephoneNumber_;
    }

    void ContactType::
    TelephoneNumber (const TelephoneNumber_sequence& TelephoneNumber)
    {
      this->TelephoneNumber_ = TelephoneNumber;
    }

    const ContactType::contactType_type& ContactType::
    contactType () const
    {
      return this->contactType_.get ();
    }

    ContactType::contactType_type& ContactType::
    contactType ()
    {
      return this->contactType_.get ();
    }

    void ContactType::
    contactType (const contactType_type& contactType)
    {
      this->contactType_.set (contactType);
    }

    void ContactType::
    contactType (::std::auto_ptr< contactType_type > contactType)
    {
      this->contactType_.set (contactType);
    }

    const ContactType::any_attribute_set& ContactType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    ContactType::any_attribute_set& ContactType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void ContactType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& ContactType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& ContactType::
    dom_document ()
    {
      return *dom_document_;
    }


    // ContactTypeType
    // 

    ContactTypeType::
    ContactTypeType ()
    : ::xml_schema::string ()
    {
    }

    ContactTypeType::
    ContactTypeType (value v)
    : ::xml_schema::string (_xsd_ContactTypeType_literals_[v])
    {
    }

    ContactTypeType::
    ContactTypeType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ContactTypeType::
    ContactTypeType (const ContactTypeType& v,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ContactTypeType& ContactTypeType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ContactTypeType_literals_[v]);

      return *this;
    }


    // AdditionalMetadataLocationType
    // 

    const AdditionalMetadataLocationType::namespace__type& AdditionalMetadataLocationType::
    namespace_ () const
    {
      return this->namespace__.get ();
    }

    AdditionalMetadataLocationType::namespace__type& AdditionalMetadataLocationType::
    namespace_ ()
    {
      return this->namespace__.get ();
    }

    void AdditionalMetadataLocationType::
    namespace_ (const namespace__type& namespace_)
    {
      this->namespace__.set (namespace_);
    }

    void AdditionalMetadataLocationType::
    namespace_ (::std::auto_ptr< namespace__type > namespace_)
    {
      this->namespace__.set (namespace_);
    }


    // RoleDescriptorType
    // 

    const RoleDescriptorType::Signature_optional& RoleDescriptorType::
    Signature () const
    {
      return this->Signature_;
    }

    RoleDescriptorType::Signature_optional& RoleDescriptorType::
    Signature ()
    {
      return this->Signature_;
    }

    void RoleDescriptorType::
    Signature (const Signature_type& Signature)
    {
      this->Signature_.set (Signature);
    }

    void RoleDescriptorType::
    Signature (const Signature_optional& Signature)
    {
      this->Signature_ = Signature;
    }

    void RoleDescriptorType::
    Signature (::std::auto_ptr< Signature_type > Signature)
    {
      this->Signature_.set (Signature);
    }

    const RoleDescriptorType::Extensions_optional& RoleDescriptorType::
    Extensions () const
    {
      return this->Extensions_;
    }

    RoleDescriptorType::Extensions_optional& RoleDescriptorType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void RoleDescriptorType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void RoleDescriptorType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void RoleDescriptorType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const RoleDescriptorType::KeyDescriptor_sequence& RoleDescriptorType::
    KeyDescriptor () const
    {
      return this->KeyDescriptor_;
    }

    RoleDescriptorType::KeyDescriptor_sequence& RoleDescriptorType::
    KeyDescriptor ()
    {
      return this->KeyDescriptor_;
    }

    void RoleDescriptorType::
    KeyDescriptor (const KeyDescriptor_sequence& KeyDescriptor)
    {
      this->KeyDescriptor_ = KeyDescriptor;
    }

    const RoleDescriptorType::Organization_optional& RoleDescriptorType::
    Organization () const
    {
      return this->Organization_;
    }

    RoleDescriptorType::Organization_optional& RoleDescriptorType::
    Organization ()
    {
      return this->Organization_;
    }

    void RoleDescriptorType::
    Organization (const Organization_type& Organization)
    {
      this->Organization_.set (Organization);
    }

    void RoleDescriptorType::
    Organization (const Organization_optional& Organization)
    {
      this->Organization_ = Organization;
    }

    void RoleDescriptorType::
    Organization (::std::auto_ptr< Organization_type > Organization)
    {
      this->Organization_.set (Organization);
    }

    const RoleDescriptorType::ContactPerson_sequence& RoleDescriptorType::
    ContactPerson () const
    {
      return this->ContactPerson_;
    }

    RoleDescriptorType::ContactPerson_sequence& RoleDescriptorType::
    ContactPerson ()
    {
      return this->ContactPerson_;
    }

    void RoleDescriptorType::
    ContactPerson (const ContactPerson_sequence& ContactPerson)
    {
      this->ContactPerson_ = ContactPerson;
    }

    const RoleDescriptorType::ID_optional& RoleDescriptorType::
    ID () const
    {
      return this->ID_;
    }

    RoleDescriptorType::ID_optional& RoleDescriptorType::
    ID ()
    {
      return this->ID_;
    }

    void RoleDescriptorType::
    ID (const ID_type& ID)
    {
      this->ID_.set (ID);
    }

    void RoleDescriptorType::
    ID (const ID_optional& ID)
    {
      this->ID_ = ID;
    }

    void RoleDescriptorType::
    ID (::std::auto_ptr< ID_type > ID)
    {
      this->ID_.set (ID);
    }

    const RoleDescriptorType::validUntil_optional& RoleDescriptorType::
    validUntil () const
    {
      return this->validUntil_;
    }

    RoleDescriptorType::validUntil_optional& RoleDescriptorType::
    validUntil ()
    {
      return this->validUntil_;
    }

    void RoleDescriptorType::
    validUntil (const validUntil_type& validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    void RoleDescriptorType::
    validUntil (const validUntil_optional& validUntil)
    {
      this->validUntil_ = validUntil;
    }

    void RoleDescriptorType::
    validUntil (::std::auto_ptr< validUntil_type > validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    const RoleDescriptorType::cacheDuration_optional& RoleDescriptorType::
    cacheDuration () const
    {
      return this->cacheDuration_;
    }

    RoleDescriptorType::cacheDuration_optional& RoleDescriptorType::
    cacheDuration ()
    {
      return this->cacheDuration_;
    }

    void RoleDescriptorType::
    cacheDuration (const cacheDuration_type& cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    void RoleDescriptorType::
    cacheDuration (const cacheDuration_optional& cacheDuration)
    {
      this->cacheDuration_ = cacheDuration;
    }

    void RoleDescriptorType::
    cacheDuration (::std::auto_ptr< cacheDuration_type > cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    const RoleDescriptorType::protocolSupportEnumeration_type& RoleDescriptorType::
    protocolSupportEnumeration () const
    {
      return this->protocolSupportEnumeration_.get ();
    }

    RoleDescriptorType::protocolSupportEnumeration_type& RoleDescriptorType::
    protocolSupportEnumeration ()
    {
      return this->protocolSupportEnumeration_.get ();
    }

    void RoleDescriptorType::
    protocolSupportEnumeration (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    {
      this->protocolSupportEnumeration_.set (protocolSupportEnumeration);
    }

    void RoleDescriptorType::
    protocolSupportEnumeration (::std::auto_ptr< protocolSupportEnumeration_type > protocolSupportEnumeration)
    {
      this->protocolSupportEnumeration_.set (protocolSupportEnumeration);
    }

    const RoleDescriptorType::errorURL_optional& RoleDescriptorType::
    errorURL () const
    {
      return this->errorURL_;
    }

    RoleDescriptorType::errorURL_optional& RoleDescriptorType::
    errorURL ()
    {
      return this->errorURL_;
    }

    void RoleDescriptorType::
    errorURL (const errorURL_type& errorURL)
    {
      this->errorURL_.set (errorURL);
    }

    void RoleDescriptorType::
    errorURL (const errorURL_optional& errorURL)
    {
      this->errorURL_ = errorURL;
    }

    void RoleDescriptorType::
    errorURL (::std::auto_ptr< errorURL_type > errorURL)
    {
      this->errorURL_.set (errorURL);
    }

    const RoleDescriptorType::any_attribute_set& RoleDescriptorType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    RoleDescriptorType::any_attribute_set& RoleDescriptorType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void RoleDescriptorType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& RoleDescriptorType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& RoleDescriptorType::
    dom_document ()
    {
      return *dom_document_;
    }


    // anyURIListType
    //

    anyURIListType::
    anyURIListType ()
    {
    }

    anyURIListType::
    anyURIListType (const anyURIListType& o,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (o, f, c)
    {
    }

    // KeyDescriptorType
    // 

    const KeyDescriptorType::KeyInfo_type& KeyDescriptorType::
    KeyInfo () const
    {
      return this->KeyInfo_.get ();
    }

    KeyDescriptorType::KeyInfo_type& KeyDescriptorType::
    KeyInfo ()
    {
      return this->KeyInfo_.get ();
    }

    void KeyDescriptorType::
    KeyInfo (const KeyInfo_type& KeyInfo)
    {
      this->KeyInfo_.set (KeyInfo);
    }

    void KeyDescriptorType::
    KeyInfo (::std::auto_ptr< KeyInfo_type > KeyInfo)
    {
      this->KeyInfo_.set (KeyInfo);
    }

    const KeyDescriptorType::EncryptionMethod_sequence& KeyDescriptorType::
    EncryptionMethod () const
    {
      return this->EncryptionMethod_;
    }

    KeyDescriptorType::EncryptionMethod_sequence& KeyDescriptorType::
    EncryptionMethod ()
    {
      return this->EncryptionMethod_;
    }

    void KeyDescriptorType::
    EncryptionMethod (const EncryptionMethod_sequence& EncryptionMethod)
    {
      this->EncryptionMethod_ = EncryptionMethod;
    }

    const KeyDescriptorType::use_optional& KeyDescriptorType::
    use () const
    {
      return this->use_;
    }

    KeyDescriptorType::use_optional& KeyDescriptorType::
    use ()
    {
      return this->use_;
    }

    void KeyDescriptorType::
    use (const use_type& use)
    {
      this->use_.set (use);
    }

    void KeyDescriptorType::
    use (const use_optional& use)
    {
      this->use_ = use;
    }

    void KeyDescriptorType::
    use (::std::auto_ptr< use_type > use)
    {
      this->use_.set (use);
    }


    // KeyTypes
    // 

    KeyTypes::
    KeyTypes ()
    : ::xml_schema::string ()
    {
    }

    KeyTypes::
    KeyTypes (value v)
    : ::xml_schema::string (_xsd_KeyTypes_literals_[v])
    {
    }

    KeyTypes::
    KeyTypes (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    KeyTypes::
    KeyTypes (const KeyTypes& v,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    KeyTypes& KeyTypes::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_KeyTypes_literals_[v]);

      return *this;
    }


    // SSODescriptorType
    // 

    const SSODescriptorType::ArtifactResolutionService_sequence& SSODescriptorType::
    ArtifactResolutionService () const
    {
      return this->ArtifactResolutionService_;
    }

    SSODescriptorType::ArtifactResolutionService_sequence& SSODescriptorType::
    ArtifactResolutionService ()
    {
      return this->ArtifactResolutionService_;
    }

    void SSODescriptorType::
    ArtifactResolutionService (const ArtifactResolutionService_sequence& ArtifactResolutionService)
    {
      this->ArtifactResolutionService_ = ArtifactResolutionService;
    }

    const SSODescriptorType::SingleLogoutService_sequence& SSODescriptorType::
    SingleLogoutService () const
    {
      return this->SingleLogoutService_;
    }

    SSODescriptorType::SingleLogoutService_sequence& SSODescriptorType::
    SingleLogoutService ()
    {
      return this->SingleLogoutService_;
    }

    void SSODescriptorType::
    SingleLogoutService (const SingleLogoutService_sequence& SingleLogoutService)
    {
      this->SingleLogoutService_ = SingleLogoutService;
    }

    const SSODescriptorType::ManageNameIDService_sequence& SSODescriptorType::
    ManageNameIDService () const
    {
      return this->ManageNameIDService_;
    }

    SSODescriptorType::ManageNameIDService_sequence& SSODescriptorType::
    ManageNameIDService ()
    {
      return this->ManageNameIDService_;
    }

    void SSODescriptorType::
    ManageNameIDService (const ManageNameIDService_sequence& ManageNameIDService)
    {
      this->ManageNameIDService_ = ManageNameIDService;
    }

    const SSODescriptorType::NameIDFormat_sequence& SSODescriptorType::
    NameIDFormat () const
    {
      return this->NameIDFormat_;
    }

    SSODescriptorType::NameIDFormat_sequence& SSODescriptorType::
    NameIDFormat ()
    {
      return this->NameIDFormat_;
    }

    void SSODescriptorType::
    NameIDFormat (const NameIDFormat_sequence& NameIDFormat)
    {
      this->NameIDFormat_ = NameIDFormat;
    }


    // IDPSSODescriptorType
    // 

    const IDPSSODescriptorType::SingleSignOnService_sequence& IDPSSODescriptorType::
    SingleSignOnService () const
    {
      return this->SingleSignOnService_;
    }

    IDPSSODescriptorType::SingleSignOnService_sequence& IDPSSODescriptorType::
    SingleSignOnService ()
    {
      return this->SingleSignOnService_;
    }

    void IDPSSODescriptorType::
    SingleSignOnService (const SingleSignOnService_sequence& SingleSignOnService)
    {
      this->SingleSignOnService_ = SingleSignOnService;
    }

    const IDPSSODescriptorType::NameIDMappingService_sequence& IDPSSODescriptorType::
    NameIDMappingService () const
    {
      return this->NameIDMappingService_;
    }

    IDPSSODescriptorType::NameIDMappingService_sequence& IDPSSODescriptorType::
    NameIDMappingService ()
    {
      return this->NameIDMappingService_;
    }

    void IDPSSODescriptorType::
    NameIDMappingService (const NameIDMappingService_sequence& NameIDMappingService)
    {
      this->NameIDMappingService_ = NameIDMappingService;
    }

    const IDPSSODescriptorType::AssertionIDRequestService_sequence& IDPSSODescriptorType::
    AssertionIDRequestService () const
    {
      return this->AssertionIDRequestService_;
    }

    IDPSSODescriptorType::AssertionIDRequestService_sequence& IDPSSODescriptorType::
    AssertionIDRequestService ()
    {
      return this->AssertionIDRequestService_;
    }

    void IDPSSODescriptorType::
    AssertionIDRequestService (const AssertionIDRequestService_sequence& AssertionIDRequestService)
    {
      this->AssertionIDRequestService_ = AssertionIDRequestService;
    }

    const IDPSSODescriptorType::AttributeProfile_sequence& IDPSSODescriptorType::
    AttributeProfile () const
    {
      return this->AttributeProfile_;
    }

    IDPSSODescriptorType::AttributeProfile_sequence& IDPSSODescriptorType::
    AttributeProfile ()
    {
      return this->AttributeProfile_;
    }

    void IDPSSODescriptorType::
    AttributeProfile (const AttributeProfile_sequence& AttributeProfile)
    {
      this->AttributeProfile_ = AttributeProfile;
    }

    const IDPSSODescriptorType::Attribute_sequence& IDPSSODescriptorType::
    Attribute () const
    {
      return this->Attribute_;
    }

    IDPSSODescriptorType::Attribute_sequence& IDPSSODescriptorType::
    Attribute ()
    {
      return this->Attribute_;
    }

    void IDPSSODescriptorType::
    Attribute (const Attribute_sequence& Attribute)
    {
      this->Attribute_ = Attribute;
    }

    const IDPSSODescriptorType::WantAuthnRequestsSigned_optional& IDPSSODescriptorType::
    WantAuthnRequestsSigned () const
    {
      return this->WantAuthnRequestsSigned_;
    }

    IDPSSODescriptorType::WantAuthnRequestsSigned_optional& IDPSSODescriptorType::
    WantAuthnRequestsSigned ()
    {
      return this->WantAuthnRequestsSigned_;
    }

    void IDPSSODescriptorType::
    WantAuthnRequestsSigned (const WantAuthnRequestsSigned_type& WantAuthnRequestsSigned)
    {
      this->WantAuthnRequestsSigned_.set (WantAuthnRequestsSigned);
    }

    void IDPSSODescriptorType::
    WantAuthnRequestsSigned (const WantAuthnRequestsSigned_optional& WantAuthnRequestsSigned)
    {
      this->WantAuthnRequestsSigned_ = WantAuthnRequestsSigned;
    }


    // SPSSODescriptorType
    // 

    const SPSSODescriptorType::AssertionConsumerService_sequence& SPSSODescriptorType::
    AssertionConsumerService () const
    {
      return this->AssertionConsumerService_;
    }

    SPSSODescriptorType::AssertionConsumerService_sequence& SPSSODescriptorType::
    AssertionConsumerService ()
    {
      return this->AssertionConsumerService_;
    }

    void SPSSODescriptorType::
    AssertionConsumerService (const AssertionConsumerService_sequence& AssertionConsumerService)
    {
      this->AssertionConsumerService_ = AssertionConsumerService;
    }

    const SPSSODescriptorType::AttributeConsumingService_sequence& SPSSODescriptorType::
    AttributeConsumingService () const
    {
      return this->AttributeConsumingService_;
    }

    SPSSODescriptorType::AttributeConsumingService_sequence& SPSSODescriptorType::
    AttributeConsumingService ()
    {
      return this->AttributeConsumingService_;
    }

    void SPSSODescriptorType::
    AttributeConsumingService (const AttributeConsumingService_sequence& AttributeConsumingService)
    {
      this->AttributeConsumingService_ = AttributeConsumingService;
    }

    const SPSSODescriptorType::AuthnRequestsSigned_optional& SPSSODescriptorType::
    AuthnRequestsSigned () const
    {
      return this->AuthnRequestsSigned_;
    }

    SPSSODescriptorType::AuthnRequestsSigned_optional& SPSSODescriptorType::
    AuthnRequestsSigned ()
    {
      return this->AuthnRequestsSigned_;
    }

    void SPSSODescriptorType::
    AuthnRequestsSigned (const AuthnRequestsSigned_type& AuthnRequestsSigned)
    {
      this->AuthnRequestsSigned_.set (AuthnRequestsSigned);
    }

    void SPSSODescriptorType::
    AuthnRequestsSigned (const AuthnRequestsSigned_optional& AuthnRequestsSigned)
    {
      this->AuthnRequestsSigned_ = AuthnRequestsSigned;
    }

    const SPSSODescriptorType::WantAssertionsSigned_optional& SPSSODescriptorType::
    WantAssertionsSigned () const
    {
      return this->WantAssertionsSigned_;
    }

    SPSSODescriptorType::WantAssertionsSigned_optional& SPSSODescriptorType::
    WantAssertionsSigned ()
    {
      return this->WantAssertionsSigned_;
    }

    void SPSSODescriptorType::
    WantAssertionsSigned (const WantAssertionsSigned_type& WantAssertionsSigned)
    {
      this->WantAssertionsSigned_.set (WantAssertionsSigned);
    }

    void SPSSODescriptorType::
    WantAssertionsSigned (const WantAssertionsSigned_optional& WantAssertionsSigned)
    {
      this->WantAssertionsSigned_ = WantAssertionsSigned;
    }


    // AttributeConsumingServiceType
    // 

    const AttributeConsumingServiceType::ServiceName_sequence& AttributeConsumingServiceType::
    ServiceName () const
    {
      return this->ServiceName_;
    }

    AttributeConsumingServiceType::ServiceName_sequence& AttributeConsumingServiceType::
    ServiceName ()
    {
      return this->ServiceName_;
    }

    void AttributeConsumingServiceType::
    ServiceName (const ServiceName_sequence& ServiceName)
    {
      this->ServiceName_ = ServiceName;
    }

    const AttributeConsumingServiceType::ServiceDescription_sequence& AttributeConsumingServiceType::
    ServiceDescription () const
    {
      return this->ServiceDescription_;
    }

    AttributeConsumingServiceType::ServiceDescription_sequence& AttributeConsumingServiceType::
    ServiceDescription ()
    {
      return this->ServiceDescription_;
    }

    void AttributeConsumingServiceType::
    ServiceDescription (const ServiceDescription_sequence& ServiceDescription)
    {
      this->ServiceDescription_ = ServiceDescription;
    }

    const AttributeConsumingServiceType::RequestedAttribute_sequence& AttributeConsumingServiceType::
    RequestedAttribute () const
    {
      return this->RequestedAttribute_;
    }

    AttributeConsumingServiceType::RequestedAttribute_sequence& AttributeConsumingServiceType::
    RequestedAttribute ()
    {
      return this->RequestedAttribute_;
    }

    void AttributeConsumingServiceType::
    RequestedAttribute (const RequestedAttribute_sequence& RequestedAttribute)
    {
      this->RequestedAttribute_ = RequestedAttribute;
    }

    const AttributeConsumingServiceType::index_type& AttributeConsumingServiceType::
    index () const
    {
      return this->index_.get ();
    }

    AttributeConsumingServiceType::index_type& AttributeConsumingServiceType::
    index ()
    {
      return this->index_.get ();
    }

    void AttributeConsumingServiceType::
    index (const index_type& index)
    {
      this->index_.set (index);
    }

    const AttributeConsumingServiceType::isDefault_optional& AttributeConsumingServiceType::
    isDefault () const
    {
      return this->isDefault_;
    }

    AttributeConsumingServiceType::isDefault_optional& AttributeConsumingServiceType::
    isDefault ()
    {
      return this->isDefault_;
    }

    void AttributeConsumingServiceType::
    isDefault (const isDefault_type& isDefault)
    {
      this->isDefault_.set (isDefault);
    }

    void AttributeConsumingServiceType::
    isDefault (const isDefault_optional& isDefault)
    {
      this->isDefault_ = isDefault;
    }


    // RequestedAttributeType
    // 

    const RequestedAttributeType::isRequired_optional& RequestedAttributeType::
    isRequired () const
    {
      return this->isRequired_;
    }

    RequestedAttributeType::isRequired_optional& RequestedAttributeType::
    isRequired ()
    {
      return this->isRequired_;
    }

    void RequestedAttributeType::
    isRequired (const isRequired_type& isRequired)
    {
      this->isRequired_.set (isRequired);
    }

    void RequestedAttributeType::
    isRequired (const isRequired_optional& isRequired)
    {
      this->isRequired_ = isRequired;
    }


    // AuthnAuthorityDescriptorType
    // 

    const AuthnAuthorityDescriptorType::AuthnQueryService_sequence& AuthnAuthorityDescriptorType::
    AuthnQueryService () const
    {
      return this->AuthnQueryService_;
    }

    AuthnAuthorityDescriptorType::AuthnQueryService_sequence& AuthnAuthorityDescriptorType::
    AuthnQueryService ()
    {
      return this->AuthnQueryService_;
    }

    void AuthnAuthorityDescriptorType::
    AuthnQueryService (const AuthnQueryService_sequence& AuthnQueryService)
    {
      this->AuthnQueryService_ = AuthnQueryService;
    }

    const AuthnAuthorityDescriptorType::AssertionIDRequestService_sequence& AuthnAuthorityDescriptorType::
    AssertionIDRequestService () const
    {
      return this->AssertionIDRequestService_;
    }

    AuthnAuthorityDescriptorType::AssertionIDRequestService_sequence& AuthnAuthorityDescriptorType::
    AssertionIDRequestService ()
    {
      return this->AssertionIDRequestService_;
    }

    void AuthnAuthorityDescriptorType::
    AssertionIDRequestService (const AssertionIDRequestService_sequence& AssertionIDRequestService)
    {
      this->AssertionIDRequestService_ = AssertionIDRequestService;
    }

    const AuthnAuthorityDescriptorType::NameIDFormat_sequence& AuthnAuthorityDescriptorType::
    NameIDFormat () const
    {
      return this->NameIDFormat_;
    }

    AuthnAuthorityDescriptorType::NameIDFormat_sequence& AuthnAuthorityDescriptorType::
    NameIDFormat ()
    {
      return this->NameIDFormat_;
    }

    void AuthnAuthorityDescriptorType::
    NameIDFormat (const NameIDFormat_sequence& NameIDFormat)
    {
      this->NameIDFormat_ = NameIDFormat;
    }


    // PDPDescriptorType
    // 

    const PDPDescriptorType::AuthzService_sequence& PDPDescriptorType::
    AuthzService () const
    {
      return this->AuthzService_;
    }

    PDPDescriptorType::AuthzService_sequence& PDPDescriptorType::
    AuthzService ()
    {
      return this->AuthzService_;
    }

    void PDPDescriptorType::
    AuthzService (const AuthzService_sequence& AuthzService)
    {
      this->AuthzService_ = AuthzService;
    }

    const PDPDescriptorType::AssertionIDRequestService_sequence& PDPDescriptorType::
    AssertionIDRequestService () const
    {
      return this->AssertionIDRequestService_;
    }

    PDPDescriptorType::AssertionIDRequestService_sequence& PDPDescriptorType::
    AssertionIDRequestService ()
    {
      return this->AssertionIDRequestService_;
    }

    void PDPDescriptorType::
    AssertionIDRequestService (const AssertionIDRequestService_sequence& AssertionIDRequestService)
    {
      this->AssertionIDRequestService_ = AssertionIDRequestService;
    }

    const PDPDescriptorType::NameIDFormat_sequence& PDPDescriptorType::
    NameIDFormat () const
    {
      return this->NameIDFormat_;
    }

    PDPDescriptorType::NameIDFormat_sequence& PDPDescriptorType::
    NameIDFormat ()
    {
      return this->NameIDFormat_;
    }

    void PDPDescriptorType::
    NameIDFormat (const NameIDFormat_sequence& NameIDFormat)
    {
      this->NameIDFormat_ = NameIDFormat;
    }


    // AttributeAuthorityDescriptorType
    // 

    const AttributeAuthorityDescriptorType::AttributeService_sequence& AttributeAuthorityDescriptorType::
    AttributeService () const
    {
      return this->AttributeService_;
    }

    AttributeAuthorityDescriptorType::AttributeService_sequence& AttributeAuthorityDescriptorType::
    AttributeService ()
    {
      return this->AttributeService_;
    }

    void AttributeAuthorityDescriptorType::
    AttributeService (const AttributeService_sequence& AttributeService)
    {
      this->AttributeService_ = AttributeService;
    }

    const AttributeAuthorityDescriptorType::AssertionIDRequestService_sequence& AttributeAuthorityDescriptorType::
    AssertionIDRequestService () const
    {
      return this->AssertionIDRequestService_;
    }

    AttributeAuthorityDescriptorType::AssertionIDRequestService_sequence& AttributeAuthorityDescriptorType::
    AssertionIDRequestService ()
    {
      return this->AssertionIDRequestService_;
    }

    void AttributeAuthorityDescriptorType::
    AssertionIDRequestService (const AssertionIDRequestService_sequence& AssertionIDRequestService)
    {
      this->AssertionIDRequestService_ = AssertionIDRequestService;
    }

    const AttributeAuthorityDescriptorType::NameIDFormat_sequence& AttributeAuthorityDescriptorType::
    NameIDFormat () const
    {
      return this->NameIDFormat_;
    }

    AttributeAuthorityDescriptorType::NameIDFormat_sequence& AttributeAuthorityDescriptorType::
    NameIDFormat ()
    {
      return this->NameIDFormat_;
    }

    void AttributeAuthorityDescriptorType::
    NameIDFormat (const NameIDFormat_sequence& NameIDFormat)
    {
      this->NameIDFormat_ = NameIDFormat;
    }

    const AttributeAuthorityDescriptorType::AttributeProfile_sequence& AttributeAuthorityDescriptorType::
    AttributeProfile () const
    {
      return this->AttributeProfile_;
    }

    AttributeAuthorityDescriptorType::AttributeProfile_sequence& AttributeAuthorityDescriptorType::
    AttributeProfile ()
    {
      return this->AttributeProfile_;
    }

    void AttributeAuthorityDescriptorType::
    AttributeProfile (const AttributeProfile_sequence& AttributeProfile)
    {
      this->AttributeProfile_ = AttributeProfile;
    }

    const AttributeAuthorityDescriptorType::Attribute_sequence& AttributeAuthorityDescriptorType::
    Attribute () const
    {
      return this->Attribute_;
    }

    AttributeAuthorityDescriptorType::Attribute_sequence& AttributeAuthorityDescriptorType::
    Attribute ()
    {
      return this->Attribute_;
    }

    void AttributeAuthorityDescriptorType::
    Attribute (const Attribute_sequence& Attribute)
    {
      this->Attribute_ = Attribute;
    }


    // AffiliationDescriptorType
    // 

    const AffiliationDescriptorType::Signature_optional& AffiliationDescriptorType::
    Signature () const
    {
      return this->Signature_;
    }

    AffiliationDescriptorType::Signature_optional& AffiliationDescriptorType::
    Signature ()
    {
      return this->Signature_;
    }

    void AffiliationDescriptorType::
    Signature (const Signature_type& Signature)
    {
      this->Signature_.set (Signature);
    }

    void AffiliationDescriptorType::
    Signature (const Signature_optional& Signature)
    {
      this->Signature_ = Signature;
    }

    void AffiliationDescriptorType::
    Signature (::std::auto_ptr< Signature_type > Signature)
    {
      this->Signature_.set (Signature);
    }

    const AffiliationDescriptorType::Extensions_optional& AffiliationDescriptorType::
    Extensions () const
    {
      return this->Extensions_;
    }

    AffiliationDescriptorType::Extensions_optional& AffiliationDescriptorType::
    Extensions ()
    {
      return this->Extensions_;
    }

    void AffiliationDescriptorType::
    Extensions (const Extensions_type& Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    void AffiliationDescriptorType::
    Extensions (const Extensions_optional& Extensions)
    {
      this->Extensions_ = Extensions;
    }

    void AffiliationDescriptorType::
    Extensions (::std::auto_ptr< Extensions_type > Extensions)
    {
      this->Extensions_.set (Extensions);
    }

    const AffiliationDescriptorType::AffiliateMember_sequence& AffiliationDescriptorType::
    AffiliateMember () const
    {
      return this->AffiliateMember_;
    }

    AffiliationDescriptorType::AffiliateMember_sequence& AffiliationDescriptorType::
    AffiliateMember ()
    {
      return this->AffiliateMember_;
    }

    void AffiliationDescriptorType::
    AffiliateMember (const AffiliateMember_sequence& AffiliateMember)
    {
      this->AffiliateMember_ = AffiliateMember;
    }

    const AffiliationDescriptorType::KeyDescriptor_sequence& AffiliationDescriptorType::
    KeyDescriptor () const
    {
      return this->KeyDescriptor_;
    }

    AffiliationDescriptorType::KeyDescriptor_sequence& AffiliationDescriptorType::
    KeyDescriptor ()
    {
      return this->KeyDescriptor_;
    }

    void AffiliationDescriptorType::
    KeyDescriptor (const KeyDescriptor_sequence& KeyDescriptor)
    {
      this->KeyDescriptor_ = KeyDescriptor;
    }

    const AffiliationDescriptorType::affiliationOwnerID_type& AffiliationDescriptorType::
    affiliationOwnerID () const
    {
      return this->affiliationOwnerID_.get ();
    }

    AffiliationDescriptorType::affiliationOwnerID_type& AffiliationDescriptorType::
    affiliationOwnerID ()
    {
      return this->affiliationOwnerID_.get ();
    }

    void AffiliationDescriptorType::
    affiliationOwnerID (const affiliationOwnerID_type& affiliationOwnerID)
    {
      this->affiliationOwnerID_.set (affiliationOwnerID);
    }

    void AffiliationDescriptorType::
    affiliationOwnerID (::std::auto_ptr< affiliationOwnerID_type > affiliationOwnerID)
    {
      this->affiliationOwnerID_.set (affiliationOwnerID);
    }

    const AffiliationDescriptorType::validUntil_optional& AffiliationDescriptorType::
    validUntil () const
    {
      return this->validUntil_;
    }

    AffiliationDescriptorType::validUntil_optional& AffiliationDescriptorType::
    validUntil ()
    {
      return this->validUntil_;
    }

    void AffiliationDescriptorType::
    validUntil (const validUntil_type& validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    void AffiliationDescriptorType::
    validUntil (const validUntil_optional& validUntil)
    {
      this->validUntil_ = validUntil;
    }

    void AffiliationDescriptorType::
    validUntil (::std::auto_ptr< validUntil_type > validUntil)
    {
      this->validUntil_.set (validUntil);
    }

    const AffiliationDescriptorType::cacheDuration_optional& AffiliationDescriptorType::
    cacheDuration () const
    {
      return this->cacheDuration_;
    }

    AffiliationDescriptorType::cacheDuration_optional& AffiliationDescriptorType::
    cacheDuration ()
    {
      return this->cacheDuration_;
    }

    void AffiliationDescriptorType::
    cacheDuration (const cacheDuration_type& cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    void AffiliationDescriptorType::
    cacheDuration (const cacheDuration_optional& cacheDuration)
    {
      this->cacheDuration_ = cacheDuration;
    }

    void AffiliationDescriptorType::
    cacheDuration (::std::auto_ptr< cacheDuration_type > cacheDuration)
    {
      this->cacheDuration_.set (cacheDuration);
    }

    const AffiliationDescriptorType::ID_optional& AffiliationDescriptorType::
    ID () const
    {
      return this->ID_;
    }

    AffiliationDescriptorType::ID_optional& AffiliationDescriptorType::
    ID ()
    {
      return this->ID_;
    }

    void AffiliationDescriptorType::
    ID (const ID_type& ID)
    {
      this->ID_.set (ID);
    }

    void AffiliationDescriptorType::
    ID (const ID_optional& ID)
    {
      this->ID_ = ID;
    }

    void AffiliationDescriptorType::
    ID (::std::auto_ptr< ID_type > ID)
    {
      this->ID_.set (ID);
    }

    const AffiliationDescriptorType::any_attribute_set& AffiliationDescriptorType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    AffiliationDescriptorType::any_attribute_set& AffiliationDescriptorType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void AffiliationDescriptorType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& AffiliationDescriptorType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& AffiliationDescriptorType::
    dom_document ()
    {
      return *dom_document_;
    }
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace saml2
{
  namespace metadata
  {
    // entityIDType
    //

    entityIDType::
    entityIDType ()
    : ::xml_schema::uri ()
    {
    }

    entityIDType::
    entityIDType (const ::xml_schema::uri& anyURI)
    : ::xml_schema::uri (anyURI)
    {
    }

    entityIDType::
    entityIDType (const entityIDType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::uri (x, f, c)
    {
    }

    entityIDType::
    entityIDType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::uri (e, f, c)
    {
    }

    entityIDType::
    entityIDType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::uri (a, f, c)
    {
    }

    entityIDType::
    entityIDType (const ::std::wstring& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::uri (s, e, f, c)
    {
    }

    entityIDType* entityIDType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new entityIDType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, entityIDType >
    _xsd_entityIDType_type_factory_init (
      L"entityIDType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // localizedNameType
    //

    localizedNameType::
    localizedNameType ()
    : ::xml_schema::string (),
      lang_ (::xml_schema::flags (), this)
    {
    }

    localizedNameType::
    localizedNameType (const lang_type& lang)
    : ::xml_schema::string (),
      lang_ (lang, ::xml_schema::flags (), this)
    {
    }

    localizedNameType::
    localizedNameType (const ::xml_schema::string& string,
                       const lang_type& lang)
    : ::xml_schema::string (string),
      lang_ (lang, ::xml_schema::flags (), this)
    {
    }

    localizedNameType::
    localizedNameType (const localizedNameType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (x, f, c),
      lang_ (x.lang_, f, this)
    {
    }

    localizedNameType::
    localizedNameType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      lang_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void localizedNameType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"lang" && n.namespace_ () == L"http://www.w3.org/XML/1998/namespace")
        {
          ::std::auto_ptr< lang_type > r (
            lang_traits::create (i, f, this));

          this->lang (r);
          continue;
        }
      }

      if (!lang_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"lang",
          L"http://www.w3.org/XML/1998/namespace");
      }
    }

    localizedNameType* localizedNameType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new localizedNameType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, localizedNameType >
    _xsd_localizedNameType_type_factory_init (
      L"localizedNameType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // localizedURIType
    //

    localizedURIType::
    localizedURIType ()
    : ::xml_schema::uri (),
      lang_ (::xml_schema::flags (), this)
    {
    }

    localizedURIType::
    localizedURIType (const ::xml_schema::uri& anyURI,
                      const lang_type& lang)
    : ::xml_schema::uri (anyURI),
      lang_ (lang, ::xml_schema::flags (), this)
    {
    }

    localizedURIType::
    localizedURIType (const localizedURIType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::uri (x, f, c),
      lang_ (x.lang_, f, this)
    {
    }

    localizedURIType::
    localizedURIType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
      lang_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void localizedURIType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"lang" && n.namespace_ () == L"http://www.w3.org/XML/1998/namespace")
        {
          ::std::auto_ptr< lang_type > r (
            lang_traits::create (i, f, this));

          this->lang (r);
          continue;
        }
      }

      if (!lang_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"lang",
          L"http://www.w3.org/XML/1998/namespace");
      }
    }

    localizedURIType* localizedURIType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new localizedURIType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, localizedURIType >
    _xsd_localizedURIType_type_factory_init (
      L"localizedURIType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // ExtensionsType
    //

    ExtensionsType::
    ExtensionsType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
    }

    ExtensionsType::
    ExtensionsType (const ExtensionsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ())
    {
    }

    ExtensionsType::
    ExtensionsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ExtensionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any ().push_back (r);
          continue;
        }

        break;
      }
    }

    ExtensionsType* ExtensionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ExtensionsType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ExtensionsType >
    _xsd_ExtensionsType_type_factory_init (
      L"ExtensionsType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // EndpointType
    //

    EndpointType::
    EndpointType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      Binding_ (::xml_schema::flags (), this),
      Location_ (::xml_schema::flags (), this),
      ResponseLocation_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    EndpointType::
    EndpointType (const Binding_type& Binding,
                  const Location_type& Location)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      Binding_ (Binding, ::xml_schema::flags (), this),
      Location_ (Location, ::xml_schema::flags (), this),
      ResponseLocation_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    EndpointType::
    EndpointType (const EndpointType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      Binding_ (x.Binding_, f, this),
      Location_ (x.Location_, f, this),
      ResponseLocation_ (x.ResponseLocation_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    EndpointType::
    EndpointType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      Binding_ (f, this),
      Location_ (f, this),
      ResponseLocation_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void EndpointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Binding" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Binding_type > r (
            Binding_traits::create (i, f, this));

          this->Binding (r);
          continue;
        }

        if (n.name () == L"Location" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          this->Location (r);
          continue;
        }

        if (n.name () == L"ResponseLocation" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ResponseLocation_type > r (
            ResponseLocation_traits::create (i, f, this));

          this->ResponseLocation (r);
          continue;
        }

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }

      if (!Binding_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Binding",
          L"");
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Location",
          L"");
      }
    }

    EndpointType* EndpointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new EndpointType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EndpointType >
    _xsd_EndpointType_type_factory_init (
      L"EndpointType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // IndexedEndpointType
    //

    IndexedEndpointType::
    IndexedEndpointType ()
    : ::saml2::metadata::EndpointType (),
      index_ (::xml_schema::flags (), this),
      isDefault_ (::xml_schema::flags (), this)
    {
    }

    IndexedEndpointType::
    IndexedEndpointType (const Binding_type& Binding,
                         const Location_type& Location,
                         const index_type& index)
    : ::saml2::metadata::EndpointType (Binding,
                                       Location),
      index_ (index, ::xml_schema::flags (), this),
      isDefault_ (::xml_schema::flags (), this)
    {
    }

    IndexedEndpointType::
    IndexedEndpointType (const IndexedEndpointType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::saml2::metadata::EndpointType (x, f, c),
      index_ (x.index_, f, this),
      isDefault_ (x.isDefault_, f, this)
    {
    }

    IndexedEndpointType::
    IndexedEndpointType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::saml2::metadata::EndpointType (e, f | ::xml_schema::flags::base, c),
      index_ (f, this),
      isDefault_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void IndexedEndpointType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::metadata::EndpointType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"index" && n.namespace_ ().empty ())
        {
          this->index (index_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"isDefault" && n.namespace_ ().empty ())
        {
          this->isDefault (isDefault_traits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"index",
          L"");
      }
    }

    IndexedEndpointType* IndexedEndpointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new IndexedEndpointType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IndexedEndpointType >
    _xsd_IndexedEndpointType_type_factory_init (
      L"IndexedEndpointType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // EntitiesDescriptorType
    //

    EntitiesDescriptorType::
    EntitiesDescriptorType ()
    : ::xml_schema::type (),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      EntityDescriptor_ (::xml_schema::flags (), this),
      EntitiesDescriptor_ (::xml_schema::flags (), this),
      validUntil_ (::xml_schema::flags (), this),
      cacheDuration_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      Name_ (::xml_schema::flags (), this)
    {
    }

    EntitiesDescriptorType::
    EntitiesDescriptorType (const EntitiesDescriptorType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      Signature_ (x.Signature_, f, this),
      Extensions_ (x.Extensions_, f, this),
      EntityDescriptor_ (x.EntityDescriptor_, f, this),
      EntitiesDescriptor_ (x.EntitiesDescriptor_, f, this),
      validUntil_ (x.validUntil_, f, this),
      cacheDuration_ (x.cacheDuration_, f, this),
      ID_ (x.ID_, f, this),
      Name_ (x.Name_, f, this)
    {
    }

    EntitiesDescriptorType::
    EntitiesDescriptorType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Signature_ (f, this),
      Extensions_ (f, this),
      EntityDescriptor_ (f, this),
      EntitiesDescriptor_ (f, this),
      validUntil_ (f, this),
      cacheDuration_ (f, this),
      ID_ (f, this),
      Name_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void EntitiesDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Signature_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Signature ())
            {
              ::std::auto_ptr< Signature_type > r (
                dynamic_cast< Signature_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Signature (r);
              continue;
            }
          }
        }

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        // EntityDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EntityDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< EntityDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EntityDescriptor_type > r (
              dynamic_cast< EntityDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EntityDescriptor ().push_back (r);
            continue;
          }
        }

        // EntitiesDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EntitiesDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< EntitiesDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EntitiesDescriptor_type > r (
              dynamic_cast< EntitiesDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EntitiesDescriptor ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"validUntil" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validUntil_type > r (
            validUntil_traits::create (i, f, this));

          this->validUntil (r);
          continue;
        }

        if (n.name () == L"cacheDuration" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cacheDuration_type > r (
            cacheDuration_traits::create (i, f, this));

          this->cacheDuration (r);
          continue;
        }

        if (n.name () == L"ID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID_type > r (
            ID_traits::create (i, f, this));

          this->ID (r);
          continue;
        }

        if (n.name () == L"Name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          this->Name (r);
          continue;
        }
      }
    }

    EntitiesDescriptorType* EntitiesDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new EntitiesDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EntitiesDescriptorType >
    _xsd_EntitiesDescriptorType_type_factory_init (
      L"EntitiesDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // EntityDescriptorType
    //

    EntityDescriptorType::
    EntityDescriptorType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      RoleDescriptor_ (::xml_schema::flags (), this),
      IDPSSODescriptor_ (::xml_schema::flags (), this),
      SPSSODescriptor_ (::xml_schema::flags (), this),
      AuthnAuthorityDescriptor_ (::xml_schema::flags (), this),
      AttributeAuthorityDescriptor_ (::xml_schema::flags (), this),
      PDPDescriptor_ (::xml_schema::flags (), this),
      AffiliationDescriptor_ (::xml_schema::flags (), this),
      Organization_ (::xml_schema::flags (), this),
      ContactPerson_ (::xml_schema::flags (), this),
      AdditionalMetadataLocation_ (::xml_schema::flags (), this),
      entityID_ (::xml_schema::flags (), this),
      validUntil_ (::xml_schema::flags (), this),
      cacheDuration_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    EntityDescriptorType::
    EntityDescriptorType (const entityID_type& entityID)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      RoleDescriptor_ (::xml_schema::flags (), this),
      IDPSSODescriptor_ (::xml_schema::flags (), this),
      SPSSODescriptor_ (::xml_schema::flags (), this),
      AuthnAuthorityDescriptor_ (::xml_schema::flags (), this),
      AttributeAuthorityDescriptor_ (::xml_schema::flags (), this),
      PDPDescriptor_ (::xml_schema::flags (), this),
      AffiliationDescriptor_ (::xml_schema::flags (), this),
      Organization_ (::xml_schema::flags (), this),
      ContactPerson_ (::xml_schema::flags (), this),
      AdditionalMetadataLocation_ (::xml_schema::flags (), this),
      entityID_ (entityID, ::xml_schema::flags (), this),
      validUntil_ (::xml_schema::flags (), this),
      cacheDuration_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    EntityDescriptorType::
    EntityDescriptorType (const EntityDescriptorType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (x.Signature_, f, this),
      Extensions_ (x.Extensions_, f, this),
      RoleDescriptor_ (x.RoleDescriptor_, f, this),
      IDPSSODescriptor_ (x.IDPSSODescriptor_, f, this),
      SPSSODescriptor_ (x.SPSSODescriptor_, f, this),
      AuthnAuthorityDescriptor_ (x.AuthnAuthorityDescriptor_, f, this),
      AttributeAuthorityDescriptor_ (x.AttributeAuthorityDescriptor_, f, this),
      PDPDescriptor_ (x.PDPDescriptor_, f, this),
      AffiliationDescriptor_ (x.AffiliationDescriptor_, f, this),
      Organization_ (x.Organization_, f, this),
      ContactPerson_ (x.ContactPerson_, f, this),
      AdditionalMetadataLocation_ (x.AdditionalMetadataLocation_, f, this),
      entityID_ (x.entityID_, f, this),
      validUntil_ (x.validUntil_, f, this),
      cacheDuration_ (x.cacheDuration_, f, this),
      ID_ (x.ID_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    EntityDescriptorType::
    EntityDescriptorType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (f, this),
      Extensions_ (f, this),
      RoleDescriptor_ (f, this),
      IDPSSODescriptor_ (f, this),
      SPSSODescriptor_ (f, this),
      AuthnAuthorityDescriptor_ (f, this),
      AttributeAuthorityDescriptor_ (f, this),
      PDPDescriptor_ (f, this),
      AffiliationDescriptor_ (f, this),
      Organization_ (f, this),
      ContactPerson_ (f, this),
      AdditionalMetadataLocation_ (f, this),
      entityID_ (f, this),
      validUntil_ (f, this),
      cacheDuration_ (f, this),
      ID_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void EntityDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Signature_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Signature ())
            {
              ::std::auto_ptr< Signature_type > r (
                dynamic_cast< Signature_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Signature (r);
              continue;
            }
          }
        }

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        // RoleDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"RoleDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< RoleDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< RoleDescriptor_type > r (
              dynamic_cast< RoleDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->RoleDescriptor ().push_back (r);
            continue;
          }
        }

        // IDPSSODescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"IDPSSODescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< IDPSSODescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< IDPSSODescriptor_type > r (
              dynamic_cast< IDPSSODescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->IDPSSODescriptor ().push_back (r);
            continue;
          }
        }

        // SPSSODescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SPSSODescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< SPSSODescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< SPSSODescriptor_type > r (
              dynamic_cast< SPSSODescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->SPSSODescriptor ().push_back (r);
            continue;
          }
        }

        // AuthnAuthorityDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnAuthorityDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AuthnAuthorityDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthnAuthorityDescriptor_type > r (
              dynamic_cast< AuthnAuthorityDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthnAuthorityDescriptor ().push_back (r);
            continue;
          }
        }

        // AttributeAuthorityDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AttributeAuthorityDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AttributeAuthorityDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AttributeAuthorityDescriptor_type > r (
              dynamic_cast< AttributeAuthorityDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AttributeAuthorityDescriptor ().push_back (r);
            continue;
          }
        }

        // PDPDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"PDPDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< PDPDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< PDPDescriptor_type > r (
              dynamic_cast< PDPDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->PDPDescriptor ().push_back (r);
            continue;
          }
        }

        // AffiliationDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AffiliationDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AffiliationDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->AffiliationDescriptor ())
            {
              ::std::auto_ptr< AffiliationDescriptor_type > r (
                dynamic_cast< AffiliationDescriptor_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->AffiliationDescriptor (r);
              continue;
            }
          }
        }

        // Organization
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Organization",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Organization_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Organization ())
            {
              ::std::auto_ptr< Organization_type > r (
                dynamic_cast< Organization_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Organization (r);
              continue;
            }
          }
        }

        // ContactPerson
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"ContactPerson",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< ContactPerson_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ContactPerson_type > r (
              dynamic_cast< ContactPerson_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ContactPerson ().push_back (r);
            continue;
          }
        }

        // AdditionalMetadataLocation
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AdditionalMetadataLocation",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AdditionalMetadataLocation_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AdditionalMetadataLocation_type > r (
              dynamic_cast< AdditionalMetadataLocation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AdditionalMetadataLocation ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"entityID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< entityID_type > r (
            entityID_traits::create (i, f, this));

          this->entityID (r);
          continue;
        }

        if (n.name () == L"validUntil" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validUntil_type > r (
            validUntil_traits::create (i, f, this));

          this->validUntil (r);
          continue;
        }

        if (n.name () == L"cacheDuration" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cacheDuration_type > r (
            cacheDuration_traits::create (i, f, this));

          this->cacheDuration (r);
          continue;
        }

        if (n.name () == L"ID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID_type > r (
            ID_traits::create (i, f, this));

          this->ID (r);
          continue;
        }

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }

      if (!entityID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"entityID",
          L"");
      }
    }

    EntityDescriptorType* EntityDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new EntityDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EntityDescriptorType >
    _xsd_EntityDescriptorType_type_factory_init (
      L"EntityDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // OrganizationType
    //

    OrganizationType::
    OrganizationType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Extensions_ (::xml_schema::flags (), this),
      OrganizationName_ (::xml_schema::flags (), this),
      OrganizationDisplayName_ (::xml_schema::flags (), this),
      OrganizationURL_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    OrganizationType::
    OrganizationType (const OrganizationType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Extensions_ (x.Extensions_, f, this),
      OrganizationName_ (x.OrganizationName_, f, this),
      OrganizationDisplayName_ (x.OrganizationDisplayName_, f, this),
      OrganizationURL_ (x.OrganizationURL_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    OrganizationType::
    OrganizationType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Extensions_ (f, this),
      OrganizationName_ (f, this),
      OrganizationDisplayName_ (f, this),
      OrganizationURL_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void OrganizationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        // OrganizationName
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"OrganizationName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< OrganizationName_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< OrganizationName_type > r (
              dynamic_cast< OrganizationName_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->OrganizationName ().push_back (r);
            continue;
          }
        }

        // OrganizationDisplayName
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"OrganizationDisplayName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< OrganizationDisplayName_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< OrganizationDisplayName_type > r (
              dynamic_cast< OrganizationDisplayName_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->OrganizationDisplayName ().push_back (r);
            continue;
          }
        }

        // OrganizationURL
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"OrganizationURL",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< OrganizationURL_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< OrganizationURL_type > r (
              dynamic_cast< OrganizationURL_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->OrganizationURL ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }
    }

    OrganizationType* OrganizationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new OrganizationType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OrganizationType >
    _xsd_OrganizationType_type_factory_init (
      L"OrganizationType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // ContactType
    //

    ContactType::
    ContactType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Extensions_ (::xml_schema::flags (), this),
      Company_ (::xml_schema::flags (), this),
      GivenName_ (::xml_schema::flags (), this),
      SurName_ (::xml_schema::flags (), this),
      EmailAddress_ (::xml_schema::flags (), this),
      TelephoneNumber_ (::xml_schema::flags (), this),
      contactType_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    ContactType::
    ContactType (const contactType_type& contactType)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Extensions_ (::xml_schema::flags (), this),
      Company_ (::xml_schema::flags (), this),
      GivenName_ (::xml_schema::flags (), this),
      SurName_ (::xml_schema::flags (), this),
      EmailAddress_ (::xml_schema::flags (), this),
      TelephoneNumber_ (::xml_schema::flags (), this),
      contactType_ (contactType, ::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    ContactType::
    ContactType (const ContactType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Extensions_ (x.Extensions_, f, this),
      Company_ (x.Company_, f, this),
      GivenName_ (x.GivenName_, f, this),
      SurName_ (x.SurName_, f, this),
      EmailAddress_ (x.EmailAddress_, f, this),
      TelephoneNumber_ (x.TelephoneNumber_, f, this),
      contactType_ (x.contactType_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    ContactType::
    ContactType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Extensions_ (f, this),
      Company_ (f, this),
      GivenName_ (f, this),
      SurName_ (f, this),
      EmailAddress_ (f, this),
      TelephoneNumber_ (f, this),
      contactType_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ContactType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        // Company
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Company",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Company_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Company ())
            {
              ::std::auto_ptr< Company_type > r (
                dynamic_cast< Company_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Company (r);
              continue;
            }
          }
        }

        // GivenName
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"GivenName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< GivenName_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->GivenName ())
            {
              ::std::auto_ptr< GivenName_type > r (
                dynamic_cast< GivenName_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->GivenName (r);
              continue;
            }
          }
        }

        // SurName
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SurName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< SurName_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->SurName ())
            {
              ::std::auto_ptr< SurName_type > r (
                dynamic_cast< SurName_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->SurName (r);
              continue;
            }
          }
        }

        // EmailAddress
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EmailAddress",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< EmailAddress_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EmailAddress_type > r (
              dynamic_cast< EmailAddress_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EmailAddress ().push_back (r);
            continue;
          }
        }

        // TelephoneNumber
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"TelephoneNumber",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< TelephoneNumber_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< TelephoneNumber_type > r (
              dynamic_cast< TelephoneNumber_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->TelephoneNumber ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"contactType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< contactType_type > r (
            contactType_traits::create (i, f, this));

          this->contactType (r);
          continue;
        }

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }

      if (!contactType_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"contactType",
          L"");
      }
    }

    ContactType* ContactType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ContactType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ContactType >
    _xsd_ContactType_type_factory_init (
      L"ContactType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // ContactTypeType
    //

    ContactTypeType::
    ContactTypeType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ContactTypeType_convert ();
    }

    ContactTypeType::
    ContactTypeType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ContactTypeType_convert ();
    }

    ContactTypeType::
    ContactTypeType (const ::std::wstring& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ContactTypeType_convert ();
    }

    ContactTypeType* ContactTypeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ContactTypeType (*this, f, c);
    }

    ContactTypeType::value ContactTypeType::
    _xsd_ContactTypeType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_ContactTypeType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ContactTypeType_indexes_,
                        _xsd_ContactTypeType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ContactTypeType_indexes_ + 5 || _xsd_ContactTypeType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const ContactTypeType::
    _xsd_ContactTypeType_literals_[5] =
    {
      L"technical",
      L"support",
      L"administrative",
      L"billing",
      L"other"
    };

    const ContactTypeType::value ContactTypeType::
    _xsd_ContactTypeType_indexes_[5] =
    {
      ::saml2::metadata::ContactTypeType::administrative,
      ::saml2::metadata::ContactTypeType::billing,
      ::saml2::metadata::ContactTypeType::other,
      ::saml2::metadata::ContactTypeType::support,
      ::saml2::metadata::ContactTypeType::technical
    };

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ContactTypeType >
    _xsd_ContactTypeType_type_factory_init (
      L"ContactTypeType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // AdditionalMetadataLocationType
    //

    AdditionalMetadataLocationType::
    AdditionalMetadataLocationType ()
    : ::xml_schema::uri (),
      namespace__ (::xml_schema::flags (), this)
    {
    }

    AdditionalMetadataLocationType::
    AdditionalMetadataLocationType (const ::xml_schema::uri& anyURI,
                                    const namespace__type& namespace_)
    : ::xml_schema::uri (anyURI),
      namespace__ (namespace_, ::xml_schema::flags (), this)
    {
    }

    AdditionalMetadataLocationType::
    AdditionalMetadataLocationType (const AdditionalMetadataLocationType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::type* c)
    : ::xml_schema::uri (x, f, c),
      namespace__ (x.namespace__, f, this)
    {
    }

    AdditionalMetadataLocationType::
    AdditionalMetadataLocationType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::type* c)
    : ::xml_schema::uri (e, f | ::xml_schema::flags::base, c),
      namespace__ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AdditionalMetadataLocationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"namespace" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< namespace__type > r (
            namespace__traits::create (i, f, this));

          this->namespace_ (r);
          continue;
        }
      }

      if (!namespace__.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"namespace",
          L"");
      }
    }

    AdditionalMetadataLocationType* AdditionalMetadataLocationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AdditionalMetadataLocationType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AdditionalMetadataLocationType >
    _xsd_AdditionalMetadataLocationType_type_factory_init (
      L"AdditionalMetadataLocationType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // RoleDescriptorType
    //

    RoleDescriptorType::
    RoleDescriptorType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      KeyDescriptor_ (::xml_schema::flags (), this),
      Organization_ (::xml_schema::flags (), this),
      ContactPerson_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      validUntil_ (::xml_schema::flags (), this),
      cacheDuration_ (::xml_schema::flags (), this),
      protocolSupportEnumeration_ (::xml_schema::flags (), this),
      errorURL_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    RoleDescriptorType::
    RoleDescriptorType (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      KeyDescriptor_ (::xml_schema::flags (), this),
      Organization_ (::xml_schema::flags (), this),
      ContactPerson_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      validUntil_ (::xml_schema::flags (), this),
      cacheDuration_ (::xml_schema::flags (), this),
      protocolSupportEnumeration_ (protocolSupportEnumeration, ::xml_schema::flags (), this),
      errorURL_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    RoleDescriptorType::
    RoleDescriptorType (const RoleDescriptorType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (x.Signature_, f, this),
      Extensions_ (x.Extensions_, f, this),
      KeyDescriptor_ (x.KeyDescriptor_, f, this),
      Organization_ (x.Organization_, f, this),
      ContactPerson_ (x.ContactPerson_, f, this),
      ID_ (x.ID_, f, this),
      validUntil_ (x.validUntil_, f, this),
      cacheDuration_ (x.cacheDuration_, f, this),
      protocolSupportEnumeration_ (x.protocolSupportEnumeration_, f, this),
      errorURL_ (x.errorURL_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    RoleDescriptorType::
    RoleDescriptorType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (f, this),
      Extensions_ (f, this),
      KeyDescriptor_ (f, this),
      Organization_ (f, this),
      ContactPerson_ (f, this),
      ID_ (f, this),
      validUntil_ (f, this),
      cacheDuration_ (f, this),
      protocolSupportEnumeration_ (f, this),
      errorURL_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void RoleDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Signature_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Signature ())
            {
              ::std::auto_ptr< Signature_type > r (
                dynamic_cast< Signature_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Signature (r);
              continue;
            }
          }
        }

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        // KeyDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"KeyDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< KeyDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< KeyDescriptor_type > r (
              dynamic_cast< KeyDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->KeyDescriptor ().push_back (r);
            continue;
          }
        }

        // Organization
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Organization",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Organization_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Organization ())
            {
              ::std::auto_ptr< Organization_type > r (
                dynamic_cast< Organization_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Organization (r);
              continue;
            }
          }
        }

        // ContactPerson
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"ContactPerson",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< ContactPerson_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ContactPerson_type > r (
              dynamic_cast< ContactPerson_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ContactPerson ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"ID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID_type > r (
            ID_traits::create (i, f, this));

          this->ID (r);
          continue;
        }

        if (n.name () == L"validUntil" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validUntil_type > r (
            validUntil_traits::create (i, f, this));

          this->validUntil (r);
          continue;
        }

        if (n.name () == L"cacheDuration" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cacheDuration_type > r (
            cacheDuration_traits::create (i, f, this));

          this->cacheDuration (r);
          continue;
        }

        if (n.name () == L"protocolSupportEnumeration" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< protocolSupportEnumeration_type > r (
            protocolSupportEnumeration_traits::create (i, f, this));

          this->protocolSupportEnumeration (r);
          continue;
        }

        if (n.name () == L"errorURL" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< errorURL_type > r (
            errorURL_traits::create (i, f, this));

          this->errorURL (r);
          continue;
        }

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }

      if (!protocolSupportEnumeration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"protocolSupportEnumeration",
          L"");
      }
    }

    RoleDescriptorType* RoleDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new RoleDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, RoleDescriptorType >
    _xsd_RoleDescriptorType_type_factory_init (
      L"RoleDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // anyURIListType
    //

    anyURIListType::
    anyURIListType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (e, f, c)
    {
    }

    anyURIListType::
    anyURIListType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (a, f, c)
    {
    }

    anyURIListType::
    anyURIListType (const ::std::wstring& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (s, e, f, c)
    {
    }

    anyURIListType* anyURIListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new anyURIListType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, anyURIListType >
    _xsd_anyURIListType_type_factory_init (
      L"anyURIListType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // KeyDescriptorType
    //

    KeyDescriptorType::
    KeyDescriptorType ()
    : ::xml_schema::type (),
      KeyInfo_ (::xml_schema::flags (), this),
      EncryptionMethod_ (::xml_schema::flags (), this),
      use_ (::xml_schema::flags (), this)
    {
    }

    KeyDescriptorType::
    KeyDescriptorType (const KeyInfo_type& KeyInfo)
    : ::xml_schema::type (),
      KeyInfo_ (KeyInfo, ::xml_schema::flags (), this),
      EncryptionMethod_ (::xml_schema::flags (), this),
      use_ (::xml_schema::flags (), this)
    {
    }

    KeyDescriptorType::
    KeyDescriptorType (const KeyDescriptorType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      KeyInfo_ (x.KeyInfo_, f, this),
      EncryptionMethod_ (x.EncryptionMethod_, f, this),
      use_ (x.use_, f, this)
    {
    }

    KeyDescriptorType::
    KeyDescriptorType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      KeyInfo_ (f, this),
      EncryptionMethod_ (f, this),
      use_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void KeyDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // KeyInfo
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"KeyInfo",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< KeyInfo_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!KeyInfo_.present ())
            {
              ::std::auto_ptr< KeyInfo_type > r (
                dynamic_cast< KeyInfo_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->KeyInfo (r);
              continue;
            }
          }
        }

        // EncryptionMethod
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptionMethod",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< EncryptionMethod_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EncryptionMethod_type > r (
              dynamic_cast< EncryptionMethod_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EncryptionMethod ().push_back (r);
            continue;
          }
        }

        break;
      }

      if (!KeyInfo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"KeyInfo",
          L"http://www.w3.org/2000/09/xmldsig#");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"use" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< use_type > r (
            use_traits::create (i, f, this));

          this->use (r);
          continue;
        }
      }
    }

    KeyDescriptorType* KeyDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new KeyDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, KeyDescriptorType >
    _xsd_KeyDescriptorType_type_factory_init (
      L"KeyDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // KeyTypes
    //

    KeyTypes::
    KeyTypes (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_KeyTypes_convert ();
    }

    KeyTypes::
    KeyTypes (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_KeyTypes_convert ();
    }

    KeyTypes::
    KeyTypes (const ::std::wstring& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_KeyTypes_convert ();
    }

    KeyTypes* KeyTypes::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new KeyTypes (*this, f, c);
    }

    KeyTypes::value KeyTypes::
    _xsd_KeyTypes_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_KeyTypes_literals_);
      const value* i (::std::lower_bound (
                        _xsd_KeyTypes_indexes_,
                        _xsd_KeyTypes_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_KeyTypes_indexes_ + 2 || _xsd_KeyTypes_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const KeyTypes::
    _xsd_KeyTypes_literals_[2] =
    {
      L"encryption",
      L"signing"
    };

    const KeyTypes::value KeyTypes::
    _xsd_KeyTypes_indexes_[2] =
    {
      ::saml2::metadata::KeyTypes::encryption,
      ::saml2::metadata::KeyTypes::signing
    };

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, KeyTypes >
    _xsd_KeyTypes_type_factory_init (
      L"KeyTypes",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // SSODescriptorType
    //

    SSODescriptorType::
    SSODescriptorType ()
    : ::saml2::metadata::RoleDescriptorType (),
      ArtifactResolutionService_ (::xml_schema::flags (), this),
      SingleLogoutService_ (::xml_schema::flags (), this),
      ManageNameIDService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this)
    {
    }

    SSODescriptorType::
    SSODescriptorType (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    : ::saml2::metadata::RoleDescriptorType (protocolSupportEnumeration),
      ArtifactResolutionService_ (::xml_schema::flags (), this),
      SingleLogoutService_ (::xml_schema::flags (), this),
      ManageNameIDService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this)
    {
    }

    SSODescriptorType::
    SSODescriptorType (const SSODescriptorType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (x, f, c),
      ArtifactResolutionService_ (x.ArtifactResolutionService_, f, this),
      SingleLogoutService_ (x.SingleLogoutService_, f, this),
      ManageNameIDService_ (x.ManageNameIDService_, f, this),
      NameIDFormat_ (x.NameIDFormat_, f, this)
    {
    }

    SSODescriptorType::
    SSODescriptorType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (e, f | ::xml_schema::flags::base, c),
      ArtifactResolutionService_ (f, this),
      SingleLogoutService_ (f, this),
      ManageNameIDService_ (f, this),
      NameIDFormat_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void SSODescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::metadata::RoleDescriptorType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ArtifactResolutionService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"ArtifactResolutionService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< ArtifactResolutionService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ArtifactResolutionService_type > r (
              dynamic_cast< ArtifactResolutionService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ArtifactResolutionService ().push_back (r);
            continue;
          }
        }

        // SingleLogoutService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SingleLogoutService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< SingleLogoutService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< SingleLogoutService_type > r (
              dynamic_cast< SingleLogoutService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->SingleLogoutService ().push_back (r);
            continue;
          }
        }

        // ManageNameIDService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"ManageNameIDService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< ManageNameIDService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ManageNameIDService_type > r (
              dynamic_cast< ManageNameIDService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ManageNameIDService ().push_back (r);
            continue;
          }
        }

        // NameIDFormat
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< NameIDFormat_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< NameIDFormat_type > r (
              dynamic_cast< NameIDFormat_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->NameIDFormat ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    SSODescriptorType* SSODescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SSODescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SSODescriptorType >
    _xsd_SSODescriptorType_type_factory_init (
      L"SSODescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // IDPSSODescriptorType
    //

    IDPSSODescriptorType::
    IDPSSODescriptorType ()
    : ::saml2::metadata::SSODescriptorType (),
      SingleSignOnService_ (::xml_schema::flags (), this),
      NameIDMappingService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      AttributeProfile_ (::xml_schema::flags (), this),
      Attribute_ (::xml_schema::flags (), this),
      WantAuthnRequestsSigned_ (::xml_schema::flags (), this)
    {
    }

    IDPSSODescriptorType::
    IDPSSODescriptorType (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    : ::saml2::metadata::SSODescriptorType (protocolSupportEnumeration),
      SingleSignOnService_ (::xml_schema::flags (), this),
      NameIDMappingService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      AttributeProfile_ (::xml_schema::flags (), this),
      Attribute_ (::xml_schema::flags (), this),
      WantAuthnRequestsSigned_ (::xml_schema::flags (), this)
    {
    }

    IDPSSODescriptorType::
    IDPSSODescriptorType (const IDPSSODescriptorType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::metadata::SSODescriptorType (x, f, c),
      SingleSignOnService_ (x.SingleSignOnService_, f, this),
      NameIDMappingService_ (x.NameIDMappingService_, f, this),
      AssertionIDRequestService_ (x.AssertionIDRequestService_, f, this),
      AttributeProfile_ (x.AttributeProfile_, f, this),
      Attribute_ (x.Attribute_, f, this),
      WantAuthnRequestsSigned_ (x.WantAuthnRequestsSigned_, f, this)
    {
    }

    IDPSSODescriptorType::
    IDPSSODescriptorType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::metadata::SSODescriptorType (e, f | ::xml_schema::flags::base, c),
      SingleSignOnService_ (f, this),
      NameIDMappingService_ (f, this),
      AssertionIDRequestService_ (f, this),
      AttributeProfile_ (f, this),
      Attribute_ (f, this),
      WantAuthnRequestsSigned_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void IDPSSODescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::metadata::SSODescriptorType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SingleSignOnService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SingleSignOnService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< SingleSignOnService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< SingleSignOnService_type > r (
              dynamic_cast< SingleSignOnService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->SingleSignOnService ().push_back (r);
            continue;
          }
        }

        // NameIDMappingService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameIDMappingService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< NameIDMappingService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< NameIDMappingService_type > r (
              dynamic_cast< NameIDMappingService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->NameIDMappingService ().push_back (r);
            continue;
          }
        }

        // AssertionIDRequestService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AssertionIDRequestService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionIDRequestService_type > r (
              dynamic_cast< AssertionIDRequestService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionIDRequestService ().push_back (r);
            continue;
          }
        }

        // AttributeProfile
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AttributeProfile",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AttributeProfile_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AttributeProfile_type > r (
              dynamic_cast< AttributeProfile_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AttributeProfile ().push_back (r);
            continue;
          }
        }

        // Attribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Attribute_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Attribute_type > r (
              dynamic_cast< Attribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Attribute ().push_back (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"WantAuthnRequestsSigned" && n.namespace_ ().empty ())
        {
          this->WantAuthnRequestsSigned (WantAuthnRequestsSigned_traits::create (i, f, this));
          continue;
        }
      }
    }

    IDPSSODescriptorType* IDPSSODescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new IDPSSODescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, IDPSSODescriptorType >
    _xsd_IDPSSODescriptorType_type_factory_init (
      L"IDPSSODescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // SPSSODescriptorType
    //

    SPSSODescriptorType::
    SPSSODescriptorType ()
    : ::saml2::metadata::SSODescriptorType (),
      AssertionConsumerService_ (::xml_schema::flags (), this),
      AttributeConsumingService_ (::xml_schema::flags (), this),
      AuthnRequestsSigned_ (::xml_schema::flags (), this),
      WantAssertionsSigned_ (::xml_schema::flags (), this)
    {
    }

    SPSSODescriptorType::
    SPSSODescriptorType (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    : ::saml2::metadata::SSODescriptorType (protocolSupportEnumeration),
      AssertionConsumerService_ (::xml_schema::flags (), this),
      AttributeConsumingService_ (::xml_schema::flags (), this),
      AuthnRequestsSigned_ (::xml_schema::flags (), this),
      WantAssertionsSigned_ (::xml_schema::flags (), this)
    {
    }

    SPSSODescriptorType::
    SPSSODescriptorType (const SPSSODescriptorType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::saml2::metadata::SSODescriptorType (x, f, c),
      AssertionConsumerService_ (x.AssertionConsumerService_, f, this),
      AttributeConsumingService_ (x.AttributeConsumingService_, f, this),
      AuthnRequestsSigned_ (x.AuthnRequestsSigned_, f, this),
      WantAssertionsSigned_ (x.WantAssertionsSigned_, f, this)
    {
    }

    SPSSODescriptorType::
    SPSSODescriptorType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::saml2::metadata::SSODescriptorType (e, f | ::xml_schema::flags::base, c),
      AssertionConsumerService_ (f, this),
      AttributeConsumingService_ (f, this),
      AuthnRequestsSigned_ (f, this),
      WantAssertionsSigned_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void SPSSODescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::metadata::SSODescriptorType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AssertionConsumerService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionConsumerService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AssertionConsumerService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionConsumerService_type > r (
              dynamic_cast< AssertionConsumerService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionConsumerService ().push_back (r);
            continue;
          }
        }

        // AttributeConsumingService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AttributeConsumingService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AttributeConsumingService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AttributeConsumingService_type > r (
              dynamic_cast< AttributeConsumingService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AttributeConsumingService ().push_back (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"AuthnRequestsSigned" && n.namespace_ ().empty ())
        {
          this->AuthnRequestsSigned (AuthnRequestsSigned_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"WantAssertionsSigned" && n.namespace_ ().empty ())
        {
          this->WantAssertionsSigned (WantAssertionsSigned_traits::create (i, f, this));
          continue;
        }
      }
    }

    SPSSODescriptorType* SPSSODescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SPSSODescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SPSSODescriptorType >
    _xsd_SPSSODescriptorType_type_factory_init (
      L"SPSSODescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // AttributeConsumingServiceType
    //

    AttributeConsumingServiceType::
    AttributeConsumingServiceType ()
    : ::xml_schema::type (),
      ServiceName_ (::xml_schema::flags (), this),
      ServiceDescription_ (::xml_schema::flags (), this),
      RequestedAttribute_ (::xml_schema::flags (), this),
      index_ (::xml_schema::flags (), this),
      isDefault_ (::xml_schema::flags (), this)
    {
    }

    AttributeConsumingServiceType::
    AttributeConsumingServiceType (const index_type& index)
    : ::xml_schema::type (),
      ServiceName_ (::xml_schema::flags (), this),
      ServiceDescription_ (::xml_schema::flags (), this),
      RequestedAttribute_ (::xml_schema::flags (), this),
      index_ (index, ::xml_schema::flags (), this),
      isDefault_ (::xml_schema::flags (), this)
    {
    }

    AttributeConsumingServiceType::
    AttributeConsumingServiceType (const AttributeConsumingServiceType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      ServiceName_ (x.ServiceName_, f, this),
      ServiceDescription_ (x.ServiceDescription_, f, this),
      RequestedAttribute_ (x.RequestedAttribute_, f, this),
      index_ (x.index_, f, this),
      isDefault_ (x.isDefault_, f, this)
    {
    }

    AttributeConsumingServiceType::
    AttributeConsumingServiceType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ServiceName_ (f, this),
      ServiceDescription_ (f, this),
      RequestedAttribute_ (f, this),
      index_ (f, this),
      isDefault_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AttributeConsumingServiceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ServiceName
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"ServiceName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< ServiceName_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ServiceName_type > r (
              dynamic_cast< ServiceName_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ServiceName ().push_back (r);
            continue;
          }
        }

        // ServiceDescription
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"ServiceDescription",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< ServiceDescription_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ServiceDescription_type > r (
              dynamic_cast< ServiceDescription_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ServiceDescription ().push_back (r);
            continue;
          }
        }

        // RequestedAttribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"RequestedAttribute",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< RequestedAttribute_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< RequestedAttribute_type > r (
              dynamic_cast< RequestedAttribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->RequestedAttribute ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"index" && n.namespace_ ().empty ())
        {
          this->index (index_traits::create (i, f, this));
          continue;
        }

        if (n.name () == L"isDefault" && n.namespace_ ().empty ())
        {
          this->isDefault (isDefault_traits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"index",
          L"");
      }
    }

    AttributeConsumingServiceType* AttributeConsumingServiceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AttributeConsumingServiceType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeConsumingServiceType >
    _xsd_AttributeConsumingServiceType_type_factory_init (
      L"AttributeConsumingServiceType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // RequestedAttributeType
    //

    RequestedAttributeType::
    RequestedAttributeType ()
    : ::saml2::assertion::AttributeType (),
      isRequired_ (::xml_schema::flags (), this)
    {
    }

    RequestedAttributeType::
    RequestedAttributeType (const Name_type& Name)
    : ::saml2::assertion::AttributeType (Name),
      isRequired_ (::xml_schema::flags (), this)
    {
    }

    RequestedAttributeType::
    RequestedAttributeType (const RequestedAttributeType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::assertion::AttributeType (x, f, c),
      isRequired_ (x.isRequired_, f, this)
    {
    }

    RequestedAttributeType::
    RequestedAttributeType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::assertion::AttributeType (e, f | ::xml_schema::flags::base, c),
      isRequired_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void RequestedAttributeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::assertion::AttributeType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"isRequired" && n.namespace_ ().empty ())
        {
          this->isRequired (isRequired_traits::create (i, f, this));
          continue;
        }
      }
    }

    RequestedAttributeType* RequestedAttributeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new RequestedAttributeType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, RequestedAttributeType >
    _xsd_RequestedAttributeType_type_factory_init (
      L"RequestedAttributeType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // AuthnAuthorityDescriptorType
    //

    AuthnAuthorityDescriptorType::
    AuthnAuthorityDescriptorType ()
    : ::saml2::metadata::RoleDescriptorType (),
      AuthnQueryService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this)
    {
    }

    AuthnAuthorityDescriptorType::
    AuthnAuthorityDescriptorType (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    : ::saml2::metadata::RoleDescriptorType (protocolSupportEnumeration),
      AuthnQueryService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this)
    {
    }

    AuthnAuthorityDescriptorType::
    AuthnAuthorityDescriptorType (const AuthnAuthorityDescriptorType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (x, f, c),
      AuthnQueryService_ (x.AuthnQueryService_, f, this),
      AssertionIDRequestService_ (x.AssertionIDRequestService_, f, this),
      NameIDFormat_ (x.NameIDFormat_, f, this)
    {
    }

    AuthnAuthorityDescriptorType::
    AuthnAuthorityDescriptorType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (e, f | ::xml_schema::flags::base, c),
      AuthnQueryService_ (f, this),
      AssertionIDRequestService_ (f, this),
      NameIDFormat_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AuthnAuthorityDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::metadata::RoleDescriptorType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AuthnQueryService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnQueryService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AuthnQueryService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthnQueryService_type > r (
              dynamic_cast< AuthnQueryService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthnQueryService ().push_back (r);
            continue;
          }
        }

        // AssertionIDRequestService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AssertionIDRequestService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionIDRequestService_type > r (
              dynamic_cast< AssertionIDRequestService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionIDRequestService ().push_back (r);
            continue;
          }
        }

        // NameIDFormat
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< NameIDFormat_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< NameIDFormat_type > r (
              dynamic_cast< NameIDFormat_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->NameIDFormat ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AuthnAuthorityDescriptorType* AuthnAuthorityDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnAuthorityDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnAuthorityDescriptorType >
    _xsd_AuthnAuthorityDescriptorType_type_factory_init (
      L"AuthnAuthorityDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // PDPDescriptorType
    //

    PDPDescriptorType::
    PDPDescriptorType ()
    : ::saml2::metadata::RoleDescriptorType (),
      AuthzService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this)
    {
    }

    PDPDescriptorType::
    PDPDescriptorType (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    : ::saml2::metadata::RoleDescriptorType (protocolSupportEnumeration),
      AuthzService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this)
    {
    }

    PDPDescriptorType::
    PDPDescriptorType (const PDPDescriptorType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (x, f, c),
      AuthzService_ (x.AuthzService_, f, this),
      AssertionIDRequestService_ (x.AssertionIDRequestService_, f, this),
      NameIDFormat_ (x.NameIDFormat_, f, this)
    {
    }

    PDPDescriptorType::
    PDPDescriptorType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (e, f | ::xml_schema::flags::base, c),
      AuthzService_ (f, this),
      AssertionIDRequestService_ (f, this),
      NameIDFormat_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void PDPDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::metadata::RoleDescriptorType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AuthzService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthzService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AuthzService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthzService_type > r (
              dynamic_cast< AuthzService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthzService ().push_back (r);
            continue;
          }
        }

        // AssertionIDRequestService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AssertionIDRequestService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionIDRequestService_type > r (
              dynamic_cast< AssertionIDRequestService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionIDRequestService ().push_back (r);
            continue;
          }
        }

        // NameIDFormat
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< NameIDFormat_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< NameIDFormat_type > r (
              dynamic_cast< NameIDFormat_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->NameIDFormat ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    PDPDescriptorType* PDPDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new PDPDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, PDPDescriptorType >
    _xsd_PDPDescriptorType_type_factory_init (
      L"PDPDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // AttributeAuthorityDescriptorType
    //

    AttributeAuthorityDescriptorType::
    AttributeAuthorityDescriptorType ()
    : ::saml2::metadata::RoleDescriptorType (),
      AttributeService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this),
      AttributeProfile_ (::xml_schema::flags (), this),
      Attribute_ (::xml_schema::flags (), this)
    {
    }

    AttributeAuthorityDescriptorType::
    AttributeAuthorityDescriptorType (const protocolSupportEnumeration_type& protocolSupportEnumeration)
    : ::saml2::metadata::RoleDescriptorType (protocolSupportEnumeration),
      AttributeService_ (::xml_schema::flags (), this),
      AssertionIDRequestService_ (::xml_schema::flags (), this),
      NameIDFormat_ (::xml_schema::flags (), this),
      AttributeProfile_ (::xml_schema::flags (), this),
      Attribute_ (::xml_schema::flags (), this)
    {
    }

    AttributeAuthorityDescriptorType::
    AttributeAuthorityDescriptorType (const AttributeAuthorityDescriptorType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (x, f, c),
      AttributeService_ (x.AttributeService_, f, this),
      AssertionIDRequestService_ (x.AssertionIDRequestService_, f, this),
      NameIDFormat_ (x.NameIDFormat_, f, this),
      AttributeProfile_ (x.AttributeProfile_, f, this),
      Attribute_ (x.Attribute_, f, this)
    {
    }

    AttributeAuthorityDescriptorType::
    AttributeAuthorityDescriptorType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::type* c)
    : ::saml2::metadata::RoleDescriptorType (e, f | ::xml_schema::flags::base, c),
      AttributeService_ (f, this),
      AssertionIDRequestService_ (f, this),
      NameIDFormat_ (f, this),
      AttributeProfile_ (f, this),
      Attribute_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AttributeAuthorityDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::saml2::metadata::RoleDescriptorType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AttributeService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AttributeService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AttributeService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AttributeService_type > r (
              dynamic_cast< AttributeService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AttributeService ().push_back (r);
            continue;
          }
        }

        // AssertionIDRequestService
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AssertionIDRequestService_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionIDRequestService_type > r (
              dynamic_cast< AssertionIDRequestService_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionIDRequestService ().push_back (r);
            continue;
          }
        }

        // NameIDFormat
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< NameIDFormat_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< NameIDFormat_type > r (
              dynamic_cast< NameIDFormat_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->NameIDFormat ().push_back (r);
            continue;
          }
        }

        // AttributeProfile
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AttributeProfile",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AttributeProfile_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AttributeProfile_type > r (
              dynamic_cast< AttributeProfile_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AttributeProfile ().push_back (r);
            continue;
          }
        }

        // Attribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Attribute_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Attribute_type > r (
              dynamic_cast< Attribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Attribute ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AttributeAuthorityDescriptorType* AttributeAuthorityDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AttributeAuthorityDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeAuthorityDescriptorType >
    _xsd_AttributeAuthorityDescriptorType_type_factory_init (
      L"AttributeAuthorityDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    // AffiliationDescriptorType
    //

    AffiliationDescriptorType::
    AffiliationDescriptorType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      AffiliateMember_ (::xml_schema::flags (), this),
      KeyDescriptor_ (::xml_schema::flags (), this),
      affiliationOwnerID_ (::xml_schema::flags (), this),
      validUntil_ (::xml_schema::flags (), this),
      cacheDuration_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    AffiliationDescriptorType::
    AffiliationDescriptorType (const affiliationOwnerID_type& affiliationOwnerID)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (::xml_schema::flags (), this),
      Extensions_ (::xml_schema::flags (), this),
      AffiliateMember_ (::xml_schema::flags (), this),
      KeyDescriptor_ (::xml_schema::flags (), this),
      affiliationOwnerID_ (affiliationOwnerID, ::xml_schema::flags (), this),
      validUntil_ (::xml_schema::flags (), this),
      cacheDuration_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    AffiliationDescriptorType::
    AffiliationDescriptorType (const AffiliationDescriptorType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (x.Signature_, f, this),
      Extensions_ (x.Extensions_, f, this),
      AffiliateMember_ (x.AffiliateMember_, f, this),
      KeyDescriptor_ (x.KeyDescriptor_, f, this),
      affiliationOwnerID_ (x.affiliationOwnerID_, f, this),
      validUntil_ (x.validUntil_, f, this),
      cacheDuration_ (x.cacheDuration_, f, this),
      ID_ (x.ID_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    AffiliationDescriptorType::
    AffiliationDescriptorType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Signature_ (f, this),
      Extensions_ (f, this),
      AffiliateMember_ (f, this),
      KeyDescriptor_ (f, this),
      affiliationOwnerID_ (f, this),
      validUntil_ (f, this),
      cacheDuration_ (f, this),
      ID_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AffiliationDescriptorType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Signature_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Signature ())
            {
              ::std::auto_ptr< Signature_type > r (
                dynamic_cast< Signature_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Signature (r);
              continue;
            }
          }
        }

        // Extensions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< Extensions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Extensions ())
            {
              ::std::auto_ptr< Extensions_type > r (
                dynamic_cast< Extensions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Extensions (r);
              continue;
            }
          }
        }

        // AffiliateMember
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AffiliateMember",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< AffiliateMember_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AffiliateMember_type > r (
              dynamic_cast< AffiliateMember_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AffiliateMember ().push_back (r);
            continue;
          }
        }

        // KeyDescriptor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"KeyDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              &::xsd::cxx::tree::factory_impl< KeyDescriptor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< KeyDescriptor_type > r (
              dynamic_cast< KeyDescriptor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->KeyDescriptor ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"affiliationOwnerID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< affiliationOwnerID_type > r (
            affiliationOwnerID_traits::create (i, f, this));

          this->affiliationOwnerID (r);
          continue;
        }

        if (n.name () == L"validUntil" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validUntil_type > r (
            validUntil_traits::create (i, f, this));

          this->validUntil (r);
          continue;
        }

        if (n.name () == L"cacheDuration" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< cacheDuration_type > r (
            cacheDuration_traits::create (i, f, this));

          this->cacheDuration (r);
          continue;
        }

        if (n.name () == L"ID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID_type > r (
            ID_traits::create (i, f, this));

          this->ID (r);
          continue;
        }

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:metadata" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }

      if (!affiliationOwnerID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"affiliationOwnerID",
          L"");
      }
    }

    AffiliationDescriptorType* AffiliationDescriptorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AffiliationDescriptorType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AffiliationDescriptorType >
    _xsd_AffiliationDescriptorType_type_factory_init (
      L"AffiliationDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace saml2
{
  namespace metadata
  {
    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (const ::std::wstring& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
        ::saml2::metadata::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (const ::std::wstring& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
        ::saml2::metadata::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (const ::std::wstring& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
        ::saml2::metadata::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Extensions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Extensions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (::std::istream& is,
                const ::std::wstring& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Extensions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
        ::saml2::metadata::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (const ::xercesc::DOMInputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
        ::saml2::metadata::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
        ::saml2::metadata::Extensions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
          ::saml2::metadata::Extensions (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Extensions",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::ExtensionsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
          dynamic_cast< ::saml2::metadata::ExtensionsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Extensions",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::ExtensionsType >
    Extensions (::xercesc::DOMDocument* d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Extensions",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::ExtensionsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::ExtensionsType > r (
          dynamic_cast< ::saml2::metadata::ExtensionsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Extensions",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
        ::saml2::metadata::EntitiesDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
        ::saml2::metadata::EntitiesDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
        ::saml2::metadata::EntitiesDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntitiesDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntitiesDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntitiesDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntitiesDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntitiesDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntitiesDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
        ::saml2::metadata::EntitiesDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
        ::saml2::metadata::EntitiesDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
        ::saml2::metadata::EntitiesDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
          ::saml2::metadata::EntitiesDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EntitiesDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EntitiesDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
          dynamic_cast< ::saml2::metadata::EntitiesDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EntitiesDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType >
    EntitiesDescriptor (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EntitiesDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EntitiesDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EntitiesDescriptorType > r (
          dynamic_cast< ::saml2::metadata::EntitiesDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EntitiesDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
        ::saml2::metadata::EntityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
        ::saml2::metadata::EntityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
        ::saml2::metadata::EntityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntityDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntityDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EntityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
        ::saml2::metadata::EntityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
        ::saml2::metadata::EntityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
        ::saml2::metadata::EntityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
          ::saml2::metadata::EntityDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EntityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EntityDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
          dynamic_cast< ::saml2::metadata::EntityDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EntityDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType >
    EntityDescriptor (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EntityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EntityDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EntityDescriptorType > r (
          dynamic_cast< ::saml2::metadata::EntityDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EntityDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
        ::saml2::metadata::Organization (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
        ::saml2::metadata::Organization (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
        ::saml2::metadata::Organization (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Organization (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Organization (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Organization (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Organization (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Organization (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Organization (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
        ::saml2::metadata::Organization (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
        ::saml2::metadata::Organization (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
        ::saml2::metadata::Organization (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
          ::saml2::metadata::Organization (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Organization",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::OrganizationType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
          dynamic_cast< ::saml2::metadata::OrganizationType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Organization",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::OrganizationType >
    Organization (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Organization",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::OrganizationType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::OrganizationType > r (
          dynamic_cast< ::saml2::metadata::OrganizationType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Organization",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationName (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationName (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          ::saml2::metadata::OrganizationName (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OrganizationName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OrganizationName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationName (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OrganizationName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OrganizationName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (const ::std::wstring& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationDisplayName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (const ::std::wstring& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationDisplayName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (const ::std::wstring& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationDisplayName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationDisplayName (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationDisplayName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationDisplayName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationDisplayName (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationDisplayName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationDisplayName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationDisplayName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationDisplayName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (const ::xercesc::DOMInputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::OrganizationDisplayName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          ::saml2::metadata::OrganizationDisplayName (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OrganizationDisplayName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OrganizationDisplayName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    OrganizationDisplayName (::xercesc::DOMDocument* d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OrganizationDisplayName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OrganizationDisplayName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
        ::saml2::metadata::OrganizationURL (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
        ::saml2::metadata::OrganizationURL (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
        ::saml2::metadata::OrganizationURL (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationURL (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationURL (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationURL (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationURL (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationURL (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::OrganizationURL (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
        ::saml2::metadata::OrganizationURL (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
        ::saml2::metadata::OrganizationURL (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
        ::saml2::metadata::OrganizationURL (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
          ::saml2::metadata::OrganizationURL (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OrganizationURL",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedURIType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
          dynamic_cast< ::saml2::metadata::localizedURIType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OrganizationURL",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedURIType >
    OrganizationURL (::xercesc::DOMDocument* d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OrganizationURL",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedURIType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::localizedURIType > r (
          dynamic_cast< ::saml2::metadata::localizedURIType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OrganizationURL",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (const ::std::wstring& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::ContactType > r (
        ::saml2::metadata::ContactPerson (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (const ::std::wstring& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ContactType > r (
        ::saml2::metadata::ContactPerson (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (const ::std::wstring& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ContactType > r (
        ::saml2::metadata::ContactPerson (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ContactPerson (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ContactPerson (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ContactPerson (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ContactPerson (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ContactPerson (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ContactPerson (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::ContactType > r (
        ::saml2::metadata::ContactPerson (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ContactType > r (
        ::saml2::metadata::ContactPerson (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (const ::xercesc::DOMInputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::ContactType > r (
        ::saml2::metadata::ContactPerson (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::ContactType > r (
          ::saml2::metadata::ContactPerson (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ContactPerson",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::ContactType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::ContactType > r (
          dynamic_cast< ::saml2::metadata::ContactType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ContactPerson",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::ContactType >
    ContactPerson (::xercesc::DOMDocument* d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ContactPerson",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::ContactType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::ContactType > r (
          dynamic_cast< ::saml2::metadata::ContactType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ContactPerson",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::Company (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::Company (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::Company (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Company (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Company (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Company (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Company (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Company (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::Company (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::Company (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (const ::xercesc::DOMInputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::Company (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::Company (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::metadata::Company (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Company",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Company",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    Company (::xercesc::DOMDocument* d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Company",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Company",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::GivenName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::GivenName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::GivenName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::GivenName (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::GivenName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::GivenName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::GivenName (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::GivenName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::GivenName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::GivenName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (const ::xercesc::DOMInputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::GivenName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::GivenName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::metadata::GivenName (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"GivenName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"GivenName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    GivenName (::xercesc::DOMDocument* d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"GivenName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"GivenName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::SurName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::SurName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::SurName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SurName (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SurName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SurName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SurName (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SurName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SurName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::SurName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (const ::xercesc::DOMInputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::SurName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::SurName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::metadata::SurName (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SurName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SurName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    SurName (::xercesc::DOMDocument* d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SurName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SurName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::EmailAddress (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::EmailAddress (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::EmailAddress (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EmailAddress (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EmailAddress (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EmailAddress (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EmailAddress (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EmailAddress (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EmailAddress (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::EmailAddress (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::EmailAddress (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::EmailAddress (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::metadata::EmailAddress (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EmailAddress",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EmailAddress",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    EmailAddress (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EmailAddress",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EmailAddress",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::TelephoneNumber (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::TelephoneNumber (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::TelephoneNumber (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::TelephoneNumber (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::TelephoneNumber (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::TelephoneNumber (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::TelephoneNumber (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::TelephoneNumber (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::TelephoneNumber (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::TelephoneNumber (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::TelephoneNumber (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::string > r (
        ::saml2::metadata::TelephoneNumber (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::string > r (
          ::saml2::metadata::TelephoneNumber (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"TelephoneNumber",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"TelephoneNumber",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::string >
    TelephoneNumber (::xercesc::DOMDocument* d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"TelephoneNumber",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::string >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::string > r (
          dynamic_cast< ::xml_schema::string* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"TelephoneNumber",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (const ::std::wstring& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
        ::saml2::metadata::AdditionalMetadataLocation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (const ::std::wstring& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
        ::saml2::metadata::AdditionalMetadataLocation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (const ::std::wstring& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
        ::saml2::metadata::AdditionalMetadataLocation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AdditionalMetadataLocation (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AdditionalMetadataLocation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AdditionalMetadataLocation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (::std::istream& is,
                                const ::std::wstring& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AdditionalMetadataLocation (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (::std::istream& is,
                                const ::std::wstring& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AdditionalMetadataLocation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (::std::istream& is,
                                const ::std::wstring& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AdditionalMetadataLocation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (const ::xercesc::DOMInputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
        ::saml2::metadata::AdditionalMetadataLocation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (const ::xercesc::DOMInputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
        ::saml2::metadata::AdditionalMetadataLocation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (const ::xercesc::DOMInputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
        ::saml2::metadata::AdditionalMetadataLocation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (const ::xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
          ::saml2::metadata::AdditionalMetadataLocation (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AdditionalMetadataLocation",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AdditionalMetadataLocationType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
          dynamic_cast< ::saml2::metadata::AdditionalMetadataLocationType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AdditionalMetadataLocation",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType >
    AdditionalMetadataLocation (::xercesc::DOMDocument* d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AdditionalMetadataLocation",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AdditionalMetadataLocationType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::AdditionalMetadataLocationType > r (
          dynamic_cast< ::saml2::metadata::AdditionalMetadataLocationType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AdditionalMetadataLocation",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
        ::saml2::metadata::RoleDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
        ::saml2::metadata::RoleDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
        ::saml2::metadata::RoleDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RoleDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RoleDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RoleDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RoleDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RoleDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RoleDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
        ::saml2::metadata::RoleDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
        ::saml2::metadata::RoleDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
        ::saml2::metadata::RoleDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
          ::saml2::metadata::RoleDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RoleDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::RoleDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
          dynamic_cast< ::saml2::metadata::RoleDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RoleDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType >
    RoleDescriptor (::xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RoleDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::RoleDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::RoleDescriptorType > r (
          dynamic_cast< ::saml2::metadata::RoleDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RoleDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (const ::std::wstring& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
        ::saml2::metadata::KeyDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (const ::std::wstring& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
        ::saml2::metadata::KeyDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (const ::std::wstring& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
        ::saml2::metadata::KeyDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::KeyDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::KeyDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::KeyDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::KeyDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::KeyDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::KeyDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
        ::saml2::metadata::KeyDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
        ::saml2::metadata::KeyDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (const ::xercesc::DOMInputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
        ::saml2::metadata::KeyDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
          ::saml2::metadata::KeyDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"KeyDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::KeyDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
          dynamic_cast< ::saml2::metadata::KeyDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"KeyDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType >
    KeyDescriptor (::xercesc::DOMDocument* d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"KeyDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::KeyDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::KeyDescriptorType > r (
          dynamic_cast< ::saml2::metadata::KeyDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"KeyDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
        ::saml2::metadata::EncryptionMethod (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
        ::saml2::metadata::EncryptionMethod (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
        ::saml2::metadata::EncryptionMethod (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EncryptionMethod (wrap, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EncryptionMethod (wrap, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EncryptionMethod (wrap, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EncryptionMethod (wrap, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EncryptionMethod (wrap, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::EncryptionMethod (wrap, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
        ::saml2::metadata::EncryptionMethod (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
        ::saml2::metadata::EncryptionMethod (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
        ::saml2::metadata::EncryptionMethod (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
          ::saml2::metadata::EncryptionMethod (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptionMethod",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptionMethodType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
          dynamic_cast< ::w3::xmlenc::EncryptionMethodType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptionMethod",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType >
    EncryptionMethod (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptionMethod",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptionMethodType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::w3::xmlenc::EncryptionMethodType > r (
          dynamic_cast< ::w3::xmlenc::EncryptionMethodType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptionMethod",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (const ::std::wstring& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::ArtifactResolutionService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (const ::std::wstring& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::ArtifactResolutionService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (const ::std::wstring& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::ArtifactResolutionService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ArtifactResolutionService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ArtifactResolutionService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ArtifactResolutionService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ArtifactResolutionService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ArtifactResolutionService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ArtifactResolutionService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (const ::xercesc::DOMInputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::ArtifactResolutionService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (const ::xercesc::DOMInputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::ArtifactResolutionService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (const ::xercesc::DOMInputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::ArtifactResolutionService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
          ::saml2::metadata::ArtifactResolutionService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ArtifactResolutionService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::IndexedEndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
          dynamic_cast< ::saml2::metadata::IndexedEndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ArtifactResolutionService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    ArtifactResolutionService (::xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ArtifactResolutionService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::IndexedEndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
          dynamic_cast< ::saml2::metadata::IndexedEndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ArtifactResolutionService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (const ::std::wstring& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleLogoutService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (const ::std::wstring& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleLogoutService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (const ::std::wstring& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleLogoutService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleLogoutService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleLogoutService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleLogoutService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleLogoutService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleLogoutService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleLogoutService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleLogoutService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleLogoutService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleLogoutService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::SingleLogoutService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SingleLogoutService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SingleLogoutService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleLogoutService (::xercesc::DOMDocument* d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SingleLogoutService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SingleLogoutService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (const ::std::wstring& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::ManageNameIDService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (const ::std::wstring& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::ManageNameIDService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (const ::std::wstring& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::ManageNameIDService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ManageNameIDService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ManageNameIDService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ManageNameIDService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ManageNameIDService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ManageNameIDService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ManageNameIDService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::ManageNameIDService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::ManageNameIDService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::ManageNameIDService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::ManageNameIDService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ManageNameIDService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ManageNameIDService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    ManageNameIDService (::xercesc::DOMDocument* d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ManageNameIDService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ManageNameIDService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::NameIDFormat (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::NameIDFormat (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::NameIDFormat (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDFormat (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDFormat (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDFormat (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDFormat (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDFormat (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDFormat (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::NameIDFormat (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::NameIDFormat (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::NameIDFormat (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::metadata::NameIDFormat (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDFormat",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDFormat",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    NameIDFormat (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDFormat",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDFormat",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
        ::saml2::metadata::IDPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
        ::saml2::metadata::IDPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
        ::saml2::metadata::IDPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::IDPSSODescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::IDPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::IDPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::IDPSSODescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::IDPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::IDPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
        ::saml2::metadata::IDPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
        ::saml2::metadata::IDPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
        ::saml2::metadata::IDPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
          ::saml2::metadata::IDPSSODescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"IDPSSODescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::IDPSSODescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
          dynamic_cast< ::saml2::metadata::IDPSSODescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"IDPSSODescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType >
    IDPSSODescriptor (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"IDPSSODescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::IDPSSODescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::IDPSSODescriptorType > r (
          dynamic_cast< ::saml2::metadata::IDPSSODescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"IDPSSODescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (const ::std::wstring& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleSignOnService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (const ::std::wstring& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleSignOnService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (const ::std::wstring& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleSignOnService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleSignOnService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleSignOnService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleSignOnService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleSignOnService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleSignOnService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SingleSignOnService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleSignOnService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleSignOnService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::SingleSignOnService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::SingleSignOnService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SingleSignOnService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SingleSignOnService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    SingleSignOnService (::xercesc::DOMDocument* d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SingleSignOnService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SingleSignOnService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (const ::std::wstring& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::NameIDMappingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (const ::std::wstring& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::NameIDMappingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (const ::std::wstring& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::NameIDMappingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDMappingService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDMappingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDMappingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDMappingService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDMappingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::NameIDMappingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::NameIDMappingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::NameIDMappingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (const ::xercesc::DOMInputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::NameIDMappingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::NameIDMappingService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDMappingService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDMappingService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    NameIDMappingService (::xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameIDMappingService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameIDMappingService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (const ::std::wstring& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AssertionIDRequestService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (const ::std::wstring& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AssertionIDRequestService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (const ::std::wstring& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AssertionIDRequestService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionIDRequestService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionIDRequestService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionIDRequestService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionIDRequestService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionIDRequestService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionIDRequestService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (const ::xercesc::DOMInputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AssertionIDRequestService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (const ::xercesc::DOMInputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AssertionIDRequestService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (const ::xercesc::DOMInputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AssertionIDRequestService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::AssertionIDRequestService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionIDRequestService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionIDRequestService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AssertionIDRequestService (::xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionIDRequestService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionIDRequestService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::AttributeProfile (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::AttributeProfile (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::AttributeProfile (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeProfile (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeProfile (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeProfile (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeProfile (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeProfile (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeProfile (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::AttributeProfile (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::AttributeProfile (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::metadata::AttributeProfile (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::metadata::AttributeProfile (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeProfile",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeProfile",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AttributeProfile (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeProfile",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeProfile",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
        ::saml2::metadata::SPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
        ::saml2::metadata::SPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
        ::saml2::metadata::SPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SPSSODescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SPSSODescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::SPSSODescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
        ::saml2::metadata::SPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
        ::saml2::metadata::SPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
        ::saml2::metadata::SPSSODescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
          ::saml2::metadata::SPSSODescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SPSSODescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::SPSSODescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
          dynamic_cast< ::saml2::metadata::SPSSODescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SPSSODescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType >
    SPSSODescriptor (::xercesc::DOMDocument* d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SPSSODescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::SPSSODescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::SPSSODescriptorType > r (
          dynamic_cast< ::saml2::metadata::SPSSODescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SPSSODescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (const ::std::wstring& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::AssertionConsumerService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (const ::std::wstring& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::AssertionConsumerService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (const ::std::wstring& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::AssertionConsumerService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionConsumerService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionConsumerService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionConsumerService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (::std::istream& is,
                              const ::std::wstring& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionConsumerService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (::std::istream& is,
                              const ::std::wstring& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionConsumerService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (::std::istream& is,
                              const ::std::wstring& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AssertionConsumerService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (const ::xercesc::DOMInputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::AssertionConsumerService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (const ::xercesc::DOMInputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::AssertionConsumerService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (const ::xercesc::DOMInputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
        ::saml2::metadata::AssertionConsumerService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
          ::saml2::metadata::AssertionConsumerService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionConsumerService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::IndexedEndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
          dynamic_cast< ::saml2::metadata::IndexedEndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionConsumerService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType >
    AssertionConsumerService (::xercesc::DOMDocument* d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionConsumerService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::IndexedEndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::IndexedEndpointType > r (
          dynamic_cast< ::saml2::metadata::IndexedEndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionConsumerService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (const ::std::wstring& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
        ::saml2::metadata::AttributeConsumingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (const ::std::wstring& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
        ::saml2::metadata::AttributeConsumingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (const ::std::wstring& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
        ::saml2::metadata::AttributeConsumingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeConsumingService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeConsumingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeConsumingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeConsumingService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeConsumingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (::std::istream& is,
                               const ::std::wstring& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeConsumingService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (const ::xercesc::DOMInputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
        ::saml2::metadata::AttributeConsumingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (const ::xercesc::DOMInputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
        ::saml2::metadata::AttributeConsumingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (const ::xercesc::DOMInputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
        ::saml2::metadata::AttributeConsumingService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
          ::saml2::metadata::AttributeConsumingService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeConsumingService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AttributeConsumingServiceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
          dynamic_cast< ::saml2::metadata::AttributeConsumingServiceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeConsumingService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType >
    AttributeConsumingService (::xercesc::DOMDocument* d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeConsumingService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AttributeConsumingServiceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::AttributeConsumingServiceType > r (
          dynamic_cast< ::saml2::metadata::AttributeConsumingServiceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeConsumingService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (const ::std::wstring& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (const ::std::wstring& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (const ::std::wstring& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceName (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceName (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceName (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (const ::xercesc::DOMInputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceName (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          ::saml2::metadata::ServiceName (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ServiceName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ServiceName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceName (::xercesc::DOMDocument* d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ServiceName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ServiceName",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceDescription (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceDescription (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceDescription (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceDescription (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceDescription (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceDescription (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceDescription (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceDescription (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::ServiceDescription (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceDescription (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceDescription (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
        ::saml2::metadata::ServiceDescription (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          ::saml2::metadata::ServiceDescription (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ServiceDescription",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ServiceDescription",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::localizedNameType >
    ServiceDescription (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ServiceDescription",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::localizedNameType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::localizedNameType > r (
          dynamic_cast< ::saml2::metadata::localizedNameType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ServiceDescription",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
        ::saml2::metadata::RequestedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
        ::saml2::metadata::RequestedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
        ::saml2::metadata::RequestedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RequestedAttribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RequestedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RequestedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RequestedAttribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RequestedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::RequestedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
        ::saml2::metadata::RequestedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
        ::saml2::metadata::RequestedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
        ::saml2::metadata::RequestedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
          ::saml2::metadata::RequestedAttribute (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RequestedAttribute",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::RequestedAttributeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
          dynamic_cast< ::saml2::metadata::RequestedAttributeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RequestedAttribute",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType >
    RequestedAttribute (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"RequestedAttribute",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::RequestedAttributeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::RequestedAttributeType > r (
          dynamic_cast< ::saml2::metadata::RequestedAttributeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"RequestedAttribute",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (const ::std::wstring& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
        ::saml2::metadata::AuthnAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (const ::std::wstring& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
        ::saml2::metadata::AuthnAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (const ::std::wstring& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
        ::saml2::metadata::AuthnAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnAuthorityDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (::std::istream& is,
                              const ::std::wstring& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnAuthorityDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (::std::istream& is,
                              const ::std::wstring& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (::std::istream& is,
                              const ::std::wstring& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (const ::xercesc::DOMInputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
        ::saml2::metadata::AuthnAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (const ::xercesc::DOMInputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
        ::saml2::metadata::AuthnAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (const ::xercesc::DOMInputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
        ::saml2::metadata::AuthnAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
          ::saml2::metadata::AuthnAuthorityDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnAuthorityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AuthnAuthorityDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
          dynamic_cast< ::saml2::metadata::AuthnAuthorityDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnAuthorityDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType >
    AuthnAuthorityDescriptor (::xercesc::DOMDocument* d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnAuthorityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AuthnAuthorityDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::AuthnAuthorityDescriptorType > r (
          dynamic_cast< ::saml2::metadata::AuthnAuthorityDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnAuthorityDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (const ::std::wstring& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthnQueryService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (const ::std::wstring& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthnQueryService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (const ::std::wstring& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthnQueryService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnQueryService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnQueryService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnQueryService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (::std::istream& is,
                       const ::std::wstring& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnQueryService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (::std::istream& is,
                       const ::std::wstring& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnQueryService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (::std::istream& is,
                       const ::std::wstring& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthnQueryService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (const ::xercesc::DOMInputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthnQueryService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (const ::xercesc::DOMInputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthnQueryService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (const ::xercesc::DOMInputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthnQueryService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::AuthnQueryService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnQueryService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnQueryService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthnQueryService (::xercesc::DOMDocument* d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnQueryService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnQueryService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (const ::std::wstring& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
        ::saml2::metadata::PDPDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (const ::std::wstring& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
        ::saml2::metadata::PDPDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (const ::std::wstring& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
        ::saml2::metadata::PDPDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::PDPDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::PDPDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::PDPDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::PDPDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::PDPDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::PDPDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
        ::saml2::metadata::PDPDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (const ::xercesc::DOMInputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
        ::saml2::metadata::PDPDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (const ::xercesc::DOMInputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
        ::saml2::metadata::PDPDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
          ::saml2::metadata::PDPDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"PDPDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::PDPDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
          dynamic_cast< ::saml2::metadata::PDPDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"PDPDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType >
    PDPDescriptor (::xercesc::DOMDocument* d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"PDPDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::PDPDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::PDPDescriptorType > r (
          dynamic_cast< ::saml2::metadata::PDPDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"PDPDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthzService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthzService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthzService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthzService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthzService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthzService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthzService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthzService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AuthzService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthzService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthzService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AuthzService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::AuthzService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthzService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthzService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AuthzService (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthzService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthzService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (const ::std::wstring& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
        ::saml2::metadata::AttributeAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (const ::std::wstring& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
        ::saml2::metadata::AttributeAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (const ::std::wstring& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
        ::saml2::metadata::AttributeAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeAuthorityDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (::std::istream& is,
                                  const ::std::wstring& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeAuthorityDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (::std::istream& is,
                                  const ::std::wstring& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (::std::istream& is,
                                  const ::std::wstring& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeAuthorityDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (const ::xercesc::DOMInputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
        ::saml2::metadata::AttributeAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (const ::xercesc::DOMInputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
        ::saml2::metadata::AttributeAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (const ::xercesc::DOMInputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
        ::saml2::metadata::AttributeAuthorityDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
          ::saml2::metadata::AttributeAuthorityDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeAuthorityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AttributeAuthorityDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
          dynamic_cast< ::saml2::metadata::AttributeAuthorityDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeAuthorityDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType >
    AttributeAuthorityDescriptor (::xercesc::DOMDocument* d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeAuthorityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AttributeAuthorityDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::AttributeAuthorityDescriptorType > r (
          dynamic_cast< ::saml2::metadata::AttributeAuthorityDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeAuthorityDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AttributeService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AttributeService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AttributeService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeService (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AttributeService (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AttributeService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AttributeService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
        ::saml2::metadata::AttributeService (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          ::saml2::metadata::AttributeService (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::EndpointType >
    AttributeService (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::EndpointType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::EndpointType > r (
          dynamic_cast< ::saml2::metadata::EndpointType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeService",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (const ::std::wstring& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
        ::saml2::metadata::AffiliationDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (const ::std::wstring& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
        ::saml2::metadata::AffiliationDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (const ::std::wstring& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
        ::saml2::metadata::AffiliationDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliationDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliationDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliationDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliationDescriptor (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliationDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (::std::istream& is,
                           const ::std::wstring& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliationDescriptor (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (const ::xercesc::DOMInputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
        ::saml2::metadata::AffiliationDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (const ::xercesc::DOMInputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
        ::saml2::metadata::AffiliationDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (const ::xercesc::DOMInputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
        ::saml2::metadata::AffiliationDescriptor (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
          ::saml2::metadata::AffiliationDescriptor (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AffiliationDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AffiliationDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
          dynamic_cast< ::saml2::metadata::AffiliationDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AffiliationDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType >
    AffiliationDescriptor (::xercesc::DOMDocument* d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AffiliationDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::AffiliationDescriptorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::AffiliationDescriptorType > r (
          dynamic_cast< ::saml2::metadata::AffiliationDescriptorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AffiliationDescriptor",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
        ::saml2::metadata::AffiliateMember (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
        ::saml2::metadata::AffiliateMember (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
        ::saml2::metadata::AffiliateMember (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliateMember (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliateMember (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliateMember (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliateMember (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliateMember (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::metadata::AffiliateMember (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
        ::saml2::metadata::AffiliateMember (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
        ::saml2::metadata::AffiliateMember (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
        ::saml2::metadata::AffiliateMember (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
          ::saml2::metadata::AffiliateMember (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AffiliateMember",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::entityIDType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
          dynamic_cast< ::saml2::metadata::entityIDType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AffiliateMember",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }

    ::std::auto_ptr< ::saml2::metadata::entityIDType >
    AffiliateMember (::xercesc::DOMDocument* d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AffiliateMember",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          &::xsd::cxx::tree::factory_impl< ::saml2::metadata::entityIDType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::metadata::entityIDType > r (
          dynamic_cast< ::saml2::metadata::entityIDType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AffiliateMember",
        L"urn:oasis:names:tc:SAML:2.0:metadata");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace saml2
{
  namespace metadata
  {
    void
    operator<< (::xercesc::DOMElement& e, const entityIDType& i)
    {
      e << static_cast< const ::xml_schema::uri& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,const entityIDType& i)
    {
      a << static_cast< const ::xml_schema::uri& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const entityIDType& i)
    {
      l << static_cast< const ::xml_schema::uri& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, entityIDType >
    _xsd_entityIDType_type_serializer_init (
      L"entityIDType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    operator<< (::xercesc::DOMElement& e, const localizedNameType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      // lang
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"lang",
            L"http://www.w3.org/XML/1998/namespace",
            e));

        a << i.lang ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, localizedNameType >
    _xsd_localizedNameType_type_serializer_init (
      L"localizedNameType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    operator<< (::xercesc::DOMElement& e, const localizedURIType& i)
    {
      e << static_cast< const ::xml_schema::uri& > (i);

      // lang
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"lang",
            L"http://www.w3.org/XML/1998/namespace",
            e));

        a << i.lang ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, localizedURIType >
    _xsd_localizedURIType_type_serializer_init (
      L"localizedURIType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    Extensions (::std::ostream& o,
                const ::saml2::metadata::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Extensions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Extensions (::std::ostream& o,
                const ::saml2::metadata::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Extensions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::std::ostream& o,
                const ::saml2::metadata::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Extensions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::xercesc::XMLFormatTarget& t,
                const ::saml2::metadata::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Extensions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Extensions (::xercesc::XMLFormatTarget& t,
                const ::saml2::metadata::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Extensions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::xercesc::XMLFormatTarget& t,
                const ::saml2::metadata::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Extensions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Extensions (::xercesc::DOMDocument& d,
                const ::saml2::metadata::ExtensionsType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::ExtensionsType) == typeid (s))
      {
        if (n.name () == L"Extensions" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Extensions",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Extensions",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Extensions (const ::saml2::metadata::ExtensionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::ExtensionsType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Extensions",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Extensions",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::Extensions (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtensionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any
      //
      for (ExtensionsType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ExtensionsType >
    _xsd_ExtensionsType_type_serializer_init (
      L"ExtensionsType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    operator<< (::xercesc::DOMElement& e, const EndpointType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (EndpointType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (EndpointType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // Binding
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Binding",
            e));

        a << i.Binding ();
      }

      // Location
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Location",
            e));

        a << i.Location ();
      }

      // ResponseLocation
      //
      if (i.ResponseLocation ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ResponseLocation",
            e));

        a << *i.ResponseLocation ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EndpointType >
    _xsd_EndpointType_type_serializer_init (
      L"EndpointType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    operator<< (::xercesc::DOMElement& e, const IndexedEndpointType& i)
    {
      e << static_cast< const ::saml2::metadata::EndpointType& > (i);

      // index
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"index",
            e));

        a << i.index ();
      }

      // isDefault
      //
      if (i.isDefault ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"isDefault",
            e));

        a << *i.isDefault ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IndexedEndpointType >
    _xsd_IndexedEndpointType_type_serializer_init (
      L"IndexedEndpointType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    EntitiesDescriptor (::std::ostream& o,
                        const ::saml2::metadata::EntitiesDescriptorType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntitiesDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EntitiesDescriptor (::std::ostream& o,
                        const ::saml2::metadata::EntitiesDescriptorType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntitiesDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntitiesDescriptor (::std::ostream& o,
                        const ::saml2::metadata::EntitiesDescriptorType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntitiesDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntitiesDescriptor (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::EntitiesDescriptorType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntitiesDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EntitiesDescriptor (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::EntitiesDescriptorType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntitiesDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntitiesDescriptor (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::EntitiesDescriptorType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntitiesDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntitiesDescriptor (::xercesc::DOMDocument& d,
                        const ::saml2::metadata::EntitiesDescriptorType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EntitiesDescriptorType) == typeid (s))
      {
        if (n.name () == L"EntitiesDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EntitiesDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EntitiesDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EntitiesDescriptor (const ::saml2::metadata::EntitiesDescriptorType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EntitiesDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EntitiesDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"EntitiesDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::EntitiesDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EntitiesDescriptorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Signature
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          const EntitiesDescriptorType::Signature_type& x (*i.Signature ());
          if (typeid (EntitiesDescriptorType::Signature_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Signature",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const EntitiesDescriptorType::Extensions_type& x (*i.Extensions ());
          if (typeid (EntitiesDescriptorType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // EntityDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntitiesDescriptorType::EntityDescriptor_const_iterator
             b (i.EntityDescriptor ().begin ()), n (i.EntityDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntitiesDescriptorType::EntityDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EntityDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EntityDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // EntitiesDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntitiesDescriptorType::EntitiesDescriptor_const_iterator
             b (i.EntitiesDescriptor ().begin ()), n (i.EntitiesDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntitiesDescriptorType::EntitiesDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EntitiesDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EntitiesDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // validUntil
      //
      if (i.validUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validUntil",
            e));

        a << *i.validUntil ();
      }

      // cacheDuration
      //
      if (i.cacheDuration ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"cacheDuration",
            e));

        a << *i.cacheDuration ();
      }

      // ID
      //
      if (i.ID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ID",
            e));

        a << *i.ID ();
      }

      // Name
      //
      if (i.Name ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Name",
            e));

        a << *i.Name ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EntitiesDescriptorType >
    _xsd_EntitiesDescriptorType_type_serializer_init (
      L"EntitiesDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    EntityDescriptor (::std::ostream& o,
                      const ::saml2::metadata::EntityDescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntityDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EntityDescriptor (::std::ostream& o,
                      const ::saml2::metadata::EntityDescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntityDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntityDescriptor (::std::ostream& o,
                      const ::saml2::metadata::EntityDescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntityDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntityDescriptor (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::EntityDescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntityDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EntityDescriptor (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::EntityDescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntityDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntityDescriptor (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::EntityDescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EntityDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EntityDescriptor (::xercesc::DOMDocument& d,
                      const ::saml2::metadata::EntityDescriptorType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EntityDescriptorType) == typeid (s))
      {
        if (n.name () == L"EntityDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EntityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EntityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EntityDescriptor (const ::saml2::metadata::EntityDescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EntityDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EntityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"EntityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::EntityDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EntityDescriptorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (EntityDescriptorType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // Signature
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          const EntityDescriptorType::Signature_type& x (*i.Signature ());
          if (typeid (EntityDescriptorType::Signature_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Signature",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const EntityDescriptorType::Extensions_type& x (*i.Extensions ());
          if (typeid (EntityDescriptorType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // RoleDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::RoleDescriptor_const_iterator
             b (i.RoleDescriptor ().begin ()), n (i.RoleDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::RoleDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"RoleDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"RoleDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // IDPSSODescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::IDPSSODescriptor_const_iterator
             b (i.IDPSSODescriptor ().begin ()), n (i.IDPSSODescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::IDPSSODescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"IDPSSODescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"IDPSSODescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // SPSSODescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::SPSSODescriptor_const_iterator
             b (i.SPSSODescriptor ().begin ()), n (i.SPSSODescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::SPSSODescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SPSSODescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"SPSSODescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AuthnAuthorityDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::AuthnAuthorityDescriptor_const_iterator
             b (i.AuthnAuthorityDescriptor ().begin ()), n (i.AuthnAuthorityDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::AuthnAuthorityDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnAuthorityDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthnAuthorityDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AttributeAuthorityDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::AttributeAuthorityDescriptor_const_iterator
             b (i.AttributeAuthorityDescriptor ().begin ()), n (i.AttributeAuthorityDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::AttributeAuthorityDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AttributeAuthorityDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AttributeAuthorityDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // PDPDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::PDPDescriptor_const_iterator
             b (i.PDPDescriptor ().begin ()), n (i.PDPDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::PDPDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"PDPDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"PDPDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AffiliationDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.AffiliationDescriptor ())
        {
          const EntityDescriptorType::AffiliationDescriptor_type& x (*i.AffiliationDescriptor ());
          if (typeid (EntityDescriptorType::AffiliationDescriptor_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AffiliationDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"AffiliationDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // Organization
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Organization ())
        {
          const EntityDescriptorType::Organization_type& x (*i.Organization ());
          if (typeid (EntityDescriptorType::Organization_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Organization",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Organization",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // ContactPerson
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::ContactPerson_const_iterator
             b (i.ContactPerson ().begin ()), n (i.ContactPerson ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::ContactPerson_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ContactPerson",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"ContactPerson",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AdditionalMetadataLocation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EntityDescriptorType::AdditionalMetadataLocation_const_iterator
             b (i.AdditionalMetadataLocation ().begin ()), n (i.AdditionalMetadataLocation ().end ());
             b != n; ++b)
        {
          if (typeid (EntityDescriptorType::AdditionalMetadataLocation_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AdditionalMetadataLocation",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AdditionalMetadataLocation",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // entityID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"entityID",
            e));

        a << i.entityID ();
      }

      // validUntil
      //
      if (i.validUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validUntil",
            e));

        a << *i.validUntil ();
      }

      // cacheDuration
      //
      if (i.cacheDuration ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"cacheDuration",
            e));

        a << *i.cacheDuration ();
      }

      // ID
      //
      if (i.ID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ID",
            e));

        a << *i.ID ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EntityDescriptorType >
    _xsd_EntityDescriptorType_type_serializer_init (
      L"EntityDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    Organization (::std::ostream& o,
                  const ::saml2::metadata::OrganizationType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Organization (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Organization (::std::ostream& o,
                  const ::saml2::metadata::OrganizationType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Organization (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Organization (::std::ostream& o,
                  const ::saml2::metadata::OrganizationType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Organization (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Organization (::xercesc::XMLFormatTarget& t,
                  const ::saml2::metadata::OrganizationType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Organization (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Organization (::xercesc::XMLFormatTarget& t,
                  const ::saml2::metadata::OrganizationType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Organization (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Organization (::xercesc::XMLFormatTarget& t,
                  const ::saml2::metadata::OrganizationType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Organization (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Organization (::xercesc::DOMDocument& d,
                  const ::saml2::metadata::OrganizationType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::OrganizationType) == typeid (s))
      {
        if (n.name () == L"Organization" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Organization",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Organization",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Organization (const ::saml2::metadata::OrganizationType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::OrganizationType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Organization",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Organization",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::Organization (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OrganizationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (OrganizationType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const OrganizationType::Extensions_type& x (*i.Extensions ());
          if (typeid (OrganizationType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // OrganizationName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (OrganizationType::OrganizationName_const_iterator
             b (i.OrganizationName ().begin ()), n (i.OrganizationName ().end ());
             b != n; ++b)
        {
          if (typeid (OrganizationType::OrganizationName_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"OrganizationName",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"OrganizationName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // OrganizationDisplayName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (OrganizationType::OrganizationDisplayName_const_iterator
             b (i.OrganizationDisplayName ().begin ()), n (i.OrganizationDisplayName ().end ());
             b != n; ++b)
        {
          if (typeid (OrganizationType::OrganizationDisplayName_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"OrganizationDisplayName",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"OrganizationDisplayName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // OrganizationURL
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (OrganizationType::OrganizationURL_const_iterator
             b (i.OrganizationURL ().begin ()), n (i.OrganizationURL ().end ());
             b != n; ++b)
        {
          if (typeid (OrganizationType::OrganizationURL_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"OrganizationURL",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"OrganizationURL",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OrganizationType >
    _xsd_OrganizationType_type_serializer_init (
      L"OrganizationType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    OrganizationName (::std::ostream& o,
                      const ::saml2::metadata::localizedNameType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OrganizationName (::std::ostream& o,
                      const ::saml2::metadata::localizedNameType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationName (::std::ostream& o,
                      const ::saml2::metadata::localizedNameType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationName (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::localizedNameType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OrganizationName (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::localizedNameType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationName (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::localizedNameType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationName (::xercesc::DOMDocument& d,
                      const ::saml2::metadata::localizedNameType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
      {
        if (n.name () == L"OrganizationName" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"OrganizationName",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"OrganizationName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    OrganizationName (const ::saml2::metadata::localizedNameType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"OrganizationName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"OrganizationName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::OrganizationName (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    OrganizationDisplayName (::std::ostream& o,
                             const ::saml2::metadata::localizedNameType& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationDisplayName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OrganizationDisplayName (::std::ostream& o,
                             const ::saml2::metadata::localizedNameType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::error_handler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationDisplayName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationDisplayName (::std::ostream& o,
                             const ::saml2::metadata::localizedNameType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationDisplayName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationDisplayName (::xercesc::XMLFormatTarget& t,
                             const ::saml2::metadata::localizedNameType& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationDisplayName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OrganizationDisplayName (::xercesc::XMLFormatTarget& t,
                             const ::saml2::metadata::localizedNameType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::error_handler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationDisplayName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationDisplayName (::xercesc::XMLFormatTarget& t,
                             const ::saml2::metadata::localizedNameType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationDisplayName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationDisplayName (::xercesc::DOMDocument& d,
                             const ::saml2::metadata::localizedNameType& s,
                             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
      {
        if (n.name () == L"OrganizationDisplayName" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"OrganizationDisplayName",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"OrganizationDisplayName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    OrganizationDisplayName (const ::saml2::metadata::localizedNameType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"OrganizationDisplayName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"OrganizationDisplayName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::OrganizationDisplayName (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    OrganizationURL (::std::ostream& o,
                     const ::saml2::metadata::localizedURIType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationURL (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OrganizationURL (::std::ostream& o,
                     const ::saml2::metadata::localizedURIType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationURL (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationURL (::std::ostream& o,
                     const ::saml2::metadata::localizedURIType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationURL (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationURL (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::localizedURIType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationURL (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OrganizationURL (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::localizedURIType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationURL (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationURL (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::localizedURIType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::OrganizationURL (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OrganizationURL (::xercesc::DOMDocument& d,
                     const ::saml2::metadata::localizedURIType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::localizedURIType) == typeid (s))
      {
        if (n.name () == L"OrganizationURL" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"OrganizationURL",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"OrganizationURL",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    OrganizationURL (const ::saml2::metadata::localizedURIType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::localizedURIType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"OrganizationURL",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"OrganizationURL",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::OrganizationURL (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    ContactPerson (::std::ostream& o,
                   const ::saml2::metadata::ContactType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ContactPerson (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ContactPerson (::std::ostream& o,
                   const ::saml2::metadata::ContactType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ContactPerson (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ContactPerson (::std::ostream& o,
                   const ::saml2::metadata::ContactType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ContactPerson (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ContactPerson (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::ContactType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ContactPerson (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ContactPerson (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::ContactType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ContactPerson (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ContactPerson (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::ContactType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ContactPerson (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ContactPerson (::xercesc::DOMDocument& d,
                   const ::saml2::metadata::ContactType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::ContactType) == typeid (s))
      {
        if (n.name () == L"ContactPerson" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ContactPerson",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ContactPerson",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ContactPerson (const ::saml2::metadata::ContactType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::ContactType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ContactPerson",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ContactPerson",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::ContactPerson (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ContactType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (ContactType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const ContactType::Extensions_type& x (*i.Extensions ());
          if (typeid (ContactType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // Company
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Company ())
        {
          const ContactType::Company_type& x (*i.Company ());
          if (typeid (ContactType::Company_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Company",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Company",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // GivenName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.GivenName ())
        {
          const ContactType::GivenName_type& x (*i.GivenName ());
          if (typeid (ContactType::GivenName_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"GivenName",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"GivenName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // SurName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.SurName ())
        {
          const ContactType::SurName_type& x (*i.SurName ());
          if (typeid (ContactType::SurName_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SurName",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"SurName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // EmailAddress
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ContactType::EmailAddress_const_iterator
             b (i.EmailAddress ().begin ()), n (i.EmailAddress ().end ());
             b != n; ++b)
        {
          if (typeid (ContactType::EmailAddress_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EmailAddress",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EmailAddress",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // TelephoneNumber
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ContactType::TelephoneNumber_const_iterator
             b (i.TelephoneNumber ().begin ()), n (i.TelephoneNumber ().end ());
             b != n; ++b)
        {
          if (typeid (ContactType::TelephoneNumber_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"TelephoneNumber",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"TelephoneNumber",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // contactType
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"contactType",
            e));

        a << i.contactType ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ContactType >
    _xsd_ContactType_type_serializer_init (
      L"ContactType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    Company (::std::ostream& o,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Company (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Company (::std::ostream& o,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Company (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Company (::std::ostream& o,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Company (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Company (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Company (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Company (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Company (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Company (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::Company (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Company (::xercesc::DOMDocument& d,
             const ::xml_schema::string& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"Company" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Company",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Company",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Company (const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Company",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Company",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::Company (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    GivenName (::std::ostream& o,
               const ::xml_schema::string& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::GivenName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    GivenName (::std::ostream& o,
               const ::xml_schema::string& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::GivenName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GivenName (::std::ostream& o,
               const ::xml_schema::string& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::GivenName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GivenName (::xercesc::XMLFormatTarget& t,
               const ::xml_schema::string& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::GivenName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    GivenName (::xercesc::XMLFormatTarget& t,
               const ::xml_schema::string& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::GivenName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GivenName (::xercesc::XMLFormatTarget& t,
               const ::xml_schema::string& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::GivenName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    GivenName (::xercesc::DOMDocument& d,
               const ::xml_schema::string& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"GivenName" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"GivenName",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"GivenName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    GivenName (const ::xml_schema::string& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"GivenName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"GivenName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::GivenName (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    SurName (::std::ostream& o,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SurName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SurName (::std::ostream& o,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SurName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SurName (::std::ostream& o,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SurName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SurName (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SurName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SurName (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SurName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SurName (::xercesc::XMLFormatTarget& t,
             const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SurName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SurName (::xercesc::DOMDocument& d,
             const ::xml_schema::string& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"SurName" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SurName",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SurName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SurName (const ::xml_schema::string& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SurName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SurName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::SurName (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    EmailAddress (::std::ostream& o,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EmailAddress (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EmailAddress (::std::ostream& o,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EmailAddress (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EmailAddress (::std::ostream& o,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EmailAddress (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EmailAddress (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EmailAddress (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EmailAddress (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EmailAddress (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EmailAddress (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EmailAddress (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EmailAddress (::xercesc::DOMDocument& d,
                  const ::xml_schema::uri& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"EmailAddress" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EmailAddress",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EmailAddress",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EmailAddress (const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EmailAddress",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"EmailAddress",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::EmailAddress (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    TelephoneNumber (::std::ostream& o,
                     const ::xml_schema::string& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::TelephoneNumber (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    TelephoneNumber (::std::ostream& o,
                     const ::xml_schema::string& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::TelephoneNumber (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    TelephoneNumber (::std::ostream& o,
                     const ::xml_schema::string& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::TelephoneNumber (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    TelephoneNumber (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::string& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::TelephoneNumber (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    TelephoneNumber (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::string& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::TelephoneNumber (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    TelephoneNumber (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::string& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::TelephoneNumber (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    TelephoneNumber (::xercesc::DOMDocument& d,
                     const ::xml_schema::string& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::string) == typeid (s))
      {
        if (n.name () == L"TelephoneNumber" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"TelephoneNumber",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"TelephoneNumber",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    TelephoneNumber (const ::xml_schema::string& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::string) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"TelephoneNumber",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"TelephoneNumber",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::TelephoneNumber (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ContactTypeType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ContactTypeType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const ContactTypeType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ContactTypeType >
    _xsd_ContactTypeType_type_serializer_init (
      L"ContactTypeType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    AdditionalMetadataLocation (::std::ostream& o,
                                const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::wstring& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AdditionalMetadataLocation (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AdditionalMetadataLocation (::std::ostream& o,
                                const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                const ::xml_schema::namespace_infomap& m,
                                ::xml_schema::error_handler& h,
                                const ::std::wstring& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AdditionalMetadataLocation (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AdditionalMetadataLocation (::std::ostream& o,
                                const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                const ::xml_schema::namespace_infomap& m,
                                ::xercesc::DOMErrorHandler& h,
                                const ::std::wstring& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AdditionalMetadataLocation (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AdditionalMetadataLocation (::xercesc::XMLFormatTarget& t,
                                const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                const ::xml_schema::namespace_infomap& m,
                                const ::std::wstring& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AdditionalMetadataLocation (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AdditionalMetadataLocation (::xercesc::XMLFormatTarget& t,
                                const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                const ::xml_schema::namespace_infomap& m,
                                ::xml_schema::error_handler& h,
                                const ::std::wstring& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AdditionalMetadataLocation (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AdditionalMetadataLocation (::xercesc::XMLFormatTarget& t,
                                const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                const ::xml_schema::namespace_infomap& m,
                                ::xercesc::DOMErrorHandler& h,
                                const ::std::wstring& e,
                                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AdditionalMetadataLocation (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AdditionalMetadataLocation (::xercesc::DOMDocument& d,
                                const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::AdditionalMetadataLocationType) == typeid (s))
      {
        if (n.name () == L"AdditionalMetadataLocation" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AdditionalMetadataLocation",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AdditionalMetadataLocation",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AdditionalMetadataLocation (const ::saml2::metadata::AdditionalMetadataLocationType& s,
                                const ::xml_schema::namespace_infomap& m,
                                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::AdditionalMetadataLocationType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AdditionalMetadataLocation",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AdditionalMetadataLocation",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AdditionalMetadataLocation (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AdditionalMetadataLocationType& i)
    {
      e << static_cast< const ::xml_schema::uri& > (i);

      // namespace_
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"namespace",
            e));

        a << i.namespace_ ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AdditionalMetadataLocationType >
    _xsd_AdditionalMetadataLocationType_type_serializer_init (
      L"AdditionalMetadataLocationType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    RoleDescriptor (::std::ostream& o,
                    const ::saml2::metadata::RoleDescriptorType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RoleDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RoleDescriptor (::std::ostream& o,
                    const ::saml2::metadata::RoleDescriptorType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RoleDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RoleDescriptor (::std::ostream& o,
                    const ::saml2::metadata::RoleDescriptorType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RoleDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RoleDescriptor (::xercesc::XMLFormatTarget& t,
                    const ::saml2::metadata::RoleDescriptorType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RoleDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RoleDescriptor (::xercesc::XMLFormatTarget& t,
                    const ::saml2::metadata::RoleDescriptorType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RoleDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RoleDescriptor (::xercesc::XMLFormatTarget& t,
                    const ::saml2::metadata::RoleDescriptorType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RoleDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RoleDescriptor (::xercesc::DOMDocument& d,
                    const ::saml2::metadata::RoleDescriptorType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::RoleDescriptorType) == typeid (s))
      {
        if (n.name () == L"RoleDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"RoleDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"RoleDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    RoleDescriptor (const ::saml2::metadata::RoleDescriptorType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::RoleDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"RoleDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"RoleDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::RoleDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RoleDescriptorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (RoleDescriptorType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // Signature
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          const RoleDescriptorType::Signature_type& x (*i.Signature ());
          if (typeid (RoleDescriptorType::Signature_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Signature",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const RoleDescriptorType::Extensions_type& x (*i.Extensions ());
          if (typeid (RoleDescriptorType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // KeyDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (RoleDescriptorType::KeyDescriptor_const_iterator
             b (i.KeyDescriptor ().begin ()), n (i.KeyDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (RoleDescriptorType::KeyDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"KeyDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"KeyDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // Organization
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Organization ())
        {
          const RoleDescriptorType::Organization_type& x (*i.Organization ());
          if (typeid (RoleDescriptorType::Organization_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Organization",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Organization",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // ContactPerson
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (RoleDescriptorType::ContactPerson_const_iterator
             b (i.ContactPerson ().begin ()), n (i.ContactPerson ().end ());
             b != n; ++b)
        {
          if (typeid (RoleDescriptorType::ContactPerson_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ContactPerson",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"ContactPerson",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // ID
      //
      if (i.ID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ID",
            e));

        a << *i.ID ();
      }

      // validUntil
      //
      if (i.validUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validUntil",
            e));

        a << *i.validUntil ();
      }

      // cacheDuration
      //
      if (i.cacheDuration ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"cacheDuration",
            e));

        a << *i.cacheDuration ();
      }

      // protocolSupportEnumeration
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"protocolSupportEnumeration",
            e));

        a << i.protocolSupportEnumeration ();
      }

      // errorURL
      //
      if (i.errorURL ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"errorURL",
            e));

        a << *i.errorURL ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, RoleDescriptorType >
    _xsd_RoleDescriptorType_type_serializer_init (
      L"RoleDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    operator<< (::xercesc::DOMElement& e, const anyURIListType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const anyURIListType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t >& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const anyURIListType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t >& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, anyURIListType >
    _xsd_anyURIListType_type_serializer_init (
      L"anyURIListType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    KeyDescriptor (::std::ostream& o,
                   const ::saml2::metadata::KeyDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::KeyDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    KeyDescriptor (::std::ostream& o,
                   const ::saml2::metadata::KeyDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::KeyDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    KeyDescriptor (::std::ostream& o,
                   const ::saml2::metadata::KeyDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::KeyDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    KeyDescriptor (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::KeyDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::KeyDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    KeyDescriptor (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::KeyDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::KeyDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    KeyDescriptor (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::KeyDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::KeyDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    KeyDescriptor (::xercesc::DOMDocument& d,
                   const ::saml2::metadata::KeyDescriptorType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::KeyDescriptorType) == typeid (s))
      {
        if (n.name () == L"KeyDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"KeyDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"KeyDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    KeyDescriptor (const ::saml2::metadata::KeyDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::KeyDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"KeyDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"KeyDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::KeyDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const KeyDescriptorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // KeyInfo
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const KeyDescriptorType::KeyInfo_type& x (i.KeyInfo ());
        if (typeid (KeyDescriptorType::KeyInfo_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"KeyInfo",
              L"http://www.w3.org/2000/09/xmldsig#",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"KeyInfo",
            L"http://www.w3.org/2000/09/xmldsig#",
            true, true, e, x);
      }

      // EncryptionMethod
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (KeyDescriptorType::EncryptionMethod_const_iterator
             b (i.EncryptionMethod ().begin ()), n (i.EncryptionMethod ().end ());
             b != n; ++b)
        {
          if (typeid (KeyDescriptorType::EncryptionMethod_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptionMethod",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EncryptionMethod",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // use
      //
      if (i.use ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"use",
            e));

        a << *i.use ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, KeyDescriptorType >
    _xsd_KeyDescriptorType_type_serializer_init (
      L"KeyDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    operator<< (::xercesc::DOMElement& e, const KeyTypes& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const KeyTypes& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const KeyTypes& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, KeyTypes >
    _xsd_KeyTypes_type_serializer_init (
      L"KeyTypes",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    EncryptionMethod (::std::ostream& o,
                      const ::w3::xmlenc::EncryptionMethodType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EncryptionMethod (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptionMethod (::std::ostream& o,
                      const ::w3::xmlenc::EncryptionMethodType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EncryptionMethod (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionMethod (::std::ostream& o,
                      const ::w3::xmlenc::EncryptionMethodType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EncryptionMethod (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionMethod (::xercesc::XMLFormatTarget& t,
                      const ::w3::xmlenc::EncryptionMethodType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EncryptionMethod (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptionMethod (::xercesc::XMLFormatTarget& t,
                      const ::w3::xmlenc::EncryptionMethodType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EncryptionMethod (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionMethod (::xercesc::XMLFormatTarget& t,
                      const ::w3::xmlenc::EncryptionMethodType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::EncryptionMethod (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionMethod (::xercesc::DOMDocument& d,
                      const ::w3::xmlenc::EncryptionMethodType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::EncryptionMethodType) == typeid (s))
      {
        if (n.name () == L"EncryptionMethod" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptionMethod",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptionMethod",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptionMethod (const ::w3::xmlenc::EncryptionMethodType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::w3::xmlenc::EncryptionMethodType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptionMethod",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"EncryptionMethod",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::EncryptionMethod (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SSODescriptorType& i)
    {
      e << static_cast< const ::saml2::metadata::RoleDescriptorType& > (i);

      // ArtifactResolutionService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SSODescriptorType::ArtifactResolutionService_const_iterator
             b (i.ArtifactResolutionService ().begin ()), n (i.ArtifactResolutionService ().end ());
             b != n; ++b)
        {
          if (typeid (SSODescriptorType::ArtifactResolutionService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ArtifactResolutionService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"ArtifactResolutionService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // SingleLogoutService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SSODescriptorType::SingleLogoutService_const_iterator
             b (i.SingleLogoutService ().begin ()), n (i.SingleLogoutService ().end ());
             b != n; ++b)
        {
          if (typeid (SSODescriptorType::SingleLogoutService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SingleLogoutService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"SingleLogoutService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // ManageNameIDService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SSODescriptorType::ManageNameIDService_const_iterator
             b (i.ManageNameIDService ().begin ()), n (i.ManageNameIDService ().end ());
             b != n; ++b)
        {
          if (typeid (SSODescriptorType::ManageNameIDService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ManageNameIDService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"ManageNameIDService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // NameIDFormat
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SSODescriptorType::NameIDFormat_const_iterator
             b (i.NameIDFormat ().begin ()), n (i.NameIDFormat ().end ());
             b != n; ++b)
        {
          if (typeid (SSODescriptorType::NameIDFormat_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameIDFormat",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SSODescriptorType >
    _xsd_SSODescriptorType_type_serializer_init (
      L"SSODescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    ArtifactResolutionService (::std::ostream& o,
                               const ::saml2::metadata::IndexedEndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ArtifactResolutionService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ArtifactResolutionService (::std::ostream& o,
                               const ::saml2::metadata::IndexedEndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::error_handler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ArtifactResolutionService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolutionService (::std::ostream& o,
                               const ::saml2::metadata::IndexedEndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xercesc::DOMErrorHandler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ArtifactResolutionService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolutionService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::IndexedEndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ArtifactResolutionService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ArtifactResolutionService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::IndexedEndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::error_handler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ArtifactResolutionService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolutionService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::IndexedEndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xercesc::DOMErrorHandler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ArtifactResolutionService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ArtifactResolutionService (::xercesc::DOMDocument& d,
                               const ::saml2::metadata::IndexedEndpointType& s,
                               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::IndexedEndpointType) == typeid (s))
      {
        if (n.name () == L"ArtifactResolutionService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ArtifactResolutionService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ArtifactResolutionService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ArtifactResolutionService (const ::saml2::metadata::IndexedEndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::IndexedEndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ArtifactResolutionService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ArtifactResolutionService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::ArtifactResolutionService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    SingleLogoutService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleLogoutService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SingleLogoutService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleLogoutService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleLogoutService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleLogoutService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleLogoutService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleLogoutService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SingleLogoutService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleLogoutService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleLogoutService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleLogoutService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleLogoutService (::xercesc::DOMDocument& d,
                         const ::saml2::metadata::EndpointType& s,
                         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"SingleLogoutService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SingleLogoutService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SingleLogoutService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SingleLogoutService (const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SingleLogoutService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SingleLogoutService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::SingleLogoutService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    ManageNameIDService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ManageNameIDService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ManageNameIDService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ManageNameIDService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ManageNameIDService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ManageNameIDService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ManageNameIDService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ManageNameIDService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ManageNameIDService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ManageNameIDService (::xercesc::DOMDocument& d,
                         const ::saml2::metadata::EndpointType& s,
                         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"ManageNameIDService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ManageNameIDService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ManageNameIDService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ManageNameIDService (const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ManageNameIDService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ManageNameIDService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::ManageNameIDService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    NameIDFormat (::std::ostream& o,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDFormat (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDFormat (::std::ostream& o,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDFormat (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDFormat (::std::ostream& o,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDFormat (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDFormat (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDFormat (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDFormat (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDFormat (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDFormat (::xercesc::XMLFormatTarget& t,
                  const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDFormat (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDFormat (::xercesc::DOMDocument& d,
                  const ::xml_schema::uri& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"NameIDFormat" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NameIDFormat",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NameIDFormat",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NameIDFormat (const ::xml_schema::uri& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NameIDFormat",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NameIDFormat",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::NameIDFormat (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    IDPSSODescriptor (::std::ostream& o,
                      const ::saml2::metadata::IDPSSODescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::IDPSSODescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    IDPSSODescriptor (::std::ostream& o,
                      const ::saml2::metadata::IDPSSODescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::IDPSSODescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPSSODescriptor (::std::ostream& o,
                      const ::saml2::metadata::IDPSSODescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::IDPSSODescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPSSODescriptor (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::IDPSSODescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::IDPSSODescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    IDPSSODescriptor (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::IDPSSODescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::IDPSSODescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPSSODescriptor (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::IDPSSODescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::IDPSSODescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    IDPSSODescriptor (::xercesc::DOMDocument& d,
                      const ::saml2::metadata::IDPSSODescriptorType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::IDPSSODescriptorType) == typeid (s))
      {
        if (n.name () == L"IDPSSODescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"IDPSSODescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"IDPSSODescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    IDPSSODescriptor (const ::saml2::metadata::IDPSSODescriptorType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::IDPSSODescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"IDPSSODescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"IDPSSODescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::IDPSSODescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const IDPSSODescriptorType& i)
    {
      e << static_cast< const ::saml2::metadata::SSODescriptorType& > (i);

      // SingleSignOnService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (IDPSSODescriptorType::SingleSignOnService_const_iterator
             b (i.SingleSignOnService ().begin ()), n (i.SingleSignOnService ().end ());
             b != n; ++b)
        {
          if (typeid (IDPSSODescriptorType::SingleSignOnService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SingleSignOnService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"SingleSignOnService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // NameIDMappingService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (IDPSSODescriptorType::NameIDMappingService_const_iterator
             b (i.NameIDMappingService ().begin ()), n (i.NameIDMappingService ().end ());
             b != n; ++b)
        {
          if (typeid (IDPSSODescriptorType::NameIDMappingService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameIDMappingService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"NameIDMappingService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AssertionIDRequestService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (IDPSSODescriptorType::AssertionIDRequestService_const_iterator
             b (i.AssertionIDRequestService ().begin ()), n (i.AssertionIDRequestService ().end ());
             b != n; ++b)
        {
          if (typeid (IDPSSODescriptorType::AssertionIDRequestService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionIDRequestService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AttributeProfile
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (IDPSSODescriptorType::AttributeProfile_const_iterator
             b (i.AttributeProfile ().begin ()), n (i.AttributeProfile ().end ());
             b != n; ++b)
        {
          if (typeid (IDPSSODescriptorType::AttributeProfile_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AttributeProfile",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AttributeProfile",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // Attribute
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (IDPSSODescriptorType::Attribute_const_iterator
             b (i.Attribute ().begin ()), n (i.Attribute ().end ());
             b != n; ++b)
        {
          if (typeid (IDPSSODescriptorType::Attribute_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Attribute",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // WantAuthnRequestsSigned
      //
      if (i.WantAuthnRequestsSigned ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"WantAuthnRequestsSigned",
            e));

        a << *i.WantAuthnRequestsSigned ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, IDPSSODescriptorType >
    _xsd_IDPSSODescriptorType_type_serializer_init (
      L"IDPSSODescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    SingleSignOnService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleSignOnService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SingleSignOnService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleSignOnService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleSignOnService (::std::ostream& o,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleSignOnService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleSignOnService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleSignOnService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SingleSignOnService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleSignOnService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleSignOnService (::xercesc::XMLFormatTarget& t,
                         const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SingleSignOnService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SingleSignOnService (::xercesc::DOMDocument& d,
                         const ::saml2::metadata::EndpointType& s,
                         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"SingleSignOnService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SingleSignOnService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SingleSignOnService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SingleSignOnService (const ::saml2::metadata::EndpointType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SingleSignOnService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SingleSignOnService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::SingleSignOnService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    NameIDMappingService (::std::ostream& o,
                          const ::saml2::metadata::EndpointType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDMappingService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDMappingService (::std::ostream& o,
                          const ::saml2::metadata::EndpointType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDMappingService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingService (::std::ostream& o,
                          const ::saml2::metadata::EndpointType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDMappingService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingService (::xercesc::XMLFormatTarget& t,
                          const ::saml2::metadata::EndpointType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDMappingService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameIDMappingService (::xercesc::XMLFormatTarget& t,
                          const ::saml2::metadata::EndpointType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDMappingService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingService (::xercesc::XMLFormatTarget& t,
                          const ::saml2::metadata::EndpointType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::NameIDMappingService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameIDMappingService (::xercesc::DOMDocument& d,
                          const ::saml2::metadata::EndpointType& s,
                          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"NameIDMappingService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NameIDMappingService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NameIDMappingService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NameIDMappingService (const ::saml2::metadata::EndpointType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NameIDMappingService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NameIDMappingService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::NameIDMappingService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AssertionIDRequestService (::std::ostream& o,
                               const ::saml2::metadata::EndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionIDRequestService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRequestService (::std::ostream& o,
                               const ::saml2::metadata::EndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::error_handler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionIDRequestService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequestService (::std::ostream& o,
                               const ::saml2::metadata::EndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xercesc::DOMErrorHandler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionIDRequestService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequestService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::EndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionIDRequestService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRequestService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::EndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::error_handler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionIDRequestService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequestService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::EndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xercesc::DOMErrorHandler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionIDRequestService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRequestService (::xercesc::DOMDocument& d,
                               const ::saml2::metadata::EndpointType& s,
                               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"AssertionIDRequestService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AssertionIDRequestService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AssertionIDRequestService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AssertionIDRequestService (const ::saml2::metadata::EndpointType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AssertionIDRequestService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AssertionIDRequestService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AssertionIDRequestService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AttributeProfile (::std::ostream& o,
                      const ::xml_schema::uri& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeProfile (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeProfile (::std::ostream& o,
                      const ::xml_schema::uri& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeProfile (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeProfile (::std::ostream& o,
                      const ::xml_schema::uri& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeProfile (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeProfile (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::uri& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeProfile (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeProfile (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::uri& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeProfile (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeProfile (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::uri& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeProfile (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeProfile (::xercesc::DOMDocument& d,
                      const ::xml_schema::uri& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"AttributeProfile" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AttributeProfile",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AttributeProfile",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeProfile (const ::xml_schema::uri& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AttributeProfile",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AttributeProfile",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AttributeProfile (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    SPSSODescriptor (::std::ostream& o,
                     const ::saml2::metadata::SPSSODescriptorType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SPSSODescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SPSSODescriptor (::std::ostream& o,
                     const ::saml2::metadata::SPSSODescriptorType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SPSSODescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SPSSODescriptor (::std::ostream& o,
                     const ::saml2::metadata::SPSSODescriptorType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SPSSODescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SPSSODescriptor (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::SPSSODescriptorType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SPSSODescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SPSSODescriptor (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::SPSSODescriptorType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SPSSODescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SPSSODescriptor (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::SPSSODescriptorType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::SPSSODescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SPSSODescriptor (::xercesc::DOMDocument& d,
                     const ::saml2::metadata::SPSSODescriptorType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::SPSSODescriptorType) == typeid (s))
      {
        if (n.name () == L"SPSSODescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SPSSODescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SPSSODescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SPSSODescriptor (const ::saml2::metadata::SPSSODescriptorType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::SPSSODescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SPSSODescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SPSSODescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::SPSSODescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SPSSODescriptorType& i)
    {
      e << static_cast< const ::saml2::metadata::SSODescriptorType& > (i);

      // AssertionConsumerService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SPSSODescriptorType::AssertionConsumerService_const_iterator
             b (i.AssertionConsumerService ().begin ()), n (i.AssertionConsumerService ().end ());
             b != n; ++b)
        {
          if (typeid (SPSSODescriptorType::AssertionConsumerService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionConsumerService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionConsumerService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AttributeConsumingService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SPSSODescriptorType::AttributeConsumingService_const_iterator
             b (i.AttributeConsumingService ().begin ()), n (i.AttributeConsumingService ().end ());
             b != n; ++b)
        {
          if (typeid (SPSSODescriptorType::AttributeConsumingService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AttributeConsumingService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AttributeConsumingService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AuthnRequestsSigned
      //
      if (i.AuthnRequestsSigned ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"AuthnRequestsSigned",
            e));

        a << *i.AuthnRequestsSigned ();
      }

      // WantAssertionsSigned
      //
      if (i.WantAssertionsSigned ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"WantAssertionsSigned",
            e));

        a << *i.WantAssertionsSigned ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SPSSODescriptorType >
    _xsd_SPSSODescriptorType_type_serializer_init (
      L"SPSSODescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    AssertionConsumerService (::std::ostream& o,
                              const ::saml2::metadata::IndexedEndpointType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionConsumerService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionConsumerService (::std::ostream& o,
                              const ::saml2::metadata::IndexedEndpointType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::error_handler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionConsumerService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionConsumerService (::std::ostream& o,
                              const ::saml2::metadata::IndexedEndpointType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xercesc::DOMErrorHandler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionConsumerService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionConsumerService (::xercesc::XMLFormatTarget& t,
                              const ::saml2::metadata::IndexedEndpointType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionConsumerService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionConsumerService (::xercesc::XMLFormatTarget& t,
                              const ::saml2::metadata::IndexedEndpointType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::error_handler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionConsumerService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionConsumerService (::xercesc::XMLFormatTarget& t,
                              const ::saml2::metadata::IndexedEndpointType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xercesc::DOMErrorHandler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AssertionConsumerService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionConsumerService (::xercesc::DOMDocument& d,
                              const ::saml2::metadata::IndexedEndpointType& s,
                              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::IndexedEndpointType) == typeid (s))
      {
        if (n.name () == L"AssertionConsumerService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AssertionConsumerService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AssertionConsumerService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AssertionConsumerService (const ::saml2::metadata::IndexedEndpointType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::IndexedEndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AssertionConsumerService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AssertionConsumerService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AssertionConsumerService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AttributeConsumingService (::std::ostream& o,
                               const ::saml2::metadata::AttributeConsumingServiceType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeConsumingService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeConsumingService (::std::ostream& o,
                               const ::saml2::metadata::AttributeConsumingServiceType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::error_handler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeConsumingService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeConsumingService (::std::ostream& o,
                               const ::saml2::metadata::AttributeConsumingServiceType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xercesc::DOMErrorHandler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeConsumingService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeConsumingService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::AttributeConsumingServiceType& s,
                               const ::xml_schema::namespace_infomap& m,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeConsumingService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeConsumingService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::AttributeConsumingServiceType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::error_handler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeConsumingService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeConsumingService (::xercesc::XMLFormatTarget& t,
                               const ::saml2::metadata::AttributeConsumingServiceType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xercesc::DOMErrorHandler& h,
                               const ::std::wstring& e,
                               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeConsumingService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeConsumingService (::xercesc::DOMDocument& d,
                               const ::saml2::metadata::AttributeConsumingServiceType& s,
                               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::AttributeConsumingServiceType) == typeid (s))
      {
        if (n.name () == L"AttributeConsumingService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AttributeConsumingService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AttributeConsumingService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeConsumingService (const ::saml2::metadata::AttributeConsumingServiceType& s,
                               const ::xml_schema::namespace_infomap& m,
                               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::AttributeConsumingServiceType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AttributeConsumingService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AttributeConsumingService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AttributeConsumingService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AttributeConsumingServiceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ServiceName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeConsumingServiceType::ServiceName_const_iterator
             b (i.ServiceName ().begin ()), n (i.ServiceName ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeConsumingServiceType::ServiceName_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ServiceName",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"ServiceName",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // ServiceDescription
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeConsumingServiceType::ServiceDescription_const_iterator
             b (i.ServiceDescription ().begin ()), n (i.ServiceDescription ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeConsumingServiceType::ServiceDescription_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ServiceDescription",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"ServiceDescription",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // RequestedAttribute
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeConsumingServiceType::RequestedAttribute_const_iterator
             b (i.RequestedAttribute ().begin ()), n (i.RequestedAttribute ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeConsumingServiceType::RequestedAttribute_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"RequestedAttribute",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"RequestedAttribute",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // index
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"index",
            e));

        a << i.index ();
      }

      // isDefault
      //
      if (i.isDefault ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"isDefault",
            e));

        a << *i.isDefault ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeConsumingServiceType >
    _xsd_AttributeConsumingServiceType_type_serializer_init (
      L"AttributeConsumingServiceType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    ServiceName (::std::ostream& o,
                 const ::saml2::metadata::localizedNameType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ServiceName (::std::ostream& o,
                 const ::saml2::metadata::localizedNameType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceName (::std::ostream& o,
                 const ::saml2::metadata::localizedNameType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceName (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceName (::xercesc::XMLFormatTarget& t,
                 const ::saml2::metadata::localizedNameType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceName (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ServiceName (::xercesc::XMLFormatTarget& t,
                 const ::saml2::metadata::localizedNameType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceName (::xercesc::XMLFormatTarget& t,
                 const ::saml2::metadata::localizedNameType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceName (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceName (::xercesc::DOMDocument& d,
                 const ::saml2::metadata::localizedNameType& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
      {
        if (n.name () == L"ServiceName" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ServiceName",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ServiceName",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ServiceName (const ::saml2::metadata::localizedNameType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ServiceName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ServiceName",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::ServiceName (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    ServiceDescription (::std::ostream& o,
                        const ::saml2::metadata::localizedNameType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceDescription (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ServiceDescription (::std::ostream& o,
                        const ::saml2::metadata::localizedNameType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceDescription (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceDescription (::std::ostream& o,
                        const ::saml2::metadata::localizedNameType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceDescription (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceDescription (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::localizedNameType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceDescription (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ServiceDescription (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::localizedNameType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceDescription (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceDescription (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::localizedNameType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::ServiceDescription (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ServiceDescription (::xercesc::DOMDocument& d,
                        const ::saml2::metadata::localizedNameType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
      {
        if (n.name () == L"ServiceDescription" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ServiceDescription",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ServiceDescription",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ServiceDescription (const ::saml2::metadata::localizedNameType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::localizedNameType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ServiceDescription",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ServiceDescription",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::ServiceDescription (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    RequestedAttribute (::std::ostream& o,
                        const ::saml2::metadata::RequestedAttributeType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RequestedAttribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RequestedAttribute (::std::ostream& o,
                        const ::saml2::metadata::RequestedAttributeType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RequestedAttribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAttribute (::std::ostream& o,
                        const ::saml2::metadata::RequestedAttributeType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RequestedAttribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::RequestedAttributeType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RequestedAttribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    RequestedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::RequestedAttributeType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RequestedAttribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::metadata::RequestedAttributeType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::RequestedAttribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    RequestedAttribute (::xercesc::DOMDocument& d,
                        const ::saml2::metadata::RequestedAttributeType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::RequestedAttributeType) == typeid (s))
      {
        if (n.name () == L"RequestedAttribute" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"RequestedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"RequestedAttribute",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    RequestedAttribute (const ::saml2::metadata::RequestedAttributeType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::RequestedAttributeType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"RequestedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"RequestedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::RequestedAttribute (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RequestedAttributeType& i)
    {
      e << static_cast< const ::saml2::assertion::AttributeType& > (i);

      // isRequired
      //
      if (i.isRequired ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"isRequired",
            e));

        a << *i.isRequired ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, RequestedAttributeType >
    _xsd_RequestedAttributeType_type_serializer_init (
      L"RequestedAttributeType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    AuthnAuthorityDescriptor (::std::ostream& o,
                              const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnAuthorityDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnAuthorityDescriptor (::std::ostream& o,
                              const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::error_handler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnAuthorityDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnAuthorityDescriptor (::std::ostream& o,
                              const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xercesc::DOMErrorHandler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnAuthorityDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnAuthorityDescriptor (::xercesc::XMLFormatTarget& t,
                              const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              const ::xml_schema::namespace_infomap& m,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnAuthorityDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnAuthorityDescriptor (::xercesc::XMLFormatTarget& t,
                              const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::error_handler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnAuthorityDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnAuthorityDescriptor (::xercesc::XMLFormatTarget& t,
                              const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xercesc::DOMErrorHandler& h,
                              const ::std::wstring& e,
                              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnAuthorityDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnAuthorityDescriptor (::xercesc::DOMDocument& d,
                              const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::AuthnAuthorityDescriptorType) == typeid (s))
      {
        if (n.name () == L"AuthnAuthorityDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnAuthorityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnAuthorityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnAuthorityDescriptor (const ::saml2::metadata::AuthnAuthorityDescriptorType& s,
                              const ::xml_schema::namespace_infomap& m,
                              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::AuthnAuthorityDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnAuthorityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnAuthorityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AuthnAuthorityDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AuthnAuthorityDescriptorType& i)
    {
      e << static_cast< const ::saml2::metadata::RoleDescriptorType& > (i);

      // AuthnQueryService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthnAuthorityDescriptorType::AuthnQueryService_const_iterator
             b (i.AuthnQueryService ().begin ()), n (i.AuthnQueryService ().end ());
             b != n; ++b)
        {
          if (typeid (AuthnAuthorityDescriptorType::AuthnQueryService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnQueryService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthnQueryService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AssertionIDRequestService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthnAuthorityDescriptorType::AssertionIDRequestService_const_iterator
             b (i.AssertionIDRequestService ().begin ()), n (i.AssertionIDRequestService ().end ());
             b != n; ++b)
        {
          if (typeid (AuthnAuthorityDescriptorType::AssertionIDRequestService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionIDRequestService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // NameIDFormat
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthnAuthorityDescriptorType::NameIDFormat_const_iterator
             b (i.NameIDFormat ().begin ()), n (i.NameIDFormat ().end ());
             b != n; ++b)
        {
          if (typeid (AuthnAuthorityDescriptorType::NameIDFormat_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameIDFormat",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnAuthorityDescriptorType >
    _xsd_AuthnAuthorityDescriptorType_type_serializer_init (
      L"AuthnAuthorityDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    AuthnQueryService (::std::ostream& o,
                       const ::saml2::metadata::EndpointType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::wstring& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnQueryService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnQueryService (::std::ostream& o,
                       const ::saml2::metadata::EndpointType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::error_handler& h,
                       const ::std::wstring& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnQueryService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQueryService (::std::ostream& o,
                       const ::saml2::metadata::EndpointType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xercesc::DOMErrorHandler& h,
                       const ::std::wstring& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnQueryService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQueryService (::xercesc::XMLFormatTarget& t,
                       const ::saml2::metadata::EndpointType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::wstring& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnQueryService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnQueryService (::xercesc::XMLFormatTarget& t,
                       const ::saml2::metadata::EndpointType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::error_handler& h,
                       const ::std::wstring& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnQueryService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQueryService (::xercesc::XMLFormatTarget& t,
                       const ::saml2::metadata::EndpointType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xercesc::DOMErrorHandler& h,
                       const ::std::wstring& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthnQueryService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnQueryService (::xercesc::DOMDocument& d,
                       const ::saml2::metadata::EndpointType& s,
                       ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"AuthnQueryService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnQueryService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnQueryService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnQueryService (const ::saml2::metadata::EndpointType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnQueryService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnQueryService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AuthnQueryService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    PDPDescriptor (::std::ostream& o,
                   const ::saml2::metadata::PDPDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::PDPDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    PDPDescriptor (::std::ostream& o,
                   const ::saml2::metadata::PDPDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::PDPDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    PDPDescriptor (::std::ostream& o,
                   const ::saml2::metadata::PDPDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::PDPDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    PDPDescriptor (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::PDPDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::PDPDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    PDPDescriptor (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::PDPDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::PDPDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    PDPDescriptor (::xercesc::XMLFormatTarget& t,
                   const ::saml2::metadata::PDPDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::PDPDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    PDPDescriptor (::xercesc::DOMDocument& d,
                   const ::saml2::metadata::PDPDescriptorType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::PDPDescriptorType) == typeid (s))
      {
        if (n.name () == L"PDPDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"PDPDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"PDPDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    PDPDescriptor (const ::saml2::metadata::PDPDescriptorType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::PDPDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"PDPDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"PDPDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::PDPDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PDPDescriptorType& i)
    {
      e << static_cast< const ::saml2::metadata::RoleDescriptorType& > (i);

      // AuthzService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (PDPDescriptorType::AuthzService_const_iterator
             b (i.AuthzService ().begin ()), n (i.AuthzService ().end ());
             b != n; ++b)
        {
          if (typeid (PDPDescriptorType::AuthzService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthzService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthzService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AssertionIDRequestService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (PDPDescriptorType::AssertionIDRequestService_const_iterator
             b (i.AssertionIDRequestService ().begin ()), n (i.AssertionIDRequestService ().end ());
             b != n; ++b)
        {
          if (typeid (PDPDescriptorType::AssertionIDRequestService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionIDRequestService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // NameIDFormat
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (PDPDescriptorType::NameIDFormat_const_iterator
             b (i.NameIDFormat ().begin ()), n (i.NameIDFormat ().end ());
             b != n; ++b)
        {
          if (typeid (PDPDescriptorType::NameIDFormat_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameIDFormat",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, PDPDescriptorType >
    _xsd_PDPDescriptorType_type_serializer_init (
      L"PDPDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    AuthzService (::std::ostream& o,
                  const ::saml2::metadata::EndpointType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthzService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzService (::std::ostream& o,
                  const ::saml2::metadata::EndpointType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthzService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzService (::std::ostream& o,
                  const ::saml2::metadata::EndpointType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthzService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzService (::xercesc::XMLFormatTarget& t,
                  const ::saml2::metadata::EndpointType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthzService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzService (::xercesc::XMLFormatTarget& t,
                  const ::saml2::metadata::EndpointType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthzService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzService (::xercesc::XMLFormatTarget& t,
                  const ::saml2::metadata::EndpointType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AuthzService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzService (::xercesc::DOMDocument& d,
                  const ::saml2::metadata::EndpointType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"AuthzService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthzService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthzService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthzService (const ::saml2::metadata::EndpointType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthzService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthzService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AuthzService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AttributeAuthorityDescriptor (::std::ostream& o,
                                  const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::wstring& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeAuthorityDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeAuthorityDescriptor (::std::ostream& o,
                                  const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  ::xml_schema::error_handler& h,
                                  const ::std::wstring& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeAuthorityDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeAuthorityDescriptor (::std::ostream& o,
                                  const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::std::wstring& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeAuthorityDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeAuthorityDescriptor (::xercesc::XMLFormatTarget& t,
                                  const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  const ::std::wstring& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeAuthorityDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeAuthorityDescriptor (::xercesc::XMLFormatTarget& t,
                                  const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  ::xml_schema::error_handler& h,
                                  const ::std::wstring& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeAuthorityDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeAuthorityDescriptor (::xercesc::XMLFormatTarget& t,
                                  const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  ::xercesc::DOMErrorHandler& h,
                                  const ::std::wstring& e,
                                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeAuthorityDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeAuthorityDescriptor (::xercesc::DOMDocument& d,
                                  const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::AttributeAuthorityDescriptorType) == typeid (s))
      {
        if (n.name () == L"AttributeAuthorityDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AttributeAuthorityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AttributeAuthorityDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeAuthorityDescriptor (const ::saml2::metadata::AttributeAuthorityDescriptorType& s,
                                  const ::xml_schema::namespace_infomap& m,
                                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::AttributeAuthorityDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AttributeAuthorityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AttributeAuthorityDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AttributeAuthorityDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AttributeAuthorityDescriptorType& i)
    {
      e << static_cast< const ::saml2::metadata::RoleDescriptorType& > (i);

      // AttributeService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeAuthorityDescriptorType::AttributeService_const_iterator
             b (i.AttributeService ().begin ()), n (i.AttributeService ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeAuthorityDescriptorType::AttributeService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AttributeService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AttributeService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AssertionIDRequestService
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeAuthorityDescriptorType::AssertionIDRequestService_const_iterator
             b (i.AssertionIDRequestService ().begin ()), n (i.AssertionIDRequestService ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeAuthorityDescriptorType::AssertionIDRequestService_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionIDRequestService",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionIDRequestService",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // NameIDFormat
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeAuthorityDescriptorType::NameIDFormat_const_iterator
             b (i.NameIDFormat ().begin ()), n (i.NameIDFormat ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeAuthorityDescriptorType::NameIDFormat_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameIDFormat",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"NameIDFormat",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // AttributeProfile
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeAuthorityDescriptorType::AttributeProfile_const_iterator
             b (i.AttributeProfile ().begin ()), n (i.AttributeProfile ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeAuthorityDescriptorType::AttributeProfile_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AttributeProfile",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AttributeProfile",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // Attribute
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeAuthorityDescriptorType::Attribute_const_iterator
             b (i.Attribute ().begin ()), n (i.Attribute ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeAuthorityDescriptorType::Attribute_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Attribute",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeAuthorityDescriptorType >
    _xsd_AttributeAuthorityDescriptorType_type_serializer_init (
      L"AttributeAuthorityDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    AttributeService (::std::ostream& o,
                      const ::saml2::metadata::EndpointType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeService (::std::ostream& o,
                      const ::saml2::metadata::EndpointType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeService (::std::ostream& o,
                      const ::saml2::metadata::EndpointType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeService (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeService (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::EndpointType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeService (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeService (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::EndpointType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeService (::xercesc::XMLFormatTarget& t,
                      const ::saml2::metadata::EndpointType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AttributeService (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeService (::xercesc::DOMDocument& d,
                      const ::saml2::metadata::EndpointType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::EndpointType) == typeid (s))
      {
        if (n.name () == L"AttributeService" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AttributeService",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AttributeService",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeService (const ::saml2::metadata::EndpointType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::EndpointType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AttributeService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AttributeService",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AttributeService (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AffiliationDescriptor (::std::ostream& o,
                           const ::saml2::metadata::AffiliationDescriptorType& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliationDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AffiliationDescriptor (::std::ostream& o,
                           const ::saml2::metadata::AffiliationDescriptorType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::error_handler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliationDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliationDescriptor (::std::ostream& o,
                           const ::saml2::metadata::AffiliationDescriptorType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xercesc::DOMErrorHandler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliationDescriptor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliationDescriptor (::xercesc::XMLFormatTarget& t,
                           const ::saml2::metadata::AffiliationDescriptorType& s,
                           const ::xml_schema::namespace_infomap& m,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliationDescriptor (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AffiliationDescriptor (::xercesc::XMLFormatTarget& t,
                           const ::saml2::metadata::AffiliationDescriptorType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::error_handler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliationDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliationDescriptor (::xercesc::XMLFormatTarget& t,
                           const ::saml2::metadata::AffiliationDescriptorType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xercesc::DOMErrorHandler& h,
                           const ::std::wstring& e,
                           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliationDescriptor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliationDescriptor (::xercesc::DOMDocument& d,
                           const ::saml2::metadata::AffiliationDescriptorType& s,
                           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::AffiliationDescriptorType) == typeid (s))
      {
        if (n.name () == L"AffiliationDescriptor" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AffiliationDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AffiliationDescriptor",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AffiliationDescriptor (const ::saml2::metadata::AffiliationDescriptorType& s,
                           const ::xml_schema::namespace_infomap& m,
                           ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::AffiliationDescriptorType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AffiliationDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AffiliationDescriptor",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AffiliationDescriptor (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AffiliationDescriptorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (AffiliationDescriptorType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // Signature
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          const AffiliationDescriptorType::Signature_type& x (*i.Signature ());
          if (typeid (AffiliationDescriptorType::Signature_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Signature",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // Extensions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Extensions ())
        {
          const AffiliationDescriptorType::Extensions_type& x (*i.Extensions ());
          if (typeid (AffiliationDescriptorType::Extensions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Extensions",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Extensions",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, x);
        }
      }

      // AffiliateMember
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AffiliationDescriptorType::AffiliateMember_const_iterator
             b (i.AffiliateMember ().begin ()), n (i.AffiliateMember ().end ());
             b != n; ++b)
        {
          if (typeid (AffiliationDescriptorType::AffiliateMember_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AffiliateMember",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AffiliateMember",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // KeyDescriptor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AffiliationDescriptorType::KeyDescriptor_const_iterator
             b (i.KeyDescriptor ().begin ()), n (i.KeyDescriptor ().end ());
             b != n; ++b)
        {
          if (typeid (AffiliationDescriptorType::KeyDescriptor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"KeyDescriptor",
                L"urn:oasis:names:tc:SAML:2.0:metadata",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"KeyDescriptor",
              L"urn:oasis:names:tc:SAML:2.0:metadata",
              true, true, e, *b);
        }
      }

      // affiliationOwnerID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"affiliationOwnerID",
            e));

        a << i.affiliationOwnerID ();
      }

      // validUntil
      //
      if (i.validUntil ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"validUntil",
            e));

        a << *i.validUntil ();
      }

      // cacheDuration
      //
      if (i.cacheDuration ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"cacheDuration",
            e));

        a << *i.cacheDuration ();
      }

      // ID
      //
      if (i.ID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ID",
            e));

        a << *i.ID ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AffiliationDescriptorType >
    _xsd_AffiliationDescriptorType_type_serializer_init (
      L"AffiliationDescriptorType",
      L"urn:oasis:names:tc:SAML:2.0:metadata");


    void
    AffiliateMember (::std::ostream& o,
                     const ::saml2::metadata::entityIDType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliateMember (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AffiliateMember (::std::ostream& o,
                     const ::saml2::metadata::entityIDType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliateMember (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliateMember (::std::ostream& o,
                     const ::saml2::metadata::entityIDType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliateMember (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliateMember (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::entityIDType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliateMember (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AffiliateMember (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::entityIDType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliateMember (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliateMember (::xercesc::XMLFormatTarget& t,
                     const ::saml2::metadata::entityIDType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::metadata::AffiliateMember (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AffiliateMember (::xercesc::DOMDocument& d,
                     const ::saml2::metadata::entityIDType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::metadata::entityIDType) == typeid (s))
      {
        if (n.name () == L"AffiliateMember" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:metadata")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AffiliateMember",
            L"urn:oasis:names:tc:SAML:2.0:metadata");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AffiliateMember",
          L"urn:oasis:names:tc:SAML:2.0:metadata",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AffiliateMember (const ::saml2::metadata::entityIDType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::metadata::entityIDType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AffiliateMember",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AffiliateMember",
            L"urn:oasis:names:tc:SAML:2.0:metadata",
            m, s, f);
        }

        ::saml2::metadata::AffiliateMember (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

