// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "saml2/bindings/saml-schema-assertion-2.0.hxx"

namespace saml2
{
  namespace assertion
  {
    // BaseIDAbstractType
    // 

    const BaseIDAbstractType::NameQualifier_optional& BaseIDAbstractType::
    NameQualifier () const
    {
      return this->NameQualifier_;
    }

    BaseIDAbstractType::NameQualifier_optional& BaseIDAbstractType::
    NameQualifier ()
    {
      return this->NameQualifier_;
    }

    void BaseIDAbstractType::
    NameQualifier (const NameQualifier_type& NameQualifier)
    {
      this->NameQualifier_.set (NameQualifier);
    }

    void BaseIDAbstractType::
    NameQualifier (const NameQualifier_optional& NameQualifier)
    {
      this->NameQualifier_ = NameQualifier;
    }

    void BaseIDAbstractType::
    NameQualifier (::std::auto_ptr< NameQualifier_type > NameQualifier)
    {
      this->NameQualifier_.set (NameQualifier);
    }

    const BaseIDAbstractType::SPNameQualifier_optional& BaseIDAbstractType::
    SPNameQualifier () const
    {
      return this->SPNameQualifier_;
    }

    BaseIDAbstractType::SPNameQualifier_optional& BaseIDAbstractType::
    SPNameQualifier ()
    {
      return this->SPNameQualifier_;
    }

    void BaseIDAbstractType::
    SPNameQualifier (const SPNameQualifier_type& SPNameQualifier)
    {
      this->SPNameQualifier_.set (SPNameQualifier);
    }

    void BaseIDAbstractType::
    SPNameQualifier (const SPNameQualifier_optional& SPNameQualifier)
    {
      this->SPNameQualifier_ = SPNameQualifier;
    }

    void BaseIDAbstractType::
    SPNameQualifier (::std::auto_ptr< SPNameQualifier_type > SPNameQualifier)
    {
      this->SPNameQualifier_.set (SPNameQualifier);
    }


    // NameIDType
    // 

    const NameIDType::NameQualifier_optional& NameIDType::
    NameQualifier () const
    {
      return this->NameQualifier_;
    }

    NameIDType::NameQualifier_optional& NameIDType::
    NameQualifier ()
    {
      return this->NameQualifier_;
    }

    void NameIDType::
    NameQualifier (const NameQualifier_type& NameQualifier)
    {
      this->NameQualifier_.set (NameQualifier);
    }

    void NameIDType::
    NameQualifier (const NameQualifier_optional& NameQualifier)
    {
      this->NameQualifier_ = NameQualifier;
    }

    void NameIDType::
    NameQualifier (::std::auto_ptr< NameQualifier_type > NameQualifier)
    {
      this->NameQualifier_.set (NameQualifier);
    }

    const NameIDType::SPNameQualifier_optional& NameIDType::
    SPNameQualifier () const
    {
      return this->SPNameQualifier_;
    }

    NameIDType::SPNameQualifier_optional& NameIDType::
    SPNameQualifier ()
    {
      return this->SPNameQualifier_;
    }

    void NameIDType::
    SPNameQualifier (const SPNameQualifier_type& SPNameQualifier)
    {
      this->SPNameQualifier_.set (SPNameQualifier);
    }

    void NameIDType::
    SPNameQualifier (const SPNameQualifier_optional& SPNameQualifier)
    {
      this->SPNameQualifier_ = SPNameQualifier;
    }

    void NameIDType::
    SPNameQualifier (::std::auto_ptr< SPNameQualifier_type > SPNameQualifier)
    {
      this->SPNameQualifier_.set (SPNameQualifier);
    }

    const NameIDType::Format_optional& NameIDType::
    Format () const
    {
      return this->Format_;
    }

    NameIDType::Format_optional& NameIDType::
    Format ()
    {
      return this->Format_;
    }

    void NameIDType::
    Format (const Format_type& Format)
    {
      this->Format_.set (Format);
    }

    void NameIDType::
    Format (const Format_optional& Format)
    {
      this->Format_ = Format;
    }

    void NameIDType::
    Format (::std::auto_ptr< Format_type > Format)
    {
      this->Format_.set (Format);
    }

    const NameIDType::SPProvidedID_optional& NameIDType::
    SPProvidedID () const
    {
      return this->SPProvidedID_;
    }

    NameIDType::SPProvidedID_optional& NameIDType::
    SPProvidedID ()
    {
      return this->SPProvidedID_;
    }

    void NameIDType::
    SPProvidedID (const SPProvidedID_type& SPProvidedID)
    {
      this->SPProvidedID_.set (SPProvidedID);
    }

    void NameIDType::
    SPProvidedID (const SPProvidedID_optional& SPProvidedID)
    {
      this->SPProvidedID_ = SPProvidedID;
    }

    void NameIDType::
    SPProvidedID (::std::auto_ptr< SPProvidedID_type > SPProvidedID)
    {
      this->SPProvidedID_.set (SPProvidedID);
    }


    // EncryptedElementType
    // 

    const EncryptedElementType::EncryptedData_type& EncryptedElementType::
    EncryptedData () const
    {
      return this->EncryptedData_.get ();
    }

    EncryptedElementType::EncryptedData_type& EncryptedElementType::
    EncryptedData ()
    {
      return this->EncryptedData_.get ();
    }

    void EncryptedElementType::
    EncryptedData (const EncryptedData_type& EncryptedData)
    {
      this->EncryptedData_.set (EncryptedData);
    }

    void EncryptedElementType::
    EncryptedData (::std::auto_ptr< EncryptedData_type > EncryptedData)
    {
      this->EncryptedData_.set (EncryptedData);
    }

    const EncryptedElementType::EncryptedKey_sequence& EncryptedElementType::
    EncryptedKey () const
    {
      return this->EncryptedKey_;
    }

    EncryptedElementType::EncryptedKey_sequence& EncryptedElementType::
    EncryptedKey ()
    {
      return this->EncryptedKey_;
    }

    void EncryptedElementType::
    EncryptedKey (const EncryptedKey_sequence& EncryptedKey)
    {
      this->EncryptedKey_ = EncryptedKey;
    }


    // AssertionType
    // 

    const AssertionType::Issuer_type& AssertionType::
    Issuer () const
    {
      return this->Issuer_.get ();
    }

    AssertionType::Issuer_type& AssertionType::
    Issuer ()
    {
      return this->Issuer_.get ();
    }

    void AssertionType::
    Issuer (const Issuer_type& Issuer)
    {
      this->Issuer_.set (Issuer);
    }

    void AssertionType::
    Issuer (::std::auto_ptr< Issuer_type > Issuer)
    {
      this->Issuer_.set (Issuer);
    }

    const AssertionType::Signature_optional& AssertionType::
    Signature () const
    {
      return this->Signature_;
    }

    AssertionType::Signature_optional& AssertionType::
    Signature ()
    {
      return this->Signature_;
    }

    void AssertionType::
    Signature (const Signature_type& Signature)
    {
      this->Signature_.set (Signature);
    }

    void AssertionType::
    Signature (const Signature_optional& Signature)
    {
      this->Signature_ = Signature;
    }

    void AssertionType::
    Signature (::std::auto_ptr< Signature_type > Signature)
    {
      this->Signature_.set (Signature);
    }

    const AssertionType::Subject_optional& AssertionType::
    Subject () const
    {
      return this->Subject_;
    }

    AssertionType::Subject_optional& AssertionType::
    Subject ()
    {
      return this->Subject_;
    }

    void AssertionType::
    Subject (const Subject_type& Subject)
    {
      this->Subject_.set (Subject);
    }

    void AssertionType::
    Subject (const Subject_optional& Subject)
    {
      this->Subject_ = Subject;
    }

    void AssertionType::
    Subject (::std::auto_ptr< Subject_type > Subject)
    {
      this->Subject_.set (Subject);
    }

    const AssertionType::Conditions_optional& AssertionType::
    Conditions () const
    {
      return this->Conditions_;
    }

    AssertionType::Conditions_optional& AssertionType::
    Conditions ()
    {
      return this->Conditions_;
    }

    void AssertionType::
    Conditions (const Conditions_type& Conditions)
    {
      this->Conditions_.set (Conditions);
    }

    void AssertionType::
    Conditions (const Conditions_optional& Conditions)
    {
      this->Conditions_ = Conditions;
    }

    void AssertionType::
    Conditions (::std::auto_ptr< Conditions_type > Conditions)
    {
      this->Conditions_.set (Conditions);
    }

    const AssertionType::Advice_optional& AssertionType::
    Advice () const
    {
      return this->Advice_;
    }

    AssertionType::Advice_optional& AssertionType::
    Advice ()
    {
      return this->Advice_;
    }

    void AssertionType::
    Advice (const Advice_type& Advice)
    {
      this->Advice_.set (Advice);
    }

    void AssertionType::
    Advice (const Advice_optional& Advice)
    {
      this->Advice_ = Advice;
    }

    void AssertionType::
    Advice (::std::auto_ptr< Advice_type > Advice)
    {
      this->Advice_.set (Advice);
    }

    const AssertionType::Statement_sequence& AssertionType::
    Statement () const
    {
      return this->Statement_;
    }

    AssertionType::Statement_sequence& AssertionType::
    Statement ()
    {
      return this->Statement_;
    }

    void AssertionType::
    Statement (const Statement_sequence& Statement)
    {
      this->Statement_ = Statement;
    }

    const AssertionType::AuthnStatement_sequence& AssertionType::
    AuthnStatement () const
    {
      return this->AuthnStatement_;
    }

    AssertionType::AuthnStatement_sequence& AssertionType::
    AuthnStatement ()
    {
      return this->AuthnStatement_;
    }

    void AssertionType::
    AuthnStatement (const AuthnStatement_sequence& AuthnStatement)
    {
      this->AuthnStatement_ = AuthnStatement;
    }

    const AssertionType::AuthzDecisionStatement_sequence& AssertionType::
    AuthzDecisionStatement () const
    {
      return this->AuthzDecisionStatement_;
    }

    AssertionType::AuthzDecisionStatement_sequence& AssertionType::
    AuthzDecisionStatement ()
    {
      return this->AuthzDecisionStatement_;
    }

    void AssertionType::
    AuthzDecisionStatement (const AuthzDecisionStatement_sequence& AuthzDecisionStatement)
    {
      this->AuthzDecisionStatement_ = AuthzDecisionStatement;
    }

    const AssertionType::AttributeStatement_sequence& AssertionType::
    AttributeStatement () const
    {
      return this->AttributeStatement_;
    }

    AssertionType::AttributeStatement_sequence& AssertionType::
    AttributeStatement ()
    {
      return this->AttributeStatement_;
    }

    void AssertionType::
    AttributeStatement (const AttributeStatement_sequence& AttributeStatement)
    {
      this->AttributeStatement_ = AttributeStatement;
    }

    const AssertionType::Version_type& AssertionType::
    Version () const
    {
      return this->Version_.get ();
    }

    AssertionType::Version_type& AssertionType::
    Version ()
    {
      return this->Version_.get ();
    }

    void AssertionType::
    Version (const Version_type& Version)
    {
      this->Version_.set (Version);
    }

    void AssertionType::
    Version (::std::auto_ptr< Version_type > Version)
    {
      this->Version_.set (Version);
    }

    const AssertionType::ID_type& AssertionType::
    ID () const
    {
      return this->ID_.get ();
    }

    AssertionType::ID_type& AssertionType::
    ID ()
    {
      return this->ID_.get ();
    }

    void AssertionType::
    ID (const ID_type& ID)
    {
      this->ID_.set (ID);
    }

    void AssertionType::
    ID (::std::auto_ptr< ID_type > ID)
    {
      this->ID_.set (ID);
    }

    const AssertionType::IssueInstant_type& AssertionType::
    IssueInstant () const
    {
      return this->IssueInstant_.get ();
    }

    AssertionType::IssueInstant_type& AssertionType::
    IssueInstant ()
    {
      return this->IssueInstant_.get ();
    }

    void AssertionType::
    IssueInstant (const IssueInstant_type& IssueInstant)
    {
      this->IssueInstant_.set (IssueInstant);
    }

    void AssertionType::
    IssueInstant (::std::auto_ptr< IssueInstant_type > IssueInstant)
    {
      this->IssueInstant_.set (IssueInstant);
    }


    // SubjectType
    // 

    const SubjectType::BaseID_optional& SubjectType::
    BaseID () const
    {
      return this->BaseID_;
    }

    SubjectType::BaseID_optional& SubjectType::
    BaseID ()
    {
      return this->BaseID_;
    }

    void SubjectType::
    BaseID (const BaseID_type& BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    void SubjectType::
    BaseID (const BaseID_optional& BaseID)
    {
      this->BaseID_ = BaseID;
    }

    void SubjectType::
    BaseID (::std::auto_ptr< BaseID_type > BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    const SubjectType::NameID_optional& SubjectType::
    NameID () const
    {
      return this->NameID_;
    }

    SubjectType::NameID_optional& SubjectType::
    NameID ()
    {
      return this->NameID_;
    }

    void SubjectType::
    NameID (const NameID_type& NameID)
    {
      this->NameID_.set (NameID);
    }

    void SubjectType::
    NameID (const NameID_optional& NameID)
    {
      this->NameID_ = NameID;
    }

    void SubjectType::
    NameID (::std::auto_ptr< NameID_type > NameID)
    {
      this->NameID_.set (NameID);
    }

    const SubjectType::EncryptedID_optional& SubjectType::
    EncryptedID () const
    {
      return this->EncryptedID_;
    }

    SubjectType::EncryptedID_optional& SubjectType::
    EncryptedID ()
    {
      return this->EncryptedID_;
    }

    void SubjectType::
    EncryptedID (const EncryptedID_type& EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    void SubjectType::
    EncryptedID (const EncryptedID_optional& EncryptedID)
    {
      this->EncryptedID_ = EncryptedID;
    }

    void SubjectType::
    EncryptedID (::std::auto_ptr< EncryptedID_type > EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    const SubjectType::SubjectConfirmation_sequence& SubjectType::
    SubjectConfirmation () const
    {
      return this->SubjectConfirmation_;
    }

    SubjectType::SubjectConfirmation_sequence& SubjectType::
    SubjectConfirmation ()
    {
      return this->SubjectConfirmation_;
    }

    void SubjectType::
    SubjectConfirmation (const SubjectConfirmation_sequence& SubjectConfirmation)
    {
      this->SubjectConfirmation_ = SubjectConfirmation;
    }


    // SubjectConfirmationType
    // 

    const SubjectConfirmationType::BaseID_optional& SubjectConfirmationType::
    BaseID () const
    {
      return this->BaseID_;
    }

    SubjectConfirmationType::BaseID_optional& SubjectConfirmationType::
    BaseID ()
    {
      return this->BaseID_;
    }

    void SubjectConfirmationType::
    BaseID (const BaseID_type& BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    void SubjectConfirmationType::
    BaseID (const BaseID_optional& BaseID)
    {
      this->BaseID_ = BaseID;
    }

    void SubjectConfirmationType::
    BaseID (::std::auto_ptr< BaseID_type > BaseID)
    {
      this->BaseID_.set (BaseID);
    }

    const SubjectConfirmationType::NameID_optional& SubjectConfirmationType::
    NameID () const
    {
      return this->NameID_;
    }

    SubjectConfirmationType::NameID_optional& SubjectConfirmationType::
    NameID ()
    {
      return this->NameID_;
    }

    void SubjectConfirmationType::
    NameID (const NameID_type& NameID)
    {
      this->NameID_.set (NameID);
    }

    void SubjectConfirmationType::
    NameID (const NameID_optional& NameID)
    {
      this->NameID_ = NameID;
    }

    void SubjectConfirmationType::
    NameID (::std::auto_ptr< NameID_type > NameID)
    {
      this->NameID_.set (NameID);
    }

    const SubjectConfirmationType::EncryptedID_optional& SubjectConfirmationType::
    EncryptedID () const
    {
      return this->EncryptedID_;
    }

    SubjectConfirmationType::EncryptedID_optional& SubjectConfirmationType::
    EncryptedID ()
    {
      return this->EncryptedID_;
    }

    void SubjectConfirmationType::
    EncryptedID (const EncryptedID_type& EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    void SubjectConfirmationType::
    EncryptedID (const EncryptedID_optional& EncryptedID)
    {
      this->EncryptedID_ = EncryptedID;
    }

    void SubjectConfirmationType::
    EncryptedID (::std::auto_ptr< EncryptedID_type > EncryptedID)
    {
      this->EncryptedID_.set (EncryptedID);
    }

    const SubjectConfirmationType::SubjectConfirmationData_optional& SubjectConfirmationType::
    SubjectConfirmationData () const
    {
      return this->SubjectConfirmationData_;
    }

    SubjectConfirmationType::SubjectConfirmationData_optional& SubjectConfirmationType::
    SubjectConfirmationData ()
    {
      return this->SubjectConfirmationData_;
    }

    void SubjectConfirmationType::
    SubjectConfirmationData (const SubjectConfirmationData_type& SubjectConfirmationData)
    {
      this->SubjectConfirmationData_.set (SubjectConfirmationData);
    }

    void SubjectConfirmationType::
    SubjectConfirmationData (const SubjectConfirmationData_optional& SubjectConfirmationData)
    {
      this->SubjectConfirmationData_ = SubjectConfirmationData;
    }

    void SubjectConfirmationType::
    SubjectConfirmationData (::std::auto_ptr< SubjectConfirmationData_type > SubjectConfirmationData)
    {
      this->SubjectConfirmationData_.set (SubjectConfirmationData);
    }

    const SubjectConfirmationType::Method_type& SubjectConfirmationType::
    Method () const
    {
      return this->Method_.get ();
    }

    SubjectConfirmationType::Method_type& SubjectConfirmationType::
    Method ()
    {
      return this->Method_.get ();
    }

    void SubjectConfirmationType::
    Method (const Method_type& Method)
    {
      this->Method_.set (Method);
    }

    void SubjectConfirmationType::
    Method (::std::auto_ptr< Method_type > Method)
    {
      this->Method_.set (Method);
    }


    // SubjectConfirmationDataType
    // 

    const SubjectConfirmationDataType::any_sequence& SubjectConfirmationDataType::
    any () const
    {
      return this->any_;
    }

    SubjectConfirmationDataType::any_sequence& SubjectConfirmationDataType::
    any ()
    {
      return this->any_;
    }

    void SubjectConfirmationDataType::
    any (const any_sequence& any)
    {
      this->any_ = any;
    }

    const SubjectConfirmationDataType::NotBefore_optional& SubjectConfirmationDataType::
    NotBefore () const
    {
      return this->NotBefore_;
    }

    SubjectConfirmationDataType::NotBefore_optional& SubjectConfirmationDataType::
    NotBefore ()
    {
      return this->NotBefore_;
    }

    void SubjectConfirmationDataType::
    NotBefore (const NotBefore_type& NotBefore)
    {
      this->NotBefore_.set (NotBefore);
    }

    void SubjectConfirmationDataType::
    NotBefore (const NotBefore_optional& NotBefore)
    {
      this->NotBefore_ = NotBefore;
    }

    void SubjectConfirmationDataType::
    NotBefore (::std::auto_ptr< NotBefore_type > NotBefore)
    {
      this->NotBefore_.set (NotBefore);
    }

    const SubjectConfirmationDataType::NotOnOrAfter_optional& SubjectConfirmationDataType::
    NotOnOrAfter () const
    {
      return this->NotOnOrAfter_;
    }

    SubjectConfirmationDataType::NotOnOrAfter_optional& SubjectConfirmationDataType::
    NotOnOrAfter ()
    {
      return this->NotOnOrAfter_;
    }

    void SubjectConfirmationDataType::
    NotOnOrAfter (const NotOnOrAfter_type& NotOnOrAfter)
    {
      this->NotOnOrAfter_.set (NotOnOrAfter);
    }

    void SubjectConfirmationDataType::
    NotOnOrAfter (const NotOnOrAfter_optional& NotOnOrAfter)
    {
      this->NotOnOrAfter_ = NotOnOrAfter;
    }

    void SubjectConfirmationDataType::
    NotOnOrAfter (::std::auto_ptr< NotOnOrAfter_type > NotOnOrAfter)
    {
      this->NotOnOrAfter_.set (NotOnOrAfter);
    }

    const SubjectConfirmationDataType::Recipient_optional& SubjectConfirmationDataType::
    Recipient () const
    {
      return this->Recipient_;
    }

    SubjectConfirmationDataType::Recipient_optional& SubjectConfirmationDataType::
    Recipient ()
    {
      return this->Recipient_;
    }

    void SubjectConfirmationDataType::
    Recipient (const Recipient_type& Recipient)
    {
      this->Recipient_.set (Recipient);
    }

    void SubjectConfirmationDataType::
    Recipient (const Recipient_optional& Recipient)
    {
      this->Recipient_ = Recipient;
    }

    void SubjectConfirmationDataType::
    Recipient (::std::auto_ptr< Recipient_type > Recipient)
    {
      this->Recipient_.set (Recipient);
    }

    const SubjectConfirmationDataType::InResponseTo_optional& SubjectConfirmationDataType::
    InResponseTo () const
    {
      return this->InResponseTo_;
    }

    SubjectConfirmationDataType::InResponseTo_optional& SubjectConfirmationDataType::
    InResponseTo ()
    {
      return this->InResponseTo_;
    }

    void SubjectConfirmationDataType::
    InResponseTo (const InResponseTo_type& InResponseTo)
    {
      this->InResponseTo_.set (InResponseTo);
    }

    void SubjectConfirmationDataType::
    InResponseTo (const InResponseTo_optional& InResponseTo)
    {
      this->InResponseTo_ = InResponseTo;
    }

    void SubjectConfirmationDataType::
    InResponseTo (::std::auto_ptr< InResponseTo_type > InResponseTo)
    {
      this->InResponseTo_.set (InResponseTo);
    }

    const SubjectConfirmationDataType::Address_optional& SubjectConfirmationDataType::
    Address () const
    {
      return this->Address_;
    }

    SubjectConfirmationDataType::Address_optional& SubjectConfirmationDataType::
    Address ()
    {
      return this->Address_;
    }

    void SubjectConfirmationDataType::
    Address (const Address_type& Address)
    {
      this->Address_.set (Address);
    }

    void SubjectConfirmationDataType::
    Address (const Address_optional& Address)
    {
      this->Address_ = Address;
    }

    void SubjectConfirmationDataType::
    Address (::std::auto_ptr< Address_type > Address)
    {
      this->Address_.set (Address);
    }

    const SubjectConfirmationDataType::any_attribute_set& SubjectConfirmationDataType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    SubjectConfirmationDataType::any_attribute_set& SubjectConfirmationDataType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void SubjectConfirmationDataType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& SubjectConfirmationDataType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& SubjectConfirmationDataType::
    dom_document ()
    {
      return *dom_document_;
    }


    // KeyInfoConfirmationDataType
    // 


    // ConditionsType
    // 

    const ConditionsType::Condition_sequence& ConditionsType::
    Condition () const
    {
      return this->Condition_;
    }

    ConditionsType::Condition_sequence& ConditionsType::
    Condition ()
    {
      return this->Condition_;
    }

    void ConditionsType::
    Condition (const Condition_sequence& Condition)
    {
      this->Condition_ = Condition;
    }

    const ConditionsType::AudienceRestriction_sequence& ConditionsType::
    AudienceRestriction () const
    {
      return this->AudienceRestriction_;
    }

    ConditionsType::AudienceRestriction_sequence& ConditionsType::
    AudienceRestriction ()
    {
      return this->AudienceRestriction_;
    }

    void ConditionsType::
    AudienceRestriction (const AudienceRestriction_sequence& AudienceRestriction)
    {
      this->AudienceRestriction_ = AudienceRestriction;
    }

    const ConditionsType::OneTimeUse_sequence& ConditionsType::
    OneTimeUse () const
    {
      return this->OneTimeUse_;
    }

    ConditionsType::OneTimeUse_sequence& ConditionsType::
    OneTimeUse ()
    {
      return this->OneTimeUse_;
    }

    void ConditionsType::
    OneTimeUse (const OneTimeUse_sequence& OneTimeUse)
    {
      this->OneTimeUse_ = OneTimeUse;
    }

    const ConditionsType::ProxyRestriction_sequence& ConditionsType::
    ProxyRestriction () const
    {
      return this->ProxyRestriction_;
    }

    ConditionsType::ProxyRestriction_sequence& ConditionsType::
    ProxyRestriction ()
    {
      return this->ProxyRestriction_;
    }

    void ConditionsType::
    ProxyRestriction (const ProxyRestriction_sequence& ProxyRestriction)
    {
      this->ProxyRestriction_ = ProxyRestriction;
    }

    const ConditionsType::NotBefore_optional& ConditionsType::
    NotBefore () const
    {
      return this->NotBefore_;
    }

    ConditionsType::NotBefore_optional& ConditionsType::
    NotBefore ()
    {
      return this->NotBefore_;
    }

    void ConditionsType::
    NotBefore (const NotBefore_type& NotBefore)
    {
      this->NotBefore_.set (NotBefore);
    }

    void ConditionsType::
    NotBefore (const NotBefore_optional& NotBefore)
    {
      this->NotBefore_ = NotBefore;
    }

    void ConditionsType::
    NotBefore (::std::auto_ptr< NotBefore_type > NotBefore)
    {
      this->NotBefore_.set (NotBefore);
    }

    const ConditionsType::NotOnOrAfter_optional& ConditionsType::
    NotOnOrAfter () const
    {
      return this->NotOnOrAfter_;
    }

    ConditionsType::NotOnOrAfter_optional& ConditionsType::
    NotOnOrAfter ()
    {
      return this->NotOnOrAfter_;
    }

    void ConditionsType::
    NotOnOrAfter (const NotOnOrAfter_type& NotOnOrAfter)
    {
      this->NotOnOrAfter_.set (NotOnOrAfter);
    }

    void ConditionsType::
    NotOnOrAfter (const NotOnOrAfter_optional& NotOnOrAfter)
    {
      this->NotOnOrAfter_ = NotOnOrAfter;
    }

    void ConditionsType::
    NotOnOrAfter (::std::auto_ptr< NotOnOrAfter_type > NotOnOrAfter)
    {
      this->NotOnOrAfter_.set (NotOnOrAfter);
    }


    // ConditionAbstractType
    // 


    // AudienceRestrictionType
    // 

    const AudienceRestrictionType::Audience_sequence& AudienceRestrictionType::
    Audience () const
    {
      return this->Audience_;
    }

    AudienceRestrictionType::Audience_sequence& AudienceRestrictionType::
    Audience ()
    {
      return this->Audience_;
    }

    void AudienceRestrictionType::
    Audience (const Audience_sequence& Audience)
    {
      this->Audience_ = Audience;
    }


    // OneTimeUseType
    // 


    // ProxyRestrictionType
    // 

    const ProxyRestrictionType::Audience_sequence& ProxyRestrictionType::
    Audience () const
    {
      return this->Audience_;
    }

    ProxyRestrictionType::Audience_sequence& ProxyRestrictionType::
    Audience ()
    {
      return this->Audience_;
    }

    void ProxyRestrictionType::
    Audience (const Audience_sequence& Audience)
    {
      this->Audience_ = Audience;
    }

    const ProxyRestrictionType::Count_optional& ProxyRestrictionType::
    Count () const
    {
      return this->Count_;
    }

    ProxyRestrictionType::Count_optional& ProxyRestrictionType::
    Count ()
    {
      return this->Count_;
    }

    void ProxyRestrictionType::
    Count (const Count_type& Count)
    {
      this->Count_.set (Count);
    }

    void ProxyRestrictionType::
    Count (const Count_optional& Count)
    {
      this->Count_ = Count;
    }


    // AdviceType
    // 

    const AdviceType::AssertionIDRef_sequence& AdviceType::
    AssertionIDRef () const
    {
      return this->AssertionIDRef_;
    }

    AdviceType::AssertionIDRef_sequence& AdviceType::
    AssertionIDRef ()
    {
      return this->AssertionIDRef_;
    }

    void AdviceType::
    AssertionIDRef (const AssertionIDRef_sequence& AssertionIDRef)
    {
      this->AssertionIDRef_ = AssertionIDRef;
    }

    const AdviceType::AssertionURIRef_sequence& AdviceType::
    AssertionURIRef () const
    {
      return this->AssertionURIRef_;
    }

    AdviceType::AssertionURIRef_sequence& AdviceType::
    AssertionURIRef ()
    {
      return this->AssertionURIRef_;
    }

    void AdviceType::
    AssertionURIRef (const AssertionURIRef_sequence& AssertionURIRef)
    {
      this->AssertionURIRef_ = AssertionURIRef;
    }

    const AdviceType::Assertion_sequence& AdviceType::
    Assertion () const
    {
      return this->Assertion_;
    }

    AdviceType::Assertion_sequence& AdviceType::
    Assertion ()
    {
      return this->Assertion_;
    }

    void AdviceType::
    Assertion (const Assertion_sequence& Assertion)
    {
      this->Assertion_ = Assertion;
    }

    const AdviceType::EncryptedAssertion_sequence& AdviceType::
    EncryptedAssertion () const
    {
      return this->EncryptedAssertion_;
    }

    AdviceType::EncryptedAssertion_sequence& AdviceType::
    EncryptedAssertion ()
    {
      return this->EncryptedAssertion_;
    }

    void AdviceType::
    EncryptedAssertion (const EncryptedAssertion_sequence& EncryptedAssertion)
    {
      this->EncryptedAssertion_ = EncryptedAssertion;
    }

    const AdviceType::any_sequence& AdviceType::
    any () const
    {
      return this->any_;
    }

    AdviceType::any_sequence& AdviceType::
    any ()
    {
      return this->any_;
    }

    void AdviceType::
    any (const any_sequence& any)
    {
      this->any_ = any;
    }

    const ::xercesc::DOMDocument& AdviceType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& AdviceType::
    dom_document ()
    {
      return *dom_document_;
    }


    // StatementAbstractType
    // 


    // AuthnStatementType
    // 

    const AuthnStatementType::SubjectLocality_optional& AuthnStatementType::
    SubjectLocality () const
    {
      return this->SubjectLocality_;
    }

    AuthnStatementType::SubjectLocality_optional& AuthnStatementType::
    SubjectLocality ()
    {
      return this->SubjectLocality_;
    }

    void AuthnStatementType::
    SubjectLocality (const SubjectLocality_type& SubjectLocality)
    {
      this->SubjectLocality_.set (SubjectLocality);
    }

    void AuthnStatementType::
    SubjectLocality (const SubjectLocality_optional& SubjectLocality)
    {
      this->SubjectLocality_ = SubjectLocality;
    }

    void AuthnStatementType::
    SubjectLocality (::std::auto_ptr< SubjectLocality_type > SubjectLocality)
    {
      this->SubjectLocality_.set (SubjectLocality);
    }

    const AuthnStatementType::AuthnContext_type& AuthnStatementType::
    AuthnContext () const
    {
      return this->AuthnContext_.get ();
    }

    AuthnStatementType::AuthnContext_type& AuthnStatementType::
    AuthnContext ()
    {
      return this->AuthnContext_.get ();
    }

    void AuthnStatementType::
    AuthnContext (const AuthnContext_type& AuthnContext)
    {
      this->AuthnContext_.set (AuthnContext);
    }

    void AuthnStatementType::
    AuthnContext (::std::auto_ptr< AuthnContext_type > AuthnContext)
    {
      this->AuthnContext_.set (AuthnContext);
    }

    const AuthnStatementType::AuthnInstant_type& AuthnStatementType::
    AuthnInstant () const
    {
      return this->AuthnInstant_.get ();
    }

    AuthnStatementType::AuthnInstant_type& AuthnStatementType::
    AuthnInstant ()
    {
      return this->AuthnInstant_.get ();
    }

    void AuthnStatementType::
    AuthnInstant (const AuthnInstant_type& AuthnInstant)
    {
      this->AuthnInstant_.set (AuthnInstant);
    }

    void AuthnStatementType::
    AuthnInstant (::std::auto_ptr< AuthnInstant_type > AuthnInstant)
    {
      this->AuthnInstant_.set (AuthnInstant);
    }

    const AuthnStatementType::SessionIndex_optional& AuthnStatementType::
    SessionIndex () const
    {
      return this->SessionIndex_;
    }

    AuthnStatementType::SessionIndex_optional& AuthnStatementType::
    SessionIndex ()
    {
      return this->SessionIndex_;
    }

    void AuthnStatementType::
    SessionIndex (const SessionIndex_type& SessionIndex)
    {
      this->SessionIndex_.set (SessionIndex);
    }

    void AuthnStatementType::
    SessionIndex (const SessionIndex_optional& SessionIndex)
    {
      this->SessionIndex_ = SessionIndex;
    }

    void AuthnStatementType::
    SessionIndex (::std::auto_ptr< SessionIndex_type > SessionIndex)
    {
      this->SessionIndex_.set (SessionIndex);
    }

    const AuthnStatementType::SessionNotOnOrAfter_optional& AuthnStatementType::
    SessionNotOnOrAfter () const
    {
      return this->SessionNotOnOrAfter_;
    }

    AuthnStatementType::SessionNotOnOrAfter_optional& AuthnStatementType::
    SessionNotOnOrAfter ()
    {
      return this->SessionNotOnOrAfter_;
    }

    void AuthnStatementType::
    SessionNotOnOrAfter (const SessionNotOnOrAfter_type& SessionNotOnOrAfter)
    {
      this->SessionNotOnOrAfter_.set (SessionNotOnOrAfter);
    }

    void AuthnStatementType::
    SessionNotOnOrAfter (const SessionNotOnOrAfter_optional& SessionNotOnOrAfter)
    {
      this->SessionNotOnOrAfter_ = SessionNotOnOrAfter;
    }

    void AuthnStatementType::
    SessionNotOnOrAfter (::std::auto_ptr< SessionNotOnOrAfter_type > SessionNotOnOrAfter)
    {
      this->SessionNotOnOrAfter_.set (SessionNotOnOrAfter);
    }


    // SubjectLocalityType
    // 

    const SubjectLocalityType::Address_optional& SubjectLocalityType::
    Address () const
    {
      return this->Address_;
    }

    SubjectLocalityType::Address_optional& SubjectLocalityType::
    Address ()
    {
      return this->Address_;
    }

    void SubjectLocalityType::
    Address (const Address_type& Address)
    {
      this->Address_.set (Address);
    }

    void SubjectLocalityType::
    Address (const Address_optional& Address)
    {
      this->Address_ = Address;
    }

    void SubjectLocalityType::
    Address (::std::auto_ptr< Address_type > Address)
    {
      this->Address_.set (Address);
    }

    const SubjectLocalityType::DNSName_optional& SubjectLocalityType::
    DNSName () const
    {
      return this->DNSName_;
    }

    SubjectLocalityType::DNSName_optional& SubjectLocalityType::
    DNSName ()
    {
      return this->DNSName_;
    }

    void SubjectLocalityType::
    DNSName (const DNSName_type& DNSName)
    {
      this->DNSName_.set (DNSName);
    }

    void SubjectLocalityType::
    DNSName (const DNSName_optional& DNSName)
    {
      this->DNSName_ = DNSName;
    }

    void SubjectLocalityType::
    DNSName (::std::auto_ptr< DNSName_type > DNSName)
    {
      this->DNSName_.set (DNSName);
    }


    // AuthnContextType
    // 

    const AuthnContextType::AuthnContextClassRef_optional& AuthnContextType::
    AuthnContextClassRef () const
    {
      return this->AuthnContextClassRef_;
    }

    AuthnContextType::AuthnContextClassRef_optional& AuthnContextType::
    AuthnContextClassRef ()
    {
      return this->AuthnContextClassRef_;
    }

    void AuthnContextType::
    AuthnContextClassRef (const AuthnContextClassRef_type& AuthnContextClassRef)
    {
      this->AuthnContextClassRef_.set (AuthnContextClassRef);
    }

    void AuthnContextType::
    AuthnContextClassRef (const AuthnContextClassRef_optional& AuthnContextClassRef)
    {
      this->AuthnContextClassRef_ = AuthnContextClassRef;
    }

    void AuthnContextType::
    AuthnContextClassRef (::std::auto_ptr< AuthnContextClassRef_type > AuthnContextClassRef)
    {
      this->AuthnContextClassRef_.set (AuthnContextClassRef);
    }

    const AuthnContextType::AuthnContextDecl_optional& AuthnContextType::
    AuthnContextDecl () const
    {
      return this->AuthnContextDecl_;
    }

    AuthnContextType::AuthnContextDecl_optional& AuthnContextType::
    AuthnContextDecl ()
    {
      return this->AuthnContextDecl_;
    }

    void AuthnContextType::
    AuthnContextDecl (const AuthnContextDecl_type& AuthnContextDecl)
    {
      this->AuthnContextDecl_.set (AuthnContextDecl);
    }

    void AuthnContextType::
    AuthnContextDecl (const AuthnContextDecl_optional& AuthnContextDecl)
    {
      this->AuthnContextDecl_ = AuthnContextDecl;
    }

    void AuthnContextType::
    AuthnContextDecl (::std::auto_ptr< AuthnContextDecl_type > AuthnContextDecl)
    {
      this->AuthnContextDecl_.set (AuthnContextDecl);
    }

    const AuthnContextType::AuthnContextDeclRef_optional& AuthnContextType::
    AuthnContextDeclRef () const
    {
      return this->AuthnContextDeclRef_;
    }

    AuthnContextType::AuthnContextDeclRef_optional& AuthnContextType::
    AuthnContextDeclRef ()
    {
      return this->AuthnContextDeclRef_;
    }

    void AuthnContextType::
    AuthnContextDeclRef (const AuthnContextDeclRef_type& AuthnContextDeclRef)
    {
      this->AuthnContextDeclRef_.set (AuthnContextDeclRef);
    }

    void AuthnContextType::
    AuthnContextDeclRef (const AuthnContextDeclRef_optional& AuthnContextDeclRef)
    {
      this->AuthnContextDeclRef_ = AuthnContextDeclRef;
    }

    void AuthnContextType::
    AuthnContextDeclRef (::std::auto_ptr< AuthnContextDeclRef_type > AuthnContextDeclRef)
    {
      this->AuthnContextDeclRef_.set (AuthnContextDeclRef);
    }

    const AuthnContextType::AuthenticatingAuthority_sequence& AuthnContextType::
    AuthenticatingAuthority () const
    {
      return this->AuthenticatingAuthority_;
    }

    AuthnContextType::AuthenticatingAuthority_sequence& AuthnContextType::
    AuthenticatingAuthority ()
    {
      return this->AuthenticatingAuthority_;
    }

    void AuthnContextType::
    AuthenticatingAuthority (const AuthenticatingAuthority_sequence& AuthenticatingAuthority)
    {
      this->AuthenticatingAuthority_ = AuthenticatingAuthority;
    }


    // AuthzDecisionStatementType
    // 

    const AuthzDecisionStatementType::Action_sequence& AuthzDecisionStatementType::
    Action () const
    {
      return this->Action_;
    }

    AuthzDecisionStatementType::Action_sequence& AuthzDecisionStatementType::
    Action ()
    {
      return this->Action_;
    }

    void AuthzDecisionStatementType::
    Action (const Action_sequence& Action)
    {
      this->Action_ = Action;
    }

    const AuthzDecisionStatementType::Evidence_optional& AuthzDecisionStatementType::
    Evidence () const
    {
      return this->Evidence_;
    }

    AuthzDecisionStatementType::Evidence_optional& AuthzDecisionStatementType::
    Evidence ()
    {
      return this->Evidence_;
    }

    void AuthzDecisionStatementType::
    Evidence (const Evidence_type& Evidence)
    {
      this->Evidence_.set (Evidence);
    }

    void AuthzDecisionStatementType::
    Evidence (const Evidence_optional& Evidence)
    {
      this->Evidence_ = Evidence;
    }

    void AuthzDecisionStatementType::
    Evidence (::std::auto_ptr< Evidence_type > Evidence)
    {
      this->Evidence_.set (Evidence);
    }

    const AuthzDecisionStatementType::Resource_type& AuthzDecisionStatementType::
    Resource () const
    {
      return this->Resource_.get ();
    }

    AuthzDecisionStatementType::Resource_type& AuthzDecisionStatementType::
    Resource ()
    {
      return this->Resource_.get ();
    }

    void AuthzDecisionStatementType::
    Resource (const Resource_type& Resource)
    {
      this->Resource_.set (Resource);
    }

    void AuthzDecisionStatementType::
    Resource (::std::auto_ptr< Resource_type > Resource)
    {
      this->Resource_.set (Resource);
    }

    const AuthzDecisionStatementType::Decision_type& AuthzDecisionStatementType::
    Decision () const
    {
      return this->Decision_.get ();
    }

    AuthzDecisionStatementType::Decision_type& AuthzDecisionStatementType::
    Decision ()
    {
      return this->Decision_.get ();
    }

    void AuthzDecisionStatementType::
    Decision (const Decision_type& Decision)
    {
      this->Decision_.set (Decision);
    }

    void AuthzDecisionStatementType::
    Decision (::std::auto_ptr< Decision_type > Decision)
    {
      this->Decision_.set (Decision);
    }


    // DecisionType
    // 

    DecisionType::
    DecisionType ()
    : ::xml_schema::string ()
    {
    }

    DecisionType::
    DecisionType (value v)
    : ::xml_schema::string (_xsd_DecisionType_literals_[v])
    {
    }

    DecisionType::
    DecisionType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    DecisionType::
    DecisionType (const DecisionType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    DecisionType& DecisionType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_DecisionType_literals_[v]);

      return *this;
    }


    // ActionType
    // 

    const ActionType::Namespace_type& ActionType::
    Namespace () const
    {
      return this->Namespace_.get ();
    }

    ActionType::Namespace_type& ActionType::
    Namespace ()
    {
      return this->Namespace_.get ();
    }

    void ActionType::
    Namespace (const Namespace_type& Namespace)
    {
      this->Namespace_.set (Namespace);
    }

    void ActionType::
    Namespace (::std::auto_ptr< Namespace_type > Namespace)
    {
      this->Namespace_.set (Namespace);
    }


    // EvidenceType
    // 

    const EvidenceType::AssertionIDRef_sequence& EvidenceType::
    AssertionIDRef () const
    {
      return this->AssertionIDRef_;
    }

    EvidenceType::AssertionIDRef_sequence& EvidenceType::
    AssertionIDRef ()
    {
      return this->AssertionIDRef_;
    }

    void EvidenceType::
    AssertionIDRef (const AssertionIDRef_sequence& AssertionIDRef)
    {
      this->AssertionIDRef_ = AssertionIDRef;
    }

    const EvidenceType::AssertionURIRef_sequence& EvidenceType::
    AssertionURIRef () const
    {
      return this->AssertionURIRef_;
    }

    EvidenceType::AssertionURIRef_sequence& EvidenceType::
    AssertionURIRef ()
    {
      return this->AssertionURIRef_;
    }

    void EvidenceType::
    AssertionURIRef (const AssertionURIRef_sequence& AssertionURIRef)
    {
      this->AssertionURIRef_ = AssertionURIRef;
    }

    const EvidenceType::Assertion_sequence& EvidenceType::
    Assertion () const
    {
      return this->Assertion_;
    }

    EvidenceType::Assertion_sequence& EvidenceType::
    Assertion ()
    {
      return this->Assertion_;
    }

    void EvidenceType::
    Assertion (const Assertion_sequence& Assertion)
    {
      this->Assertion_ = Assertion;
    }

    const EvidenceType::EncryptedAssertion_sequence& EvidenceType::
    EncryptedAssertion () const
    {
      return this->EncryptedAssertion_;
    }

    EvidenceType::EncryptedAssertion_sequence& EvidenceType::
    EncryptedAssertion ()
    {
      return this->EncryptedAssertion_;
    }

    void EvidenceType::
    EncryptedAssertion (const EncryptedAssertion_sequence& EncryptedAssertion)
    {
      this->EncryptedAssertion_ = EncryptedAssertion;
    }


    // AttributeStatementType
    // 

    const AttributeStatementType::Attribute_sequence& AttributeStatementType::
    Attribute () const
    {
      return this->Attribute_;
    }

    AttributeStatementType::Attribute_sequence& AttributeStatementType::
    Attribute ()
    {
      return this->Attribute_;
    }

    void AttributeStatementType::
    Attribute (const Attribute_sequence& Attribute)
    {
      this->Attribute_ = Attribute;
    }

    const AttributeStatementType::EncryptedAttribute_sequence& AttributeStatementType::
    EncryptedAttribute () const
    {
      return this->EncryptedAttribute_;
    }

    AttributeStatementType::EncryptedAttribute_sequence& AttributeStatementType::
    EncryptedAttribute ()
    {
      return this->EncryptedAttribute_;
    }

    void AttributeStatementType::
    EncryptedAttribute (const EncryptedAttribute_sequence& EncryptedAttribute)
    {
      this->EncryptedAttribute_ = EncryptedAttribute;
    }


    // AttributeType
    // 

    const AttributeType::AttributeValue_sequence& AttributeType::
    AttributeValue () const
    {
      return this->AttributeValue_;
    }

    AttributeType::AttributeValue_sequence& AttributeType::
    AttributeValue ()
    {
      return this->AttributeValue_;
    }

    void AttributeType::
    AttributeValue (const AttributeValue_sequence& AttributeValue)
    {
      this->AttributeValue_ = AttributeValue;
    }

    const AttributeType::Name_type& AttributeType::
    Name () const
    {
      return this->Name_.get ();
    }

    AttributeType::Name_type& AttributeType::
    Name ()
    {
      return this->Name_.get ();
    }

    void AttributeType::
    Name (const Name_type& Name)
    {
      this->Name_.set (Name);
    }

    void AttributeType::
    Name (::std::auto_ptr< Name_type > Name)
    {
      this->Name_.set (Name);
    }

    const AttributeType::NameFormat_optional& AttributeType::
    NameFormat () const
    {
      return this->NameFormat_;
    }

    AttributeType::NameFormat_optional& AttributeType::
    NameFormat ()
    {
      return this->NameFormat_;
    }

    void AttributeType::
    NameFormat (const NameFormat_type& NameFormat)
    {
      this->NameFormat_.set (NameFormat);
    }

    void AttributeType::
    NameFormat (const NameFormat_optional& NameFormat)
    {
      this->NameFormat_ = NameFormat;
    }

    void AttributeType::
    NameFormat (::std::auto_ptr< NameFormat_type > NameFormat)
    {
      this->NameFormat_.set (NameFormat);
    }

    const AttributeType::FriendlyName_optional& AttributeType::
    FriendlyName () const
    {
      return this->FriendlyName_;
    }

    AttributeType::FriendlyName_optional& AttributeType::
    FriendlyName ()
    {
      return this->FriendlyName_;
    }

    void AttributeType::
    FriendlyName (const FriendlyName_type& FriendlyName)
    {
      this->FriendlyName_.set (FriendlyName);
    }

    void AttributeType::
    FriendlyName (const FriendlyName_optional& FriendlyName)
    {
      this->FriendlyName_ = FriendlyName;
    }

    void AttributeType::
    FriendlyName (::std::auto_ptr< FriendlyName_type > FriendlyName)
    {
      this->FriendlyName_.set (FriendlyName);
    }

    const AttributeType::any_attribute_set& AttributeType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    AttributeType::any_attribute_set& AttributeType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void AttributeType::
    any_attribute (const any_attribute_set& any_attribute)
    {
      this->any_attribute_ = any_attribute;
    }

    const ::xercesc::DOMDocument& AttributeType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& AttributeType::
    dom_document ()
    {
      return *dom_document_;
    }
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace saml2
{
  namespace assertion
  {
    // BaseIDAbstractType
    //

    BaseIDAbstractType::
    BaseIDAbstractType ()
    : ::xml_schema::type (),
      NameQualifier_ (::xml_schema::flags (), this),
      SPNameQualifier_ (::xml_schema::flags (), this)
    {
    }

    BaseIDAbstractType::
    BaseIDAbstractType (const BaseIDAbstractType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      NameQualifier_ (x.NameQualifier_, f, this),
      SPNameQualifier_ (x.SPNameQualifier_, f, this)
    {
    }

    BaseIDAbstractType::
    BaseIDAbstractType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NameQualifier_ (f, this),
      SPNameQualifier_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void BaseIDAbstractType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"NameQualifier" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameQualifier_type > r (
            NameQualifier_traits::create (i, f, this));

          this->NameQualifier (r);
          continue;
        }

        if (n.name () == L"SPNameQualifier" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SPNameQualifier_type > r (
            SPNameQualifier_traits::create (i, f, this));

          this->SPNameQualifier (r);
          continue;
        }
      }
    }

    BaseIDAbstractType* BaseIDAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new BaseIDAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, BaseIDAbstractType >
    _xsd_BaseIDAbstractType_type_factory_init (
      L"BaseIDAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // NameIDType
    //

    NameIDType::
    NameIDType ()
    : ::xml_schema::string (),
      NameQualifier_ (::xml_schema::flags (), this),
      SPNameQualifier_ (::xml_schema::flags (), this),
      Format_ (::xml_schema::flags (), this),
      SPProvidedID_ (::xml_schema::flags (), this)
    {
    }

    NameIDType::
    NameIDType (const ::xml_schema::string& string)
    : ::xml_schema::string (string),
      NameQualifier_ (::xml_schema::flags (), this),
      SPNameQualifier_ (::xml_schema::flags (), this),
      Format_ (::xml_schema::flags (), this),
      SPProvidedID_ (::xml_schema::flags (), this)
    {
    }

    NameIDType::
    NameIDType (const NameIDType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (x, f, c),
      NameQualifier_ (x.NameQualifier_, f, this),
      SPNameQualifier_ (x.SPNameQualifier_, f, this),
      Format_ (x.Format_, f, this),
      SPProvidedID_ (x.SPProvidedID_, f, this)
    {
    }

    NameIDType::
    NameIDType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      NameQualifier_ (f, this),
      SPNameQualifier_ (f, this),
      Format_ (f, this),
      SPProvidedID_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void NameIDType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"NameQualifier" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameQualifier_type > r (
            NameQualifier_traits::create (i, f, this));

          this->NameQualifier (r);
          continue;
        }

        if (n.name () == L"SPNameQualifier" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SPNameQualifier_type > r (
            SPNameQualifier_traits::create (i, f, this));

          this->SPNameQualifier (r);
          continue;
        }

        if (n.name () == L"Format" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Format_type > r (
            Format_traits::create (i, f, this));

          this->Format (r);
          continue;
        }

        if (n.name () == L"SPProvidedID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SPProvidedID_type > r (
            SPProvidedID_traits::create (i, f, this));

          this->SPProvidedID (r);
          continue;
        }
      }
    }

    NameIDType* NameIDType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new NameIDType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NameIDType >
    _xsd_NameIDType_type_factory_init (
      L"NameIDType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // EncryptedElementType
    //

    EncryptedElementType::
    EncryptedElementType ()
    : ::xml_schema::type (),
      EncryptedData_ (::xml_schema::flags (), this),
      EncryptedKey_ (::xml_schema::flags (), this)
    {
    }

    EncryptedElementType::
    EncryptedElementType (const EncryptedData_type& EncryptedData)
    : ::xml_schema::type (),
      EncryptedData_ (EncryptedData, ::xml_schema::flags (), this),
      EncryptedKey_ (::xml_schema::flags (), this)
    {
    }

    EncryptedElementType::
    EncryptedElementType (const EncryptedElementType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      EncryptedData_ (x.EncryptedData_, f, this),
      EncryptedKey_ (x.EncryptedKey_, f, this)
    {
    }

    EncryptedElementType::
    EncryptedElementType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EncryptedData_ (f, this),
      EncryptedKey_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void EncryptedElementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EncryptedData
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedData",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< EncryptedData_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!EncryptedData_.present ())
            {
              ::std::auto_ptr< EncryptedData_type > r (
                dynamic_cast< EncryptedData_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptedData (r);
              continue;
            }
          }
        }

        // EncryptedKey
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedKey",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< EncryptedKey_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EncryptedKey_type > r (
              dynamic_cast< EncryptedKey_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EncryptedKey ().push_back (r);
            continue;
          }
        }

        break;
      }

      if (!EncryptedData_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"EncryptedData",
          L"http://www.w3.org/2001/04/xmlenc#");
      }
    }

    EncryptedElementType* EncryptedElementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new EncryptedElementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptedElementType >
    _xsd_EncryptedElementType_type_factory_init (
      L"EncryptedElementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AssertionType
    //

    AssertionType::
    AssertionType ()
    : ::xml_schema::type (),
      Issuer_ (::xml_schema::flags (), this),
      Signature_ (::xml_schema::flags (), this),
      Subject_ (::xml_schema::flags (), this),
      Conditions_ (::xml_schema::flags (), this),
      Advice_ (::xml_schema::flags (), this),
      Statement_ (::xml_schema::flags (), this),
      AuthnStatement_ (::xml_schema::flags (), this),
      AuthzDecisionStatement_ (::xml_schema::flags (), this),
      AttributeStatement_ (::xml_schema::flags (), this),
      Version_ (::xml_schema::flags (), this),
      ID_ (::xml_schema::flags (), this),
      IssueInstant_ (::xml_schema::flags (), this)
    {
    }

    AssertionType::
    AssertionType (const Issuer_type& Issuer,
                   const Version_type& Version,
                   const ID_type& ID,
                   const IssueInstant_type& IssueInstant)
    : ::xml_schema::type (),
      Issuer_ (Issuer, ::xml_schema::flags (), this),
      Signature_ (::xml_schema::flags (), this),
      Subject_ (::xml_schema::flags (), this),
      Conditions_ (::xml_schema::flags (), this),
      Advice_ (::xml_schema::flags (), this),
      Statement_ (::xml_schema::flags (), this),
      AuthnStatement_ (::xml_schema::flags (), this),
      AuthzDecisionStatement_ (::xml_schema::flags (), this),
      AttributeStatement_ (::xml_schema::flags (), this),
      Version_ (Version, ::xml_schema::flags (), this),
      ID_ (ID, ::xml_schema::flags (), this),
      IssueInstant_ (IssueInstant, ::xml_schema::flags (), this)
    {
    }

    AssertionType::
    AssertionType (const AssertionType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      Issuer_ (x.Issuer_, f, this),
      Signature_ (x.Signature_, f, this),
      Subject_ (x.Subject_, f, this),
      Conditions_ (x.Conditions_, f, this),
      Advice_ (x.Advice_, f, this),
      Statement_ (x.Statement_, f, this),
      AuthnStatement_ (x.AuthnStatement_, f, this),
      AuthzDecisionStatement_ (x.AuthzDecisionStatement_, f, this),
      AttributeStatement_ (x.AttributeStatement_, f, this),
      Version_ (x.Version_, f, this),
      ID_ (x.ID_, f, this),
      IssueInstant_ (x.IssueInstant_, f, this)
    {
    }

    AssertionType::
    AssertionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Issuer_ (f, this),
      Signature_ (f, this),
      Subject_ (f, this),
      Conditions_ (f, this),
      Advice_ (f, this),
      Statement_ (f, this),
      AuthnStatement_ (f, this),
      AuthzDecisionStatement_ (f, this),
      AttributeStatement_ (f, this),
      Version_ (f, this),
      ID_ (f, this),
      IssueInstant_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AssertionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Issuer
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Issuer",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Issuer_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Issuer_.present ())
            {
              ::std::auto_ptr< Issuer_type > r (
                dynamic_cast< Issuer_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Issuer (r);
              continue;
            }
          }
        }

        // Signature
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Signature_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Signature ())
            {
              ::std::auto_ptr< Signature_type > r (
                dynamic_cast< Signature_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Signature (r);
              continue;
            }
          }
        }

        // Subject
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Subject",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Subject_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Subject ())
            {
              ::std::auto_ptr< Subject_type > r (
                dynamic_cast< Subject_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Subject (r);
              continue;
            }
          }
        }

        // Conditions
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Conditions",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Conditions_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Conditions ())
            {
              ::std::auto_ptr< Conditions_type > r (
                dynamic_cast< Conditions_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Conditions (r);
              continue;
            }
          }
        }

        // Advice
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Advice",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Advice_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Advice ())
            {
              ::std::auto_ptr< Advice_type > r (
                dynamic_cast< Advice_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Advice (r);
              continue;
            }
          }
        }

        // Statement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Statement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Statement_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Statement_type > r (
              dynamic_cast< Statement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Statement ().push_back (r);
            continue;
          }
        }

        // AuthnStatement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthnStatement_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthnStatement_type > r (
              dynamic_cast< AuthnStatement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthnStatement ().push_back (r);
            continue;
          }
        }

        // AuthzDecisionStatement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthzDecisionStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthzDecisionStatement_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthzDecisionStatement_type > r (
              dynamic_cast< AuthzDecisionStatement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthzDecisionStatement ().push_back (r);
            continue;
          }
        }

        // AttributeStatement
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AttributeStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AttributeStatement_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AttributeStatement_type > r (
              dynamic_cast< AttributeStatement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AttributeStatement ().push_back (r);
            continue;
          }
        }

        break;
      }

      if (!Issuer_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Issuer",
          L"urn:oasis:names:tc:SAML:2.0:assertion");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Version" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          this->Version (r);
          continue;
        }

        if (n.name () == L"ID" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< ID_type > r (
            ID_traits::create (i, f, this));

          this->ID (r);
          continue;
        }

        if (n.name () == L"IssueInstant" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< IssueInstant_type > r (
            IssueInstant_traits::create (i, f, this));

          this->IssueInstant (r);
          continue;
        }
      }

      if (!Version_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Version",
          L"");
      }

      if (!ID_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"ID",
          L"");
      }

      if (!IssueInstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"IssueInstant",
          L"");
      }
    }

    AssertionType* AssertionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AssertionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AssertionType >
    _xsd_AssertionType_type_factory_init (
      L"AssertionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectType
    //

    SubjectType::
    SubjectType ()
    : ::xml_schema::type (),
      BaseID_ (::xml_schema::flags (), this),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      SubjectConfirmation_ (::xml_schema::flags (), this)
    {
    }

    SubjectType::
    SubjectType (const SubjectType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      BaseID_ (x.BaseID_, f, this),
      NameID_ (x.NameID_, f, this),
      EncryptedID_ (x.EncryptedID_, f, this),
      SubjectConfirmation_ (x.SubjectConfirmation_, f, this)
    {
    }

    SubjectType::
    SubjectType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseID_ (f, this),
      NameID_ (f, this),
      EncryptedID_ (f, this),
      SubjectConfirmation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void SubjectType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< BaseID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->BaseID ())
            {
              ::std::auto_ptr< BaseID_type > r (
                dynamic_cast< BaseID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BaseID (r);
              continue;
            }
          }
        }

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< NameID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NameID ())
            {
              ::std::auto_ptr< NameID_type > r (
                dynamic_cast< NameID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameID (r);
              continue;
            }
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptedID ())
            {
              ::std::auto_ptr< EncryptedID_type > r (
                dynamic_cast< EncryptedID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptedID (r);
              continue;
            }
          }
        }

        // SubjectConfirmation
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SubjectConfirmation",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< SubjectConfirmation_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< SubjectConfirmation_type > r (
              dynamic_cast< SubjectConfirmation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->SubjectConfirmation ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    SubjectType* SubjectType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectType >
    _xsd_SubjectType_type_factory_init (
      L"SubjectType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectConfirmationType
    //

    SubjectConfirmationType::
    SubjectConfirmationType ()
    : ::xml_schema::type (),
      BaseID_ (::xml_schema::flags (), this),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      SubjectConfirmationData_ (::xml_schema::flags (), this),
      Method_ (::xml_schema::flags (), this)
    {
    }

    SubjectConfirmationType::
    SubjectConfirmationType (const Method_type& Method)
    : ::xml_schema::type (),
      BaseID_ (::xml_schema::flags (), this),
      NameID_ (::xml_schema::flags (), this),
      EncryptedID_ (::xml_schema::flags (), this),
      SubjectConfirmationData_ (::xml_schema::flags (), this),
      Method_ (Method, ::xml_schema::flags (), this)
    {
    }

    SubjectConfirmationType::
    SubjectConfirmationType (const SubjectConfirmationType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      BaseID_ (x.BaseID_, f, this),
      NameID_ (x.NameID_, f, this),
      EncryptedID_ (x.EncryptedID_, f, this),
      SubjectConfirmationData_ (x.SubjectConfirmationData_, f, this),
      Method_ (x.Method_, f, this)
    {
    }

    SubjectConfirmationType::
    SubjectConfirmationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseID_ (f, this),
      NameID_ (f, this),
      EncryptedID_ (f, this),
      SubjectConfirmationData_ (f, this),
      Method_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void SubjectConfirmationType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // BaseID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< BaseID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->BaseID ())
            {
              ::std::auto_ptr< BaseID_type > r (
                dynamic_cast< BaseID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->BaseID (r);
              continue;
            }
          }
        }

        // NameID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< NameID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->NameID ())
            {
              ::std::auto_ptr< NameID_type > r (
                dynamic_cast< NameID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->NameID (r);
              continue;
            }
          }
        }

        // EncryptedID
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedID_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptedID ())
            {
              ::std::auto_ptr< EncryptedID_type > r (
                dynamic_cast< EncryptedID_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptedID (r);
              continue;
            }
          }
        }

        // SubjectConfirmationData
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SubjectConfirmationData",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< SubjectConfirmationData_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->SubjectConfirmationData ())
            {
              ::std::auto_ptr< SubjectConfirmationData_type > r (
                dynamic_cast< SubjectConfirmationData_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->SubjectConfirmationData (r);
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Method" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Method_type > r (
            Method_traits::create (i, f, this));

          this->Method (r);
          continue;
        }
      }

      if (!Method_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Method",
          L"");
      }
    }

    SubjectConfirmationType* SubjectConfirmationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectConfirmationType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectConfirmationType >
    _xsd_SubjectConfirmationType_type_factory_init (
      L"SubjectConfirmationType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectConfirmationDataType
    //

    SubjectConfirmationDataType::
    SubjectConfirmationDataType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      NotBefore_ (::xml_schema::flags (), this),
      NotOnOrAfter_ (::xml_schema::flags (), this),
      Recipient_ (::xml_schema::flags (), this),
      InResponseTo_ (::xml_schema::flags (), this),
      Address_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    SubjectConfirmationDataType::
    SubjectConfirmationDataType (const ::xml_schema::type& anyType)
    : ::xml_schema::type (anyType),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      NotBefore_ (::xml_schema::flags (), this),
      NotOnOrAfter_ (::xml_schema::flags (), this),
      Recipient_ (::xml_schema::flags (), this),
      InResponseTo_ (::xml_schema::flags (), this),
      Address_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    SubjectConfirmationDataType::
    SubjectConfirmationDataType (const SubjectConfirmationDataType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      NotBefore_ (x.NotBefore_, f, this),
      NotOnOrAfter_ (x.NotOnOrAfter_, f, this),
      Recipient_ (x.Recipient_, f, this),
      InResponseTo_ (x.InResponseTo_, f, this),
      Address_ (x.Address_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    SubjectConfirmationDataType::
    SubjectConfirmationDataType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      NotBefore_ (f, this),
      NotOnOrAfter_ (f, this),
      Recipient_ (f, this),
      InResponseTo_ (f, this),
      Address_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void SubjectConfirmationDataType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any ().push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"NotBefore" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotBefore_type > r (
            NotBefore_traits::create (i, f, this));

          this->NotBefore (r);
          continue;
        }

        if (n.name () == L"NotOnOrAfter" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotOnOrAfter_type > r (
            NotOnOrAfter_traits::create (i, f, this));

          this->NotOnOrAfter (r);
          continue;
        }

        if (n.name () == L"Recipient" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Recipient_type > r (
            Recipient_traits::create (i, f, this));

          this->Recipient (r);
          continue;
        }

        if (n.name () == L"InResponseTo" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< InResponseTo_type > r (
            InResponseTo_traits::create (i, f, this));

          this->InResponseTo (r);
          continue;
        }

        if (n.name () == L"Address" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          this->Address (r);
          continue;
        }

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:assertion" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }
    }

    SubjectConfirmationDataType* SubjectConfirmationDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectConfirmationDataType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectConfirmationDataType >
    _xsd_SubjectConfirmationDataType_type_factory_init (
      L"SubjectConfirmationDataType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // KeyInfoConfirmationDataType
    //

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType ()
    : ::saml2::assertion::SubjectConfirmationDataType ()
    {
    }

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType (const ::xml_schema::type& anyType)
    : ::saml2::assertion::SubjectConfirmationDataType (anyType)
    {
    }

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType (const KeyInfoConfirmationDataType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::saml2::assertion::SubjectConfirmationDataType (x, f, c)
    {
    }

    KeyInfoConfirmationDataType::
    KeyInfoConfirmationDataType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
    : ::saml2::assertion::SubjectConfirmationDataType (e, f, c)
    {
    }

    KeyInfoConfirmationDataType* KeyInfoConfirmationDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new KeyInfoConfirmationDataType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, KeyInfoConfirmationDataType >
    _xsd_KeyInfoConfirmationDataType_type_factory_init (
      L"KeyInfoConfirmationDataType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // ConditionsType
    //

    ConditionsType::
    ConditionsType ()
    : ::xml_schema::type (),
      Condition_ (::xml_schema::flags (), this),
      AudienceRestriction_ (::xml_schema::flags (), this),
      OneTimeUse_ (::xml_schema::flags (), this),
      ProxyRestriction_ (::xml_schema::flags (), this),
      NotBefore_ (::xml_schema::flags (), this),
      NotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    ConditionsType::
    ConditionsType (const ConditionsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      Condition_ (x.Condition_, f, this),
      AudienceRestriction_ (x.AudienceRestriction_, f, this),
      OneTimeUse_ (x.OneTimeUse_, f, this),
      ProxyRestriction_ (x.ProxyRestriction_, f, this),
      NotBefore_ (x.NotBefore_, f, this),
      NotOnOrAfter_ (x.NotOnOrAfter_, f, this)
    {
    }

    ConditionsType::
    ConditionsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Condition_ (f, this),
      AudienceRestriction_ (f, this),
      OneTimeUse_ (f, this),
      ProxyRestriction_ (f, this),
      NotBefore_ (f, this),
      NotOnOrAfter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ConditionsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Condition
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Condition",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Condition_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Condition_type > r (
              dynamic_cast< Condition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Condition ().push_back (r);
            continue;
          }
        }

        // AudienceRestriction
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AudienceRestriction",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AudienceRestriction_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AudienceRestriction_type > r (
              dynamic_cast< AudienceRestriction_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AudienceRestriction ().push_back (r);
            continue;
          }
        }

        // OneTimeUse
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"OneTimeUse",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< OneTimeUse_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< OneTimeUse_type > r (
              dynamic_cast< OneTimeUse_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->OneTimeUse ().push_back (r);
            continue;
          }
        }

        // ProxyRestriction
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"ProxyRestriction",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< ProxyRestriction_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ProxyRestriction_type > r (
              dynamic_cast< ProxyRestriction_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->ProxyRestriction ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"NotBefore" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotBefore_type > r (
            NotBefore_traits::create (i, f, this));

          this->NotBefore (r);
          continue;
        }

        if (n.name () == L"NotOnOrAfter" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NotOnOrAfter_type > r (
            NotOnOrAfter_traits::create (i, f, this));

          this->NotOnOrAfter (r);
          continue;
        }
      }
    }

    ConditionsType* ConditionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ConditionsType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConditionsType >
    _xsd_ConditionsType_type_factory_init (
      L"ConditionsType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // ConditionAbstractType
    //

    ConditionAbstractType::
    ConditionAbstractType ()
    : ::xml_schema::type ()
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ConditionAbstractType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    ConditionAbstractType::
    ConditionAbstractType (const ::std::wstring& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    ConditionAbstractType* ConditionAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ConditionAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ConditionAbstractType >
    _xsd_ConditionAbstractType_type_factory_init (
      L"ConditionAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AudienceRestrictionType
    //

    AudienceRestrictionType::
    AudienceRestrictionType ()
    : ::saml2::assertion::ConditionAbstractType (),
      Audience_ (::xml_schema::flags (), this)
    {
    }

    AudienceRestrictionType::
    AudienceRestrictionType (const AudienceRestrictionType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (x, f, c),
      Audience_ (x.Audience_, f, this)
    {
    }

    AudienceRestrictionType::
    AudienceRestrictionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (e, f | ::xml_schema::flags::base, c),
      Audience_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AudienceRestrictionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Audience
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Audience",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Audience_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Audience_type > r (
              dynamic_cast< Audience_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Audience ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AudienceRestrictionType* AudienceRestrictionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AudienceRestrictionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AudienceRestrictionType >
    _xsd_AudienceRestrictionType_type_factory_init (
      L"AudienceRestrictionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // OneTimeUseType
    //

    OneTimeUseType::
    OneTimeUseType ()
    : ::saml2::assertion::ConditionAbstractType ()
    {
    }

    OneTimeUseType::
    OneTimeUseType (const OneTimeUseType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (x, f, c)
    {
    }

    OneTimeUseType::
    OneTimeUseType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (e, f, c)
    {
    }

    OneTimeUseType::
    OneTimeUseType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (a, f, c)
    {
    }

    OneTimeUseType::
    OneTimeUseType (const ::std::wstring& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (s, e, f, c)
    {
    }

    OneTimeUseType* OneTimeUseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new OneTimeUseType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, OneTimeUseType >
    _xsd_OneTimeUseType_type_factory_init (
      L"OneTimeUseType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // ProxyRestrictionType
    //

    ProxyRestrictionType::
    ProxyRestrictionType ()
    : ::saml2::assertion::ConditionAbstractType (),
      Audience_ (::xml_schema::flags (), this),
      Count_ (::xml_schema::flags (), this)
    {
    }

    ProxyRestrictionType::
    ProxyRestrictionType (const ProxyRestrictionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (x, f, c),
      Audience_ (x.Audience_, f, this),
      Count_ (x.Count_, f, this)
    {
    }

    ProxyRestrictionType::
    ProxyRestrictionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
    : ::saml2::assertion::ConditionAbstractType (e, f | ::xml_schema::flags::base, c),
      Audience_ (f, this),
      Count_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ProxyRestrictionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Audience
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Audience",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Audience_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Audience_type > r (
              dynamic_cast< Audience_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Audience ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Count" && n.namespace_ ().empty ())
        {
          this->Count (Count_traits::create (i, f, this));
          continue;
        }
      }
    }

    ProxyRestrictionType* ProxyRestrictionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ProxyRestrictionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ProxyRestrictionType >
    _xsd_ProxyRestrictionType_type_factory_init (
      L"ProxyRestrictionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AdviceType
    //

    AdviceType::
    AdviceType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      AssertionIDRef_ (::xml_schema::flags (), this),
      AssertionURIRef_ (::xml_schema::flags (), this),
      Assertion_ (::xml_schema::flags (), this),
      EncryptedAssertion_ (::xml_schema::flags (), this),
      any_ (this->dom_document ())
    {
    }

    AdviceType::
    AdviceType (const AdviceType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      AssertionIDRef_ (x.AssertionIDRef_, f, this),
      AssertionURIRef_ (x.AssertionURIRef_, f, this),
      Assertion_ (x.Assertion_, f, this),
      EncryptedAssertion_ (x.EncryptedAssertion_, f, this),
      any_ (x.any_, this->dom_document ())
    {
    }

    AdviceType::
    AdviceType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      AssertionIDRef_ (f, this),
      AssertionURIRef_ (f, this),
      Assertion_ (f, this),
      EncryptedAssertion_ (f, this),
      any_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AdviceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AssertionIDRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AssertionIDRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionIDRef_type > r (
              dynamic_cast< AssertionIDRef_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionIDRef ().push_back (r);
            continue;
          }
        }

        // AssertionURIRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionURIRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AssertionURIRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionURIRef_type > r (
              dynamic_cast< AssertionURIRef_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionURIRef ().push_back (r);
            continue;
          }
        }

        // Assertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Assertion_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Assertion_type > r (
              dynamic_cast< Assertion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Assertion ().push_back (r);
            continue;
          }
        }

        // EncryptedAssertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedAssertion_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EncryptedAssertion_type > r (
              dynamic_cast< EncryptedAssertion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EncryptedAssertion ().push_back (r);
            continue;
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:assertion"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any ().push_back (r);
          continue;
        }

        break;
      }
    }

    AdviceType* AdviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AdviceType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AdviceType >
    _xsd_AdviceType_type_factory_init (
      L"AdviceType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // StatementAbstractType
    //

    StatementAbstractType::
    StatementAbstractType ()
    : ::xml_schema::type ()
    {
    }

    StatementAbstractType::
    StatementAbstractType (const StatementAbstractType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    StatementAbstractType::
    StatementAbstractType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    StatementAbstractType::
    StatementAbstractType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    StatementAbstractType::
    StatementAbstractType (const ::std::wstring& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    StatementAbstractType* StatementAbstractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new StatementAbstractType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, StatementAbstractType >
    _xsd_StatementAbstractType_type_factory_init (
      L"StatementAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AuthnStatementType
    //

    AuthnStatementType::
    AuthnStatementType ()
    : ::saml2::assertion::StatementAbstractType (),
      SubjectLocality_ (::xml_schema::flags (), this),
      AuthnContext_ (::xml_schema::flags (), this),
      AuthnInstant_ (::xml_schema::flags (), this),
      SessionIndex_ (::xml_schema::flags (), this),
      SessionNotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    AuthnStatementType::
    AuthnStatementType (const AuthnContext_type& AuthnContext,
                        const AuthnInstant_type& AuthnInstant)
    : ::saml2::assertion::StatementAbstractType (),
      SubjectLocality_ (::xml_schema::flags (), this),
      AuthnContext_ (AuthnContext, ::xml_schema::flags (), this),
      AuthnInstant_ (AuthnInstant, ::xml_schema::flags (), this),
      SessionIndex_ (::xml_schema::flags (), this),
      SessionNotOnOrAfter_ (::xml_schema::flags (), this)
    {
    }

    AuthnStatementType::
    AuthnStatementType (const AuthnStatementType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (x, f, c),
      SubjectLocality_ (x.SubjectLocality_, f, this),
      AuthnContext_ (x.AuthnContext_, f, this),
      AuthnInstant_ (x.AuthnInstant_, f, this),
      SessionIndex_ (x.SessionIndex_, f, this),
      SessionNotOnOrAfter_ (x.SessionNotOnOrAfter_, f, this)
    {
    }

    AuthnStatementType::
    AuthnStatementType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (e, f | ::xml_schema::flags::base, c),
      SubjectLocality_ (f, this),
      AuthnContext_ (f, this),
      AuthnInstant_ (f, this),
      SessionIndex_ (f, this),
      SessionNotOnOrAfter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AuthnStatementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SubjectLocality
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"SubjectLocality",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< SubjectLocality_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->SubjectLocality ())
            {
              ::std::auto_ptr< SubjectLocality_type > r (
                dynamic_cast< SubjectLocality_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->SubjectLocality (r);
              continue;
            }
          }
        }

        // AuthnContext
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnContext",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthnContext_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!AuthnContext_.present ())
            {
              ::std::auto_ptr< AuthnContext_type > r (
                dynamic_cast< AuthnContext_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->AuthnContext (r);
              continue;
            }
          }
        }

        break;
      }

      if (!AuthnContext_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"AuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:assertion");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"AuthnInstant" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< AuthnInstant_type > r (
            AuthnInstant_traits::create (i, f, this));

          this->AuthnInstant (r);
          continue;
        }

        if (n.name () == L"SessionIndex" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SessionIndex_type > r (
            SessionIndex_traits::create (i, f, this));

          this->SessionIndex (r);
          continue;
        }

        if (n.name () == L"SessionNotOnOrAfter" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< SessionNotOnOrAfter_type > r (
            SessionNotOnOrAfter_traits::create (i, f, this));

          this->SessionNotOnOrAfter (r);
          continue;
        }
      }

      if (!AuthnInstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"AuthnInstant",
          L"");
      }
    }

    AuthnStatementType* AuthnStatementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnStatementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnStatementType >
    _xsd_AuthnStatementType_type_factory_init (
      L"AuthnStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // SubjectLocalityType
    //

    SubjectLocalityType::
    SubjectLocalityType ()
    : ::xml_schema::type (),
      Address_ (::xml_schema::flags (), this),
      DNSName_ (::xml_schema::flags (), this)
    {
    }

    SubjectLocalityType::
    SubjectLocalityType (const SubjectLocalityType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      Address_ (x.Address_, f, this),
      DNSName_ (x.DNSName_, f, this)
    {
    }

    SubjectLocalityType::
    SubjectLocalityType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Address_ (f, this),
      DNSName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void SubjectLocalityType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Address" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          this->Address (r);
          continue;
        }

        if (n.name () == L"DNSName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< DNSName_type > r (
            DNSName_traits::create (i, f, this));

          this->DNSName (r);
          continue;
        }
      }
    }

    SubjectLocalityType* SubjectLocalityType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new SubjectLocalityType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SubjectLocalityType >
    _xsd_SubjectLocalityType_type_factory_init (
      L"SubjectLocalityType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AuthnContextType
    //

    AuthnContextType::
    AuthnContextType ()
    : ::xml_schema::type (),
      AuthnContextClassRef_ (::xml_schema::flags (), this),
      AuthnContextDecl_ (::xml_schema::flags (), this),
      AuthnContextDeclRef_ (::xml_schema::flags (), this),
      AuthenticatingAuthority_ (::xml_schema::flags (), this)
    {
    }

    AuthnContextType::
    AuthnContextType (const AuthnContextType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      AuthnContextClassRef_ (x.AuthnContextClassRef_, f, this),
      AuthnContextDecl_ (x.AuthnContextDecl_, f, this),
      AuthnContextDeclRef_ (x.AuthnContextDeclRef_, f, this),
      AuthenticatingAuthority_ (x.AuthenticatingAuthority_, f, this)
    {
    }

    AuthnContextType::
    AuthnContextType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AuthnContextClassRef_ (f, this),
      AuthnContextDecl_ (f, this),
      AuthnContextDeclRef_ (f, this),
      AuthenticatingAuthority_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AuthnContextType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AuthnContextClassRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnContextClassRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthnContextClassRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->AuthnContextClassRef ())
            {
              ::std::auto_ptr< AuthnContextClassRef_type > r (
                dynamic_cast< AuthnContextClassRef_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->AuthnContextClassRef (r);
              continue;
            }
          }
        }

        // AuthnContextDecl
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnContextDecl",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthnContextDecl_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->AuthnContextDecl ())
            {
              ::std::auto_ptr< AuthnContextDecl_type > r (
                dynamic_cast< AuthnContextDecl_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->AuthnContextDecl (r);
              continue;
            }
          }
        }

        // AuthnContextDeclRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthnContextDeclRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthnContextDeclRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->AuthnContextDeclRef ())
            {
              ::std::auto_ptr< AuthnContextDeclRef_type > r (
                dynamic_cast< AuthnContextDeclRef_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->AuthnContextDeclRef (r);
              continue;
            }
          }
        }

        // AuthenticatingAuthority
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AuthenticatingAuthority",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AuthenticatingAuthority_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AuthenticatingAuthority_type > r (
              dynamic_cast< AuthenticatingAuthority_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AuthenticatingAuthority ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AuthnContextType* AuthnContextType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthnContextType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthnContextType >
    _xsd_AuthnContextType_type_factory_init (
      L"AuthnContextType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AuthzDecisionStatementType
    //

    AuthzDecisionStatementType::
    AuthzDecisionStatementType ()
    : ::saml2::assertion::StatementAbstractType (),
      Action_ (::xml_schema::flags (), this),
      Evidence_ (::xml_schema::flags (), this),
      Resource_ (::xml_schema::flags (), this),
      Decision_ (::xml_schema::flags (), this)
    {
    }

    AuthzDecisionStatementType::
    AuthzDecisionStatementType (const Resource_type& Resource,
                                const Decision_type& Decision)
    : ::saml2::assertion::StatementAbstractType (),
      Action_ (::xml_schema::flags (), this),
      Evidence_ (::xml_schema::flags (), this),
      Resource_ (Resource, ::xml_schema::flags (), this),
      Decision_ (Decision, ::xml_schema::flags (), this)
    {
    }

    AuthzDecisionStatementType::
    AuthzDecisionStatementType (const AuthzDecisionStatementType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (x, f, c),
      Action_ (x.Action_, f, this),
      Evidence_ (x.Evidence_, f, this),
      Resource_ (x.Resource_, f, this),
      Decision_ (x.Decision_, f, this)
    {
    }

    AuthzDecisionStatementType::
    AuthzDecisionStatementType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (e, f | ::xml_schema::flags::base, c),
      Action_ (f, this),
      Evidence_ (f, this),
      Resource_ (f, this),
      Decision_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AuthzDecisionStatementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Action
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Action",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Action_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Action_type > r (
              dynamic_cast< Action_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Action ().push_back (r);
            continue;
          }
        }

        // Evidence
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Evidence",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Evidence_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Evidence ())
            {
              ::std::auto_ptr< Evidence_type > r (
                dynamic_cast< Evidence_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Evidence (r);
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Resource" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Resource_type > r (
            Resource_traits::create (i, f, this));

          this->Resource (r);
          continue;
        }

        if (n.name () == L"Decision" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Decision_type > r (
            Decision_traits::create (i, f, this));

          this->Decision (r);
          continue;
        }
      }

      if (!Resource_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Resource",
          L"");
      }

      if (!Decision_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Decision",
          L"");
      }
    }

    AuthzDecisionStatementType* AuthzDecisionStatementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AuthzDecisionStatementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AuthzDecisionStatementType >
    _xsd_AuthzDecisionStatementType_type_factory_init (
      L"AuthzDecisionStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // DecisionType
    //

    DecisionType::
    DecisionType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_DecisionType_convert ();
    }

    DecisionType::
    DecisionType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_DecisionType_convert ();
    }

    DecisionType::
    DecisionType (const ::std::wstring& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_DecisionType_convert ();
    }

    DecisionType* DecisionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new DecisionType (*this, f, c);
    }

    DecisionType::value DecisionType::
    _xsd_DecisionType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_DecisionType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DecisionType_indexes_,
                        _xsd_DecisionType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DecisionType_indexes_ + 3 || _xsd_DecisionType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
      }

      return *i;
    }

    const wchar_t* const DecisionType::
    _xsd_DecisionType_literals_[3] =
    {
      L"Permit",
      L"Deny",
      L"Indeterminate"
    };

    const DecisionType::value DecisionType::
    _xsd_DecisionType_indexes_[3] =
    {
      ::saml2::assertion::DecisionType::Deny,
      ::saml2::assertion::DecisionType::Indeterminate,
      ::saml2::assertion::DecisionType::Permit
    };

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, DecisionType >
    _xsd_DecisionType_type_factory_init (
      L"DecisionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // ActionType
    //

    ActionType::
    ActionType ()
    : ::xml_schema::string (),
      Namespace_ (::xml_schema::flags (), this)
    {
    }

    ActionType::
    ActionType (const Namespace_type& Namespace)
    : ::xml_schema::string (),
      Namespace_ (Namespace, ::xml_schema::flags (), this)
    {
    }

    ActionType::
    ActionType (const ::xml_schema::string& string,
                const Namespace_type& Namespace)
    : ::xml_schema::string (string),
      Namespace_ (Namespace, ::xml_schema::flags (), this)
    {
    }

    ActionType::
    ActionType (const ActionType& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (x, f, c),
      Namespace_ (x.Namespace_, f, this)
    {
    }

    ActionType::
    ActionType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      Namespace_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void ActionType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Namespace" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Namespace_type > r (
            Namespace_traits::create (i, f, this));

          this->Namespace (r);
          continue;
        }
      }

      if (!Namespace_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Namespace",
          L"");
      }
    }

    ActionType* ActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new ActionType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ActionType >
    _xsd_ActionType_type_factory_init (
      L"ActionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // EvidenceType
    //

    EvidenceType::
    EvidenceType ()
    : ::xml_schema::type (),
      AssertionIDRef_ (::xml_schema::flags (), this),
      AssertionURIRef_ (::xml_schema::flags (), this),
      Assertion_ (::xml_schema::flags (), this),
      EncryptedAssertion_ (::xml_schema::flags (), this)
    {
    }

    EvidenceType::
    EvidenceType (const EvidenceType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      AssertionIDRef_ (x.AssertionIDRef_, f, this),
      AssertionURIRef_ (x.AssertionURIRef_, f, this),
      Assertion_ (x.Assertion_, f, this),
      EncryptedAssertion_ (x.EncryptedAssertion_, f, this)
    {
    }

    EvidenceType::
    EvidenceType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AssertionIDRef_ (f, this),
      AssertionURIRef_ (f, this),
      Assertion_ (f, this),
      EncryptedAssertion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void EvidenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AssertionIDRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AssertionIDRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionIDRef_type > r (
              dynamic_cast< AssertionIDRef_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionIDRef ().push_back (r);
            continue;
          }
        }

        // AssertionURIRef
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AssertionURIRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AssertionURIRef_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AssertionURIRef_type > r (
              dynamic_cast< AssertionURIRef_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AssertionURIRef ().push_back (r);
            continue;
          }
        }

        // Assertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Assertion_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Assertion_type > r (
              dynamic_cast< Assertion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Assertion ().push_back (r);
            continue;
          }
        }

        // EncryptedAssertion
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedAssertion_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EncryptedAssertion_type > r (
              dynamic_cast< EncryptedAssertion_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EncryptedAssertion ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    EvidenceType* EvidenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new EvidenceType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EvidenceType >
    _xsd_EvidenceType_type_factory_init (
      L"EvidenceType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AttributeStatementType
    //

    AttributeStatementType::
    AttributeStatementType ()
    : ::saml2::assertion::StatementAbstractType (),
      Attribute_ (::xml_schema::flags (), this),
      EncryptedAttribute_ (::xml_schema::flags (), this)
    {
    }

    AttributeStatementType::
    AttributeStatementType (const AttributeStatementType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (x, f, c),
      Attribute_ (x.Attribute_, f, this),
      EncryptedAttribute_ (x.EncryptedAttribute_, f, this)
    {
    }

    AttributeStatementType::
    AttributeStatementType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::type* c)
    : ::saml2::assertion::StatementAbstractType (e, f | ::xml_schema::flags::base, c),
      Attribute_ (f, this),
      EncryptedAttribute_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AttributeStatementType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Attribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< Attribute_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Attribute_type > r (
              dynamic_cast< Attribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Attribute ().push_back (r);
            continue;
          }
        }

        // EncryptedAttribute
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"EncryptedAttribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< EncryptedAttribute_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EncryptedAttribute_type > r (
              dynamic_cast< EncryptedAttribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EncryptedAttribute ().push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AttributeStatementType* AttributeStatementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AttributeStatementType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeStatementType >
    _xsd_AttributeStatementType_type_factory_init (
      L"AttributeStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    // AttributeType
    //

    AttributeType::
    AttributeType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      AttributeValue_ (::xml_schema::flags (), this),
      Name_ (::xml_schema::flags (), this),
      NameFormat_ (::xml_schema::flags (), this),
      FriendlyName_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    AttributeType::
    AttributeType (const Name_type& Name)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      AttributeValue_ (::xml_schema::flags (), this),
      Name_ (Name, ::xml_schema::flags (), this),
      NameFormat_ (::xml_schema::flags (), this),
      FriendlyName_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    AttributeType::
    AttributeType (const AttributeType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      AttributeValue_ (x.AttributeValue_, f, this),
      Name_ (x.Name_, f, this),
      NameFormat_ (x.NameFormat_, f, this),
      FriendlyName_ (x.FriendlyName_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    AttributeType::
    AttributeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      AttributeValue_ (f, this),
      Name_ (f, this),
      NameFormat_ (f, this),
      FriendlyName_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e);
        this->parse (p, f);
      }
    }

    void AttributeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // AttributeValue
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xml_schema::type > tmp (
            tfm.create (
              L"AttributeValue",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              &::xsd::cxx::tree::factory_impl< AttributeValue_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AttributeValue_type > r (
              dynamic_cast< AttributeValue_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->AttributeValue ().push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          this->Name (r);
          continue;
        }

        if (n.name () == L"NameFormat" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< NameFormat_type > r (
            NameFormat_traits::create (i, f, this));

          this->NameFormat (r);
          continue;
        }

        if (n.name () == L"FriendlyName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< FriendlyName_type > r (
            FriendlyName_traits::create (i, f, this));

          this->FriendlyName (r);
          continue;
        }

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"urn:oasis:names:tc:SAML:2.0:assertion" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute ().insert (r);
          continue;
        }
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Name",
          L"");
      }
    }

    AttributeType* AttributeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::type* c) const
    {
      return new AttributeType (*this, f, c);
    }

    static
    ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AttributeType >
    _xsd_AttributeType_type_factory_init (
      L"AttributeType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace saml2
{
  namespace assertion
  {
    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
        ::saml2::assertion::BaseID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
        ::saml2::assertion::BaseID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
        ::saml2::assertion::BaseID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::BaseID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
        ::saml2::assertion::BaseID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMInputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
        ::saml2::assertion::BaseID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
        ::saml2::assertion::BaseID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
          ::saml2::assertion::BaseID (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"BaseID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::BaseIDAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
          dynamic_cast< ::saml2::assertion::BaseIDAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"BaseID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType >
    BaseID (::xercesc::DOMDocument* d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"BaseID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::BaseIDAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::BaseIDAbstractType > r (
          dynamic_cast< ::saml2::assertion::BaseIDAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"BaseID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::NameID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::NameID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::NameID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::NameID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::NameID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMInputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::NameID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::NameID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
          ::saml2::assertion::NameID (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::NameIDType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
          dynamic_cast< ::saml2::assertion::NameIDType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    NameID (::xercesc::DOMDocument* d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"NameID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::NameIDType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
          dynamic_cast< ::saml2::assertion::NameIDType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NameID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::std::wstring& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::std::wstring& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::std::wstring& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedID (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMInputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMInputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedID (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          ::saml2::assertion::EncryptedID (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptedID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedID (::xercesc::DOMDocument* d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptedID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedID",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::Issuer (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::Issuer (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::Issuer (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Issuer (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::Issuer (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMInputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::Issuer (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
        ::saml2::assertion::Issuer (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
          ::saml2::assertion::Issuer (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Issuer",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::NameIDType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
          dynamic_cast< ::saml2::assertion::NameIDType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Issuer",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::NameIDType >
    Issuer (::xercesc::DOMDocument* d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Issuer",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::NameIDType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::NameIDType > r (
          dynamic_cast< ::saml2::assertion::NameIDType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Issuer",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::ncname > r (
        ::saml2::assertion::AssertionIDRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::ncname > r (
        ::saml2::assertion::AssertionIDRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::ncname > r (
        ::saml2::assertion::AssertionIDRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionIDRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::ncname > r (
        ::saml2::assertion::AssertionIDRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::ncname > r (
        ::saml2::assertion::AssertionIDRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::ncname > r (
        ::saml2::assertion::AssertionIDRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::ncname > r (
          ::saml2::assertion::AssertionIDRef (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionIDRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::ncname >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::ncname > r (
          dynamic_cast< ::xml_schema::ncname* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionIDRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::ncname >
    AssertionIDRef (::xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionIDRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::ncname >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::ncname > r (
          dynamic_cast< ::xml_schema::ncname* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionIDRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AssertionURIRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AssertionURIRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AssertionURIRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AssertionURIRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AssertionURIRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AssertionURIRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AssertionURIRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::assertion::AssertionURIRef (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionURIRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionURIRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AssertionURIRef (::xercesc::DOMDocument* d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AssertionURIRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AssertionURIRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
        ::saml2::assertion::Assertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
        ::saml2::assertion::Assertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
        ::saml2::assertion::Assertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Assertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
        ::saml2::assertion::Assertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMInputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
        ::saml2::assertion::Assertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
        ::saml2::assertion::Assertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
          ::saml2::assertion::Assertion (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Assertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AssertionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
          dynamic_cast< ::saml2::assertion::AssertionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Assertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AssertionType >
    Assertion (::xercesc::DOMDocument* d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Assertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AssertionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AssertionType > r (
          dynamic_cast< ::saml2::assertion::AssertionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Assertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
        ::saml2::assertion::Subject (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
        ::saml2::assertion::Subject (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
        ::saml2::assertion::Subject (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Subject (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMInputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
        ::saml2::assertion::Subject (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMInputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
        ::saml2::assertion::Subject (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMInputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
        ::saml2::assertion::Subject (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
          ::saml2::assertion::Subject (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Subject",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
          dynamic_cast< ::saml2::assertion::SubjectType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Subject",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectType >
    Subject (::xercesc::DOMDocument* d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Subject",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::SubjectType > r (
          dynamic_cast< ::saml2::assertion::SubjectType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Subject",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::std::wstring& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
        ::saml2::assertion::SubjectConfirmation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::std::wstring& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
        ::saml2::assertion::SubjectConfirmation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::std::wstring& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
        ::saml2::assertion::SubjectConfirmation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmation (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
        ::saml2::assertion::SubjectConfirmation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
        ::saml2::assertion::SubjectConfirmation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
        ::saml2::assertion::SubjectConfirmation (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
          ::saml2::assertion::SubjectConfirmation (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectConfirmation",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectConfirmationType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
          dynamic_cast< ::saml2::assertion::SubjectConfirmationType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectConfirmation",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType >
    SubjectConfirmation (::xercesc::DOMDocument* d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectConfirmation",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectConfirmationType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationType > r (
          dynamic_cast< ::saml2::assertion::SubjectConfirmationType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectConfirmation",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::std::wstring& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
        ::saml2::assertion::SubjectConfirmationData (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::std::wstring& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
        ::saml2::assertion::SubjectConfirmationData (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::std::wstring& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
        ::saml2::assertion::SubjectConfirmationData (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectConfirmationData (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
        ::saml2::assertion::SubjectConfirmationData (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
        ::saml2::assertion::SubjectConfirmationData (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMInputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
        ::saml2::assertion::SubjectConfirmationData (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
          ::saml2::assertion::SubjectConfirmationData (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectConfirmationData",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectConfirmationDataType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
          dynamic_cast< ::saml2::assertion::SubjectConfirmationDataType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectConfirmationData",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType >
    SubjectConfirmationData (::xercesc::DOMDocument* d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectConfirmationData",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectConfirmationDataType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::SubjectConfirmationDataType > r (
          dynamic_cast< ::saml2::assertion::SubjectConfirmationDataType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectConfirmationData",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::std::wstring& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
        ::saml2::assertion::Conditions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::std::wstring& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
        ::saml2::assertion::Conditions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::std::wstring& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
        ::saml2::assertion::Conditions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::std::istream& is,
                const ::std::wstring& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Conditions (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
        ::saml2::assertion::Conditions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMInputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
        ::saml2::assertion::Conditions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
        ::saml2::assertion::Conditions (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
          ::saml2::assertion::Conditions (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Conditions",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ConditionsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
          dynamic_cast< ::saml2::assertion::ConditionsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Conditions",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionsType >
    Conditions (::xercesc::DOMDocument* d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Conditions",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ConditionsType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::ConditionsType > r (
          dynamic_cast< ::saml2::assertion::ConditionsType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Conditions",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
        ::saml2::assertion::Condition (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
        ::saml2::assertion::Condition (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
        ::saml2::assertion::Condition (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Condition (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
        ::saml2::assertion::Condition (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMInputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
        ::saml2::assertion::Condition (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
        ::saml2::assertion::Condition (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
          ::saml2::assertion::Condition (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Condition",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ConditionAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
          dynamic_cast< ::saml2::assertion::ConditionAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Condition",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType >
    Condition (::xercesc::DOMDocument* d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Condition",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ConditionAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::ConditionAbstractType > r (
          dynamic_cast< ::saml2::assertion::ConditionAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Condition",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::std::wstring& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
        ::saml2::assertion::AudienceRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::std::wstring& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
        ::saml2::assertion::AudienceRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::std::wstring& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
        ::saml2::assertion::AudienceRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AudienceRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
        ::saml2::assertion::AudienceRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
        ::saml2::assertion::AudienceRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
        ::saml2::assertion::AudienceRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
          ::saml2::assertion::AudienceRestriction (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AudienceRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AudienceRestrictionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
          dynamic_cast< ::saml2::assertion::AudienceRestrictionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AudienceRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType >
    AudienceRestriction (::xercesc::DOMDocument* d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AudienceRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AudienceRestrictionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AudienceRestrictionType > r (
          dynamic_cast< ::saml2::assertion::AudienceRestrictionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AudienceRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::std::wstring& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::Audience (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::std::wstring& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::Audience (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::std::wstring& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::Audience (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::std::istream& is,
              const ::std::wstring& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Audience (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::Audience (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMInputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::Audience (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::Audience (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::assertion::Audience (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Audience",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Audience",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    Audience (::xercesc::DOMDocument* d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Audience",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Audience",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::std::wstring& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
        ::saml2::assertion::OneTimeUse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::std::wstring& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
        ::saml2::assertion::OneTimeUse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::std::wstring& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
        ::saml2::assertion::OneTimeUse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::std::istream& is,
                const ::std::wstring& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::OneTimeUse (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMInputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
        ::saml2::assertion::OneTimeUse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMInputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
        ::saml2::assertion::OneTimeUse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMInputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
        ::saml2::assertion::OneTimeUse (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
          ::saml2::assertion::OneTimeUse (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OneTimeUse",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::OneTimeUseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
          dynamic_cast< ::saml2::assertion::OneTimeUseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OneTimeUse",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::OneTimeUseType >
    OneTimeUse (::xercesc::DOMDocument* d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"OneTimeUse",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::OneTimeUseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::OneTimeUseType > r (
          dynamic_cast< ::saml2::assertion::OneTimeUseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"OneTimeUse",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
        ::saml2::assertion::ProxyRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
        ::saml2::assertion::ProxyRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
        ::saml2::assertion::ProxyRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::ProxyRestriction (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
        ::saml2::assertion::ProxyRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
        ::saml2::assertion::ProxyRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
        ::saml2::assertion::ProxyRestriction (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
          ::saml2::assertion::ProxyRestriction (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ProxyRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ProxyRestrictionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
          dynamic_cast< ::saml2::assertion::ProxyRestrictionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ProxyRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType >
    ProxyRestriction (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"ProxyRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ProxyRestrictionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::ProxyRestrictionType > r (
          dynamic_cast< ::saml2::assertion::ProxyRestrictionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ProxyRestriction",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
        ::saml2::assertion::Advice (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
        ::saml2::assertion::Advice (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
        ::saml2::assertion::Advice (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Advice (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
        ::saml2::assertion::Advice (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMInputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
        ::saml2::assertion::Advice (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
        ::saml2::assertion::Advice (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
          ::saml2::assertion::Advice (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Advice",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AdviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
          dynamic_cast< ::saml2::assertion::AdviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Advice",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AdviceType >
    Advice (::xercesc::DOMDocument* d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Advice",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AdviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AdviceType > r (
          dynamic_cast< ::saml2::assertion::AdviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Advice",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAssertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAssertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAssertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAssertion (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAssertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAssertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAssertion (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          ::saml2::assertion::EncryptedAssertion (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptedAssertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedAssertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAssertion (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptedAssertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedAssertion",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
        ::saml2::assertion::Statement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
        ::saml2::assertion::Statement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
        ::saml2::assertion::Statement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Statement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
        ::saml2::assertion::Statement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMInputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
        ::saml2::assertion::Statement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
        ::saml2::assertion::Statement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
          ::saml2::assertion::Statement (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Statement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::StatementAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
          dynamic_cast< ::saml2::assertion::StatementAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Statement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::StatementAbstractType >
    Statement (::xercesc::DOMDocument* d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Statement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::StatementAbstractType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::StatementAbstractType > r (
          dynamic_cast< ::saml2::assertion::StatementAbstractType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Statement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
        ::saml2::assertion::AuthnStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
        ::saml2::assertion::AuthnStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
        ::saml2::assertion::AuthnStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
        ::saml2::assertion::AuthnStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
        ::saml2::assertion::AuthnStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
        ::saml2::assertion::AuthnStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
          ::saml2::assertion::AuthnStatement (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AuthnStatementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
          dynamic_cast< ::saml2::assertion::AuthnStatementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnStatementType >
    AuthnStatement (::xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AuthnStatementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AuthnStatementType > r (
          dynamic_cast< ::saml2::assertion::AuthnStatementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
        ::saml2::assertion::SubjectLocality (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
        ::saml2::assertion::SubjectLocality (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
        ::saml2::assertion::SubjectLocality (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::SubjectLocality (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
        ::saml2::assertion::SubjectLocality (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMInputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
        ::saml2::assertion::SubjectLocality (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMInputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
        ::saml2::assertion::SubjectLocality (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
          ::saml2::assertion::SubjectLocality (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectLocality",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectLocalityType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
          dynamic_cast< ::saml2::assertion::SubjectLocalityType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectLocality",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType >
    SubjectLocality (::xercesc::DOMDocument* d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"SubjectLocality",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::SubjectLocalityType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::SubjectLocalityType > r (
          dynamic_cast< ::saml2::assertion::SubjectLocalityType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"SubjectLocality",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
        ::saml2::assertion::AuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
        ::saml2::assertion::AuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
        ::saml2::assertion::AuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContext (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
        ::saml2::assertion::AuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
        ::saml2::assertion::AuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
        ::saml2::assertion::AuthnContext (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
          ::saml2::assertion::AuthnContext (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AuthnContextType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
          dynamic_cast< ::saml2::assertion::AuthnContextType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContext",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthnContextType >
    AuthnContext (::xercesc::DOMDocument* d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AuthnContextType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AuthnContextType > r (
          dynamic_cast< ::saml2::assertion::AuthnContextType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContext",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::std::wstring& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextClassRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::std::wstring& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextClassRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::std::wstring& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextClassRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextClassRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextClassRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMInputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextClassRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMInputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextClassRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::assertion::AuthnContextClassRef (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContextClassRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContextClassRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextClassRef (::xercesc::DOMDocument* d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContextClassRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContextClassRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::std::wstring& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextDeclRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::std::wstring& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextDeclRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::std::wstring& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextDeclRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::std::istream& is,
                         const ::std::wstring& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDeclRef (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextDeclRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMInputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextDeclRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMInputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthnContextDeclRef (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::assertion::AuthnContextDeclRef (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContextDeclRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContextDeclRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthnContextDeclRef (::xercesc::DOMDocument* d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContextDeclRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContextDeclRef",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::std::wstring& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AuthnContextDecl (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::std::wstring& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AuthnContextDecl (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::std::wstring& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AuthnContextDecl (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::std::istream& is,
                      const ::std::wstring& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthnContextDecl (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AuthnContextDecl (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMInputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AuthnContextDecl (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMInputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AuthnContextDecl (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::type > r (
          ::saml2::assertion::AuthnContextDecl (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContextDecl",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::type >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::type > r (
          dynamic_cast< ::xml_schema::type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContextDecl",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::type >
    AuthnContextDecl (::xercesc::DOMDocument* d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthnContextDecl",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::type >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::type > r (
          dynamic_cast< ::xml_schema::type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthnContextDecl",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::std::wstring& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthenticatingAuthority (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::std::wstring& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthenticatingAuthority (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::std::wstring& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthenticatingAuthority (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::std::istream& is,
                             const ::std::wstring& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthenticatingAuthority (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthenticatingAuthority (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMInputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthenticatingAuthority (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMInputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::uri > r (
        ::saml2::assertion::AuthenticatingAuthority (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::uri > r (
          ::saml2::assertion::AuthenticatingAuthority (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthenticatingAuthority",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthenticatingAuthority",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::uri >
    AuthenticatingAuthority (::xercesc::DOMDocument* d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthenticatingAuthority",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::uri >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::uri > r (
          dynamic_cast< ::xml_schema::uri* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthenticatingAuthority",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::std::wstring& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
        ::saml2::assertion::AuthzDecisionStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::std::wstring& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
        ::saml2::assertion::AuthzDecisionStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::std::wstring& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
        ::saml2::assertion::AuthzDecisionStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            const ::std::wstring& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            const ::std::wstring& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::std::istream& is,
                            const ::std::wstring& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AuthzDecisionStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMInputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
        ::saml2::assertion::AuthzDecisionStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMInputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
        ::saml2::assertion::AuthzDecisionStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMInputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
        ::saml2::assertion::AuthzDecisionStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
          ::saml2::assertion::AuthzDecisionStatement (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthzDecisionStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AuthzDecisionStatementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
          dynamic_cast< ::saml2::assertion::AuthzDecisionStatementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthzDecisionStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType >
    AuthzDecisionStatement (::xercesc::DOMDocument* d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AuthzDecisionStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AuthzDecisionStatementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AuthzDecisionStatementType > r (
          dynamic_cast< ::saml2::assertion::AuthzDecisionStatementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AuthzDecisionStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ActionType > r (
        ::saml2::assertion::Action (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ActionType > r (
        ::saml2::assertion::Action (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ActionType > r (
        ::saml2::assertion::Action (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Action (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::ActionType > r (
        ::saml2::assertion::Action (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMInputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ActionType > r (
        ::saml2::assertion::Action (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::ActionType > r (
        ::saml2::assertion::Action (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::ActionType > r (
          ::saml2::assertion::Action (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Action",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ActionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::ActionType > r (
          dynamic_cast< ::saml2::assertion::ActionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Action",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::ActionType >
    Action (::xercesc::DOMDocument* d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Action",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::ActionType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::ActionType > r (
          dynamic_cast< ::saml2::assertion::ActionType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Action",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::std::wstring& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
        ::saml2::assertion::Evidence (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::std::wstring& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
        ::saml2::assertion::Evidence (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::std::wstring& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
        ::saml2::assertion::Evidence (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::std::istream& is,
              const ::std::wstring& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Evidence (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
        ::saml2::assertion::Evidence (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMInputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
        ::saml2::assertion::Evidence (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
        ::saml2::assertion::Evidence (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
          ::saml2::assertion::Evidence (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Evidence",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EvidenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
          dynamic_cast< ::saml2::assertion::EvidenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Evidence",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EvidenceType >
    Evidence (::xercesc::DOMDocument* d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Evidence",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EvidenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::EvidenceType > r (
          dynamic_cast< ::saml2::assertion::EvidenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Evidence",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
        ::saml2::assertion::AttributeStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
        ::saml2::assertion::AttributeStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
        ::saml2::assertion::AttributeStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeStatement (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
        ::saml2::assertion::AttributeStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
        ::saml2::assertion::AttributeStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
        ::saml2::assertion::AttributeStatement (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
          ::saml2::assertion::AttributeStatement (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AttributeStatementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
          dynamic_cast< ::saml2::assertion::AttributeStatementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeStatementType >
    AttributeStatement (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AttributeStatementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AttributeStatementType > r (
          dynamic_cast< ::saml2::assertion::AttributeStatementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeStatement",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
        ::saml2::assertion::Attribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
        ::saml2::assertion::Attribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
        ::saml2::assertion::Attribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::Attribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMInputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
        ::saml2::assertion::Attribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMInputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
        ::saml2::assertion::Attribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMInputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
        ::saml2::assertion::Attribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
          ::saml2::assertion::Attribute (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Attribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AttributeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
          dynamic_cast< ::saml2::assertion::AttributeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Attribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::AttributeType >
    Attribute (::xercesc::DOMDocument* d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"Attribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::AttributeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::AttributeType > r (
          dynamic_cast< ::saml2::assertion::AttributeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Attribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AttributeValue (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AttributeValue (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AttributeValue (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::AttributeValue (wrap, h, f, p);
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AttributeValue (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMInputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AttributeValue (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMInputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::xml_schema::type > r (
        ::saml2::assertion::AttributeValue (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xml_schema::type > r (
          ::saml2::assertion::AttributeValue (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeValue",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::type >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xml_schema::type > r (
          dynamic_cast< ::xml_schema::type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeValue",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::xml_schema::type >
    AttributeValue (::xercesc::DOMDocument* d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"AttributeValue",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::xml_schema::type >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::xml_schema::type > r (
          dynamic_cast< ::xml_schema::type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AttributeValue",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      ::xercesc::Wrapper4InputSource wrap (&isrc, false);
      return ::saml2::assertion::EncryptedAttribute (wrap, h, f, p);
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMInputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d)
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
        ::saml2::assertion::EncryptedAttribute (
          d.get (), f | ::xml_schema::flags::own_dom, p));

      if (f & ::xml_schema::flags::keep_dom)
        d.release ();

      return r;
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          ::saml2::assertion::EncryptedAttribute (
            c.get (), f | ::xml_schema::flags::own_dom, p));

        c.release ();
        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptedAttribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedAttribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }

    ::std::auto_ptr< ::saml2::assertion::EncryptedElementType >
    EncryptedAttribute (::xercesc::DOMDocument* d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      const ::xercesc::DOMElement& e (
        c.get ()
        ? *c->getDocumentElement ()
        : *d->getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xml_schema::type > tmp (
        tfm.create (
          L"EncryptedAttribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          &::xsd::cxx::tree::factory_impl< ::saml2::assertion::EncryptedElementType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        c.release ();

        ::std::auto_ptr< ::saml2::assertion::EncryptedElementType > r (
          dynamic_cast< ::saml2::assertion::EncryptedElementType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedAttribute",
        L"urn:oasis:names:tc:SAML:2.0:assertion");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace saml2
{
  namespace assertion
  {
    void
    BaseID (::std::ostream& o,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    BaseID (::std::ostream& o,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    BaseID (::std::ostream& o,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    BaseID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    BaseID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    BaseID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::BaseID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    BaseID (::xercesc::DOMDocument& d,
            const ::saml2::assertion::BaseIDAbstractType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::BaseIDAbstractType) == typeid (s))
      {
        if (n.name () == L"BaseID" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"BaseID",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"BaseID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    BaseID (const ::saml2::assertion::BaseIDAbstractType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::BaseIDAbstractType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"BaseID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"BaseID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::BaseID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BaseIDAbstractType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NameQualifier
      //
      if (i.NameQualifier ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NameQualifier",
            e));

        a << *i.NameQualifier ();
      }

      // SPNameQualifier
      //
      if (i.SPNameQualifier ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"SPNameQualifier",
            e));

        a << *i.SPNameQualifier ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, BaseIDAbstractType >
    _xsd_BaseIDAbstractType_type_serializer_init (
      L"BaseIDAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    NameID (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameID (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameID (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NameID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameID (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::NameID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NameID (::xercesc::DOMDocument& d,
            const ::saml2::assertion::NameIDType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::NameIDType) == typeid (s))
      {
        if (n.name () == L"NameID" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NameID",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NameID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    NameID (const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::NameIDType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NameID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"NameID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::NameID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NameIDType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      // NameQualifier
      //
      if (i.NameQualifier ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NameQualifier",
            e));

        a << *i.NameQualifier ();
      }

      // SPNameQualifier
      //
      if (i.SPNameQualifier ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"SPNameQualifier",
            e));

        a << *i.SPNameQualifier ();
      }

      // Format
      //
      if (i.Format ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Format",
            e));

        a << *i.Format ();
      }

      // SPProvidedID
      //
      if (i.SPProvidedID ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"SPProvidedID",
            e));

        a << *i.SPProvidedID ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NameIDType >
    _xsd_NameIDType_type_serializer_init (
      L"NameIDType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    operator<< (::xercesc::DOMElement& e, const EncryptedElementType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EncryptedData
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const EncryptedElementType::EncryptedData_type& x (i.EncryptedData ());
        if (typeid (EncryptedElementType::EncryptedData_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"EncryptedData",
              L"http://www.w3.org/2001/04/xmlenc#",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"EncryptedData",
            L"http://www.w3.org/2001/04/xmlenc#",
            true, true, e, x);
      }

      // EncryptedKey
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EncryptedElementType::EncryptedKey_const_iterator
             b (i.EncryptedKey ().begin ()), n (i.EncryptedKey ().end ());
             b != n; ++b)
        {
          if (typeid (EncryptedElementType::EncryptedKey_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedKey",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EncryptedKey",
              L"http://www.w3.org/2001/04/xmlenc#",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptedElementType >
    _xsd_EncryptedElementType_type_serializer_init (
      L"EncryptedElementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    EncryptedID (::std::ostream& o,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedID (::std::ostream& o,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedID (::std::ostream& o,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedID (::xercesc::XMLFormatTarget& t,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedID (::xercesc::XMLFormatTarget& t,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedID (::xercesc::XMLFormatTarget& t,
                 const ::saml2::assertion::EncryptedElementType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedID (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedID (::xercesc::DOMDocument& d,
                 const ::saml2::assertion::EncryptedElementType& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
      {
        if (n.name () == L"EncryptedID" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptedID",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedID (const ::saml2::assertion::EncryptedElementType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"EncryptedID",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::EncryptedID (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Issuer (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Issuer (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::std::ostream& o,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Issuer (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Issuer (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Issuer (::xercesc::DOMDocument& d,
            const ::saml2::assertion::NameIDType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::NameIDType) == typeid (s))
      {
        if (n.name () == L"Issuer" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Issuer",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Issuer",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Issuer (const ::saml2::assertion::NameIDType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::NameIDType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Issuer",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Issuer",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Issuer (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::std::ostream& o,
                    const ::xml_schema::ncname& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRef (::std::ostream& o,
                    const ::xml_schema::ncname& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::std::ostream& o,
                    const ::xml_schema::ncname& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::ncname& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionIDRef (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::ncname& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::ncname& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionIDRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionIDRef (::xercesc::DOMDocument& d,
                    const ::xml_schema::ncname& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::ncname) == typeid (s))
      {
        if (n.name () == L"AssertionIDRef" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AssertionIDRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AssertionIDRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AssertionIDRef (const ::xml_schema::ncname& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::ncname) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AssertionIDRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AssertionIDRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AssertionIDRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::std::ostream& o,
                     const ::xml_schema::uri& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionURIRef (::std::ostream& o,
                     const ::xml_schema::uri& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::std::ostream& o,
                     const ::xml_schema::uri& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::uri& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AssertionURIRef (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::uri& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::xercesc::XMLFormatTarget& t,
                     const ::xml_schema::uri& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AssertionURIRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AssertionURIRef (::xercesc::DOMDocument& d,
                     const ::xml_schema::uri& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"AssertionURIRef" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AssertionURIRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AssertionURIRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AssertionURIRef (const ::xml_schema::uri& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AssertionURIRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AssertionURIRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AssertionURIRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Assertion (::std::ostream& o,
               const ::saml2::assertion::AssertionType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Assertion (::std::ostream& o,
               const ::saml2::assertion::AssertionType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::std::ostream& o,
               const ::saml2::assertion::AssertionType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AssertionType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Assertion (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AssertionType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AssertionType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Assertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Assertion (::xercesc::DOMDocument& d,
               const ::saml2::assertion::AssertionType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AssertionType) == typeid (s))
      {
        if (n.name () == L"Assertion" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Assertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Assertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Assertion (const ::saml2::assertion::AssertionType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AssertionType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Assertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Assertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Assertion (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AssertionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Issuer
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const AssertionType::Issuer_type& x (i.Issuer ());
        if (typeid (AssertionType::Issuer_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Issuer",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Issuer",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true, true, e, x);
      }

      // Signature
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Signature ())
        {
          const AssertionType::Signature_type& x (*i.Signature ());
          if (typeid (AssertionType::Signature_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Signature",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Signature",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // Subject
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Subject ())
        {
          const AssertionType::Subject_type& x (*i.Subject ());
          if (typeid (AssertionType::Subject_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Subject",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Subject",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Conditions
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Conditions ())
        {
          const AssertionType::Conditions_type& x (*i.Conditions ());
          if (typeid (AssertionType::Conditions_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Conditions",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Conditions",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Advice
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Advice ())
        {
          const AssertionType::Advice_type& x (*i.Advice ());
          if (typeid (AssertionType::Advice_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Advice",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Advice",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Statement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::Statement_const_iterator
             b (i.Statement ().begin ()), n (i.Statement ().end ());
             b != n; ++b)
        {
          if (typeid (AssertionType::Statement_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Statement",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Statement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // AuthnStatement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::AuthnStatement_const_iterator
             b (i.AuthnStatement ().begin ()), n (i.AuthnStatement ().end ());
             b != n; ++b)
        {
          if (typeid (AssertionType::AuthnStatement_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnStatement",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthnStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // AuthzDecisionStatement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::AuthzDecisionStatement_const_iterator
             b (i.AuthzDecisionStatement ().begin ()), n (i.AuthzDecisionStatement ().end ());
             b != n; ++b)
        {
          if (typeid (AssertionType::AuthzDecisionStatement_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthzDecisionStatement",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthzDecisionStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // AttributeStatement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AssertionType::AttributeStatement_const_iterator
             b (i.AttributeStatement ().begin ()), n (i.AttributeStatement ().end ());
             b != n; ++b)
        {
          if (typeid (AssertionType::AttributeStatement_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AttributeStatement",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AttributeStatement",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Version
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Version",
            e));

        a << i.Version ();
      }

      // ID
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"ID",
            e));

        a << i.ID ();
      }

      // IssueInstant
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"IssueInstant",
            e));

        a << i.IssueInstant ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AssertionType >
    _xsd_AssertionType_type_serializer_init (
      L"AssertionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Subject (::std::ostream& o,
             const ::saml2::assertion::SubjectType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Subject (::std::ostream& o,
             const ::saml2::assertion::SubjectType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Subject (::std::ostream& o,
             const ::saml2::assertion::SubjectType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Subject (::xercesc::XMLFormatTarget& t,
             const ::saml2::assertion::SubjectType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Subject (::xercesc::XMLFormatTarget& t,
             const ::saml2::assertion::SubjectType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::error_handler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Subject (::xercesc::XMLFormatTarget& t,
             const ::saml2::assertion::SubjectType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xercesc::DOMErrorHandler& h,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Subject (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Subject (::xercesc::DOMDocument& d,
             const ::saml2::assertion::SubjectType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::SubjectType) == typeid (s))
      {
        if (n.name () == L"Subject" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Subject",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Subject",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Subject (const ::saml2::assertion::SubjectType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::SubjectType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Subject",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Subject",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Subject (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SubjectType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BaseID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BaseID ())
        {
          const SubjectType::BaseID_type& x (*i.BaseID ());
          if (typeid (SubjectType::BaseID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BaseID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // NameID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          const SubjectType::NameID_type& x (*i.NameID ());
          if (typeid (SubjectType::NameID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // EncryptedID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          const SubjectType::EncryptedID_type& x (*i.EncryptedID ());
          if (typeid (SubjectType::EncryptedID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // SubjectConfirmation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (SubjectType::SubjectConfirmation_const_iterator
             b (i.SubjectConfirmation ().begin ()), n (i.SubjectConfirmation ().end ());
             b != n; ++b)
        {
          if (typeid (SubjectType::SubjectConfirmation_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SubjectConfirmation",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"SubjectConfirmation",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectType >
    _xsd_SubjectType_type_serializer_init (
      L"SubjectType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    SubjectConfirmation (::std::ostream& o,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmation (::std::ostream& o,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::std::ostream& o,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmation (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmation (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmation (::xercesc::DOMDocument& d,
                         const ::saml2::assertion::SubjectConfirmationType& s,
                         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::SubjectConfirmationType) == typeid (s))
      {
        if (n.name () == L"SubjectConfirmation" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SubjectConfirmation",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SubjectConfirmation",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SubjectConfirmation (const ::saml2::assertion::SubjectConfirmationType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::SubjectConfirmationType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SubjectConfirmation",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SubjectConfirmation",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::SubjectConfirmation (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SubjectConfirmationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BaseID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.BaseID ())
        {
          const SubjectConfirmationType::BaseID_type& x (*i.BaseID ());
          if (typeid (SubjectConfirmationType::BaseID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"BaseID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"BaseID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // NameID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.NameID ())
        {
          const SubjectConfirmationType::NameID_type& x (*i.NameID ());
          if (typeid (SubjectConfirmationType::NameID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"NameID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"NameID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // EncryptedID
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptedID ())
        {
          const SubjectConfirmationType::EncryptedID_type& x (*i.EncryptedID ());
          if (typeid (SubjectConfirmationType::EncryptedID_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedID",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptedID",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // SubjectConfirmationData
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.SubjectConfirmationData ())
        {
          const SubjectConfirmationType::SubjectConfirmationData_type& x (*i.SubjectConfirmationData ());
          if (typeid (SubjectConfirmationType::SubjectConfirmationData_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SubjectConfirmationData",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"SubjectConfirmationData",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Method
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Method",
            e));

        a << i.Method ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectConfirmationType >
    _xsd_SubjectConfirmationType_type_serializer_init (
      L"SubjectConfirmationType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    SubjectConfirmationData (::std::ostream& o,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmationData (::std::ostream& o,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::error_handler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::std::ostream& o,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::xercesc::XMLFormatTarget& t,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectConfirmationData (::xercesc::XMLFormatTarget& t,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::error_handler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::xercesc::XMLFormatTarget& t,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectConfirmationData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectConfirmationData (::xercesc::DOMDocument& d,
                             const ::saml2::assertion::SubjectConfirmationDataType& s,
                             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::SubjectConfirmationDataType) == typeid (s))
      {
        if (n.name () == L"SubjectConfirmationData" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SubjectConfirmationData",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SubjectConfirmationData",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SubjectConfirmationData (const ::saml2::assertion::SubjectConfirmationDataType& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::SubjectConfirmationDataType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SubjectConfirmationData",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SubjectConfirmationData",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::SubjectConfirmationData (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SubjectConfirmationDataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (SubjectConfirmationDataType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (SubjectConfirmationDataType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // NotBefore
      //
      if (i.NotBefore ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NotBefore",
            e));

        a << *i.NotBefore ();
      }

      // NotOnOrAfter
      //
      if (i.NotOnOrAfter ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NotOnOrAfter",
            e));

        a << *i.NotOnOrAfter ();
      }

      // Recipient
      //
      if (i.Recipient ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Recipient",
            e));

        a << *i.Recipient ();
      }

      // InResponseTo
      //
      if (i.InResponseTo ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"InResponseTo",
            e));

        a << *i.InResponseTo ();
      }

      // Address
      //
      if (i.Address ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Address",
            e));

        a << *i.Address ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectConfirmationDataType >
    _xsd_SubjectConfirmationDataType_type_serializer_init (
      L"SubjectConfirmationDataType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    operator<< (::xercesc::DOMElement& e, const KeyInfoConfirmationDataType& i)
    {
      e << static_cast< const ::saml2::assertion::SubjectConfirmationDataType& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, KeyInfoConfirmationDataType >
    _xsd_KeyInfoConfirmationDataType_type_serializer_init (
      L"KeyInfoConfirmationDataType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Conditions (::std::ostream& o,
                const ::saml2::assertion::ConditionsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Conditions (::std::ostream& o,
                const ::saml2::assertion::ConditionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Conditions (::std::ostream& o,
                const ::saml2::assertion::ConditionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Conditions (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::ConditionsType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Conditions (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::ConditionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Conditions (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::ConditionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Conditions (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Conditions (::xercesc::DOMDocument& d,
                const ::saml2::assertion::ConditionsType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::ConditionsType) == typeid (s))
      {
        if (n.name () == L"Conditions" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Conditions",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Conditions",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Conditions (const ::saml2::assertion::ConditionsType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::ConditionsType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Conditions",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Conditions",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Conditions (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConditionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Condition
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::Condition_const_iterator
             b (i.Condition ().begin ()), n (i.Condition ().end ());
             b != n; ++b)
        {
          if (typeid (ConditionsType::Condition_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Condition",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Condition",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // AudienceRestriction
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::AudienceRestriction_const_iterator
             b (i.AudienceRestriction ().begin ()), n (i.AudienceRestriction ().end ());
             b != n; ++b)
        {
          if (typeid (ConditionsType::AudienceRestriction_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AudienceRestriction",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AudienceRestriction",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // OneTimeUse
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::OneTimeUse_const_iterator
             b (i.OneTimeUse ().begin ()), n (i.OneTimeUse ().end ());
             b != n; ++b)
        {
          if (typeid (ConditionsType::OneTimeUse_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"OneTimeUse",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"OneTimeUse",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // ProxyRestriction
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ConditionsType::ProxyRestriction_const_iterator
             b (i.ProxyRestriction ().begin ()), n (i.ProxyRestriction ().end ());
             b != n; ++b)
        {
          if (typeid (ConditionsType::ProxyRestriction_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"ProxyRestriction",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"ProxyRestriction",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // NotBefore
      //
      if (i.NotBefore ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NotBefore",
            e));

        a << *i.NotBefore ();
      }

      // NotOnOrAfter
      //
      if (i.NotOnOrAfter ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NotOnOrAfter",
            e));

        a << *i.NotOnOrAfter ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConditionsType >
    _xsd_ConditionsType_type_serializer_init (
      L"ConditionsType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Condition (::std::ostream& o,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Condition (::std::ostream& o,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Condition (::std::ostream& o,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Condition (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Condition (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Condition (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::ConditionAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Condition (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Condition (::xercesc::DOMDocument& d,
               const ::saml2::assertion::ConditionAbstractType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::ConditionAbstractType) == typeid (s))
      {
        if (n.name () == L"Condition" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Condition",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Condition",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Condition (const ::saml2::assertion::ConditionAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::ConditionAbstractType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Condition",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Condition",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Condition (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConditionAbstractType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&,const ConditionAbstractType&)
    {
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >&,
                const ConditionAbstractType&)
    {
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ConditionAbstractType >
    _xsd_ConditionAbstractType_type_serializer_init (
      L"ConditionAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AudienceRestriction (::std::ostream& o,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AudienceRestriction (::std::ostream& o,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::std::ostream& o,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AudienceRestriction (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::xercesc::XMLFormatTarget& t,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AudienceRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AudienceRestriction (::xercesc::DOMDocument& d,
                         const ::saml2::assertion::AudienceRestrictionType& s,
                         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AudienceRestrictionType) == typeid (s))
      {
        if (n.name () == L"AudienceRestriction" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AudienceRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AudienceRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AudienceRestriction (const ::saml2::assertion::AudienceRestrictionType& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AudienceRestrictionType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AudienceRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AudienceRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AudienceRestriction (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AudienceRestrictionType& i)
    {
      e << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);

      // Audience
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AudienceRestrictionType::Audience_const_iterator
             b (i.Audience ().begin ()), n (i.Audience ().end ());
             b != n; ++b)
        {
          if (typeid (AudienceRestrictionType::Audience_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Audience",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Audience",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AudienceRestrictionType >
    _xsd_AudienceRestrictionType_type_serializer_init (
      L"AudienceRestrictionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Audience (::std::ostream& o,
              const ::xml_schema::uri& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Audience (::std::ostream& o,
              const ::xml_schema::uri& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Audience (::std::ostream& o,
              const ::xml_schema::uri& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Audience (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::uri& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Audience (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::uri& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Audience (::xercesc::XMLFormatTarget& t,
              const ::xml_schema::uri& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Audience (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Audience (::xercesc::DOMDocument& d,
              const ::xml_schema::uri& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"Audience" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Audience",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Audience",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Audience (const ::xml_schema::uri& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Audience",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Audience",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Audience (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    OneTimeUse (::std::ostream& o,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OneTimeUse (::std::ostream& o,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::std::ostream& o,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    OneTimeUse (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::xercesc::XMLFormatTarget& t,
                const ::saml2::assertion::OneTimeUseType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::OneTimeUse (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    OneTimeUse (::xercesc::DOMDocument& d,
                const ::saml2::assertion::OneTimeUseType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::OneTimeUseType) == typeid (s))
      {
        if (n.name () == L"OneTimeUse" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"OneTimeUse",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"OneTimeUse",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    OneTimeUse (const ::saml2::assertion::OneTimeUseType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::OneTimeUseType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"OneTimeUse",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"OneTimeUse",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::OneTimeUse (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OneTimeUseType& i)
    {
      e << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,const OneTimeUseType& i)
    {
      a << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const OneTimeUseType& i)
    {
      l << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, OneTimeUseType >
    _xsd_OneTimeUseType_type_serializer_init (
      L"OneTimeUseType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    ProxyRestriction (::std::ostream& o,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ProxyRestriction (::std::ostream& o,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::std::ostream& o,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::xercesc::XMLFormatTarget& t,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ProxyRestriction (::xercesc::XMLFormatTarget& t,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::xercesc::XMLFormatTarget& t,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::ProxyRestriction (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ProxyRestriction (::xercesc::DOMDocument& d,
                      const ::saml2::assertion::ProxyRestrictionType& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::ProxyRestrictionType) == typeid (s))
      {
        if (n.name () == L"ProxyRestriction" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"ProxyRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"ProxyRestriction",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    ProxyRestriction (const ::saml2::assertion::ProxyRestrictionType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::ProxyRestrictionType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"ProxyRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"ProxyRestriction",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::ProxyRestriction (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProxyRestrictionType& i)
    {
      e << static_cast< const ::saml2::assertion::ConditionAbstractType& > (i);

      // Audience
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ProxyRestrictionType::Audience_const_iterator
             b (i.Audience ().begin ()), n (i.Audience ().end ());
             b != n; ++b)
        {
          if (typeid (ProxyRestrictionType::Audience_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Audience",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Audience",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Count
      //
      if (i.Count ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Count",
            e));

        a << *i.Count ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ProxyRestrictionType >
    _xsd_ProxyRestrictionType_type_serializer_init (
      L"ProxyRestrictionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Advice (::std::ostream& o,
            const ::saml2::assertion::AdviceType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Advice (::std::ostream& o,
            const ::saml2::assertion::AdviceType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Advice (::std::ostream& o,
            const ::saml2::assertion::AdviceType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Advice (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::AdviceType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Advice (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::AdviceType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Advice (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::AdviceType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Advice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Advice (::xercesc::DOMDocument& d,
            const ::saml2::assertion::AdviceType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AdviceType) == typeid (s))
      {
        if (n.name () == L"Advice" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Advice",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Advice",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Advice (const ::saml2::assertion::AdviceType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AdviceType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Advice",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Advice",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Advice (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AdviceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AssertionIDRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::AssertionIDRef_const_iterator
             b (i.AssertionIDRef ().begin ()), n (i.AssertionIDRef ().end ());
             b != n; ++b)
        {
          if (typeid (AdviceType::AssertionIDRef_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionIDRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // AssertionURIRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::AssertionURIRef_const_iterator
             b (i.AssertionURIRef ().begin ()), n (i.AssertionURIRef ().end ());
             b != n; ++b)
        {
          if (typeid (AdviceType::AssertionURIRef_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionURIRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionURIRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Assertion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::Assertion_const_iterator
             b (i.Assertion ().begin ()), n (i.Assertion ().end ());
             b != n; ++b)
        {
          if (typeid (AdviceType::Assertion_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Assertion",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // EncryptedAssertion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AdviceType::EncryptedAssertion_const_iterator
             b (i.EncryptedAssertion ().begin ()), n (i.EncryptedAssertion ().end ());
             b != n; ++b)
        {
          if (typeid (AdviceType::EncryptedAssertion_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedAssertion",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // any
      //
      for (AdviceType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AdviceType >
    _xsd_AdviceType_type_serializer_init (
      L"AdviceType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    EncryptedAssertion (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAssertion (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAssertion (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAssertion (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAssertion (::xercesc::DOMDocument& d,
                        const ::saml2::assertion::EncryptedElementType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
      {
        if (n.name () == L"EncryptedAssertion" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptedAssertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptedAssertion",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedAssertion (const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptedAssertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"EncryptedAssertion",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::EncryptedAssertion (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    Statement (::std::ostream& o,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Statement (::std::ostream& o,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::std::ostream& o,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Statement (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::StatementAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Statement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Statement (::xercesc::DOMDocument& d,
               const ::saml2::assertion::StatementAbstractType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::StatementAbstractType) == typeid (s))
      {
        if (n.name () == L"Statement" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Statement",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Statement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Statement (const ::saml2::assertion::StatementAbstractType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::StatementAbstractType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Statement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Statement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Statement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const StatementAbstractType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&,const StatementAbstractType&)
    {
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >&,
                const StatementAbstractType&)
    {
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, StatementAbstractType >
    _xsd_StatementAbstractType_type_serializer_init (
      L"StatementAbstractType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AuthnStatement (::std::ostream& o,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnStatement (::std::ostream& o,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnStatement (::std::ostream& o,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnStatement (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnStatement (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnStatement (::xercesc::XMLFormatTarget& t,
                    const ::saml2::assertion::AuthnStatementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnStatement (::xercesc::DOMDocument& d,
                    const ::saml2::assertion::AuthnStatementType& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AuthnStatementType) == typeid (s))
      {
        if (n.name () == L"AuthnStatement" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnStatement (const ::saml2::assertion::AuthnStatementType& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AuthnStatementType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AuthnStatement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AuthnStatementType& i)
    {
      e << static_cast< const ::saml2::assertion::StatementAbstractType& > (i);

      // SubjectLocality
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.SubjectLocality ())
        {
          const AuthnStatementType::SubjectLocality_type& x (*i.SubjectLocality ());
          if (typeid (AuthnStatementType::SubjectLocality_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SubjectLocality",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"SubjectLocality",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // AuthnContext
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const AuthnStatementType::AuthnContext_type& x (i.AuthnContext ());
        if (typeid (AuthnStatementType::AuthnContext_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"AuthnContext",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"AuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            true, true, e, x);
      }

      // AuthnInstant
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"AuthnInstant",
            e));

        a << i.AuthnInstant ();
      }

      // SessionIndex
      //
      if (i.SessionIndex ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"SessionIndex",
            e));

        a << *i.SessionIndex ();
      }

      // SessionNotOnOrAfter
      //
      if (i.SessionNotOnOrAfter ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"SessionNotOnOrAfter",
            e));

        a << *i.SessionNotOnOrAfter ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnStatementType >
    _xsd_AuthnStatementType_type_serializer_init (
      L"AuthnStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    SubjectLocality (::std::ostream& o,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectLocality (::std::ostream& o,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectLocality (::std::ostream& o,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectLocality (::xercesc::XMLFormatTarget& t,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    SubjectLocality (::xercesc::XMLFormatTarget& t,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::error_handler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectLocality (::xercesc::XMLFormatTarget& t,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xercesc::DOMErrorHandler& h,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::SubjectLocality (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    SubjectLocality (::xercesc::DOMDocument& d,
                     const ::saml2::assertion::SubjectLocalityType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::SubjectLocalityType) == typeid (s))
      {
        if (n.name () == L"SubjectLocality" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"SubjectLocality",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"SubjectLocality",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    SubjectLocality (const ::saml2::assertion::SubjectLocalityType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::SubjectLocalityType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"SubjectLocality",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"SubjectLocality",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::SubjectLocality (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SubjectLocalityType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Address
      //
      if (i.Address ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Address",
            e));

        a << *i.Address ();
      }

      // DNSName
      //
      if (i.DNSName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"DNSName",
            e));

        a << *i.DNSName ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SubjectLocalityType >
    _xsd_SubjectLocalityType_type_serializer_init (
      L"SubjectLocalityType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AuthnContext (::std::ostream& o,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContext (::std::ostream& o,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContext (::std::ostream& o,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContext (::xercesc::XMLFormatTarget& t,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContext (::xercesc::XMLFormatTarget& t,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContext (::xercesc::XMLFormatTarget& t,
                  const ::saml2::assertion::AuthnContextType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContext (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContext (::xercesc::DOMDocument& d,
                  const ::saml2::assertion::AuthnContextType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AuthnContextType) == typeid (s))
      {
        if (n.name () == L"AuthnContext" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnContext",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContext (const ::saml2::assertion::AuthnContextType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AuthnContextType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnContext",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AuthnContext (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AuthnContextType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AuthnContextClassRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.AuthnContextClassRef ())
        {
          const AuthnContextType::AuthnContextClassRef_type& x (*i.AuthnContextClassRef ());
          if (typeid (AuthnContextType::AuthnContextClassRef_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnContextClassRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"AuthnContextClassRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // AuthnContextDecl
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.AuthnContextDecl ())
        {
          const AuthnContextType::AuthnContextDecl_type& x (*i.AuthnContextDecl ());
          if (typeid (AuthnContextType::AuthnContextDecl_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnContextDecl",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"AuthnContextDecl",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // AuthnContextDeclRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.AuthnContextDeclRef ())
        {
          const AuthnContextType::AuthnContextDeclRef_type& x (*i.AuthnContextDeclRef ());
          if (typeid (AuthnContextType::AuthnContextDeclRef_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthnContextDeclRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"AuthnContextDeclRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // AuthenticatingAuthority
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthnContextType::AuthenticatingAuthority_const_iterator
             b (i.AuthenticatingAuthority ().begin ()), n (i.AuthenticatingAuthority ().end ());
             b != n; ++b)
        {
          if (typeid (AuthnContextType::AuthenticatingAuthority_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AuthenticatingAuthority",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AuthenticatingAuthority",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthnContextType >
    _xsd_AuthnContextType_type_serializer_init (
      L"AuthnContextType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AuthnContextClassRef (::std::ostream& o,
                          const ::xml_schema::uri& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextClassRef (::std::ostream& o,
                          const ::xml_schema::uri& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::std::ostream& o,
                          const ::xml_schema::uri& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::xercesc::XMLFormatTarget& t,
                          const ::xml_schema::uri& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextClassRef (::xercesc::XMLFormatTarget& t,
                          const ::xml_schema::uri& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::error_handler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::xercesc::XMLFormatTarget& t,
                          const ::xml_schema::uri& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xercesc::DOMErrorHandler& h,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextClassRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextClassRef (::xercesc::DOMDocument& d,
                          const ::xml_schema::uri& s,
                          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"AuthnContextClassRef" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnContextClassRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnContextClassRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContextClassRef (const ::xml_schema::uri& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnContextClassRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnContextClassRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AuthnContextClassRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::std::ostream& o,
                         const ::xml_schema::uri& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDeclRef (::std::ostream& o,
                         const ::xml_schema::uri& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::std::ostream& o,
                         const ::xml_schema::uri& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::XMLFormatTarget& t,
                         const ::xml_schema::uri& s,
                         const ::xml_schema::namespace_infomap& m,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::XMLFormatTarget& t,
                         const ::xml_schema::uri& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::error_handler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::XMLFormatTarget& t,
                         const ::xml_schema::uri& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xercesc::DOMErrorHandler& h,
                         const ::std::wstring& e,
                         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDeclRef (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDeclRef (::xercesc::DOMDocument& d,
                         const ::xml_schema::uri& s,
                         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"AuthnContextDeclRef" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnContextDeclRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnContextDeclRef",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContextDeclRef (const ::xml_schema::uri& s,
                         const ::xml_schema::namespace_infomap& m,
                         ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnContextDeclRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnContextDeclRef",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AuthnContextDeclRef (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::std::ostream& o,
                      const ::xml_schema::type& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDecl (::std::ostream& o,
                      const ::xml_schema::type& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::std::ostream& o,
                      const ::xml_schema::type& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::type& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::type& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::XMLFormatTarget& t,
                      const ::xml_schema::type& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::wstring& e,
                      ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthnContextDecl (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthnContextDecl (::xercesc::DOMDocument& d,
                      const ::xml_schema::type& s,
                      ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::type) == typeid (s))
      {
        if (n.name () == L"AuthnContextDecl" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthnContextDecl",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthnContextDecl",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthnContextDecl (const ::xml_schema::type& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::type) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthnContextDecl",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthnContextDecl",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AuthnContextDecl (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::std::ostream& o,
                             const ::xml_schema::uri& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthenticatingAuthority (::std::ostream& o,
                             const ::xml_schema::uri& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::error_handler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::std::ostream& o,
                             const ::xml_schema::uri& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::XMLFormatTarget& t,
                             const ::xml_schema::uri& s,
                             const ::xml_schema::namespace_infomap& m,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::XMLFormatTarget& t,
                             const ::xml_schema::uri& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::error_handler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::XMLFormatTarget& t,
                             const ::xml_schema::uri& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xercesc::DOMErrorHandler& h,
                             const ::std::wstring& e,
                             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthenticatingAuthority (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthenticatingAuthority (::xercesc::DOMDocument& d,
                             const ::xml_schema::uri& s,
                             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::uri) == typeid (s))
      {
        if (n.name () == L"AuthenticatingAuthority" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthenticatingAuthority",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthenticatingAuthority",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthenticatingAuthority (const ::xml_schema::uri& s,
                             const ::xml_schema::namespace_infomap& m,
                             ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::uri) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthenticatingAuthority",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthenticatingAuthority",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AuthenticatingAuthority (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::std::ostream& o,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::wstring& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzDecisionStatement (::std::ostream& o,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xml_schema::namespace_infomap& m,
                            ::xml_schema::error_handler& h,
                            const ::std::wstring& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::std::ostream& o,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xml_schema::namespace_infomap& m,
                            ::xercesc::DOMErrorHandler& h,
                            const ::std::wstring& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::XMLFormatTarget& t,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xml_schema::namespace_infomap& m,
                            const ::std::wstring& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::XMLFormatTarget& t,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xml_schema::namespace_infomap& m,
                            ::xml_schema::error_handler& h,
                            const ::std::wstring& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::XMLFormatTarget& t,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xml_schema::namespace_infomap& m,
                            ::xercesc::DOMErrorHandler& h,
                            const ::std::wstring& e,
                            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AuthzDecisionStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AuthzDecisionStatement (::xercesc::DOMDocument& d,
                            const ::saml2::assertion::AuthzDecisionStatementType& s,
                            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AuthzDecisionStatementType) == typeid (s))
      {
        if (n.name () == L"AuthzDecisionStatement" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AuthzDecisionStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AuthzDecisionStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AuthzDecisionStatement (const ::saml2::assertion::AuthzDecisionStatementType& s,
                            const ::xml_schema::namespace_infomap& m,
                            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AuthzDecisionStatementType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AuthzDecisionStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AuthzDecisionStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AuthzDecisionStatement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AuthzDecisionStatementType& i)
    {
      e << static_cast< const ::saml2::assertion::StatementAbstractType& > (i);

      // Action
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AuthzDecisionStatementType::Action_const_iterator
             b (i.Action ().begin ()), n (i.Action ().end ());
             b != n; ++b)
        {
          if (typeid (AuthzDecisionStatementType::Action_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Action",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Action",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Evidence
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Evidence ())
        {
          const AuthzDecisionStatementType::Evidence_type& x (*i.Evidence ());
          if (typeid (AuthzDecisionStatementType::Evidence_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Evidence",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Evidence",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, x);
        }
      }

      // Resource
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Resource",
            e));

        a << i.Resource ();
      }

      // Decision
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Decision",
            e));

        a << i.Decision ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AuthzDecisionStatementType >
    _xsd_AuthzDecisionStatementType_type_serializer_init (
      L"AuthzDecisionStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    operator<< (::xercesc::DOMElement& e, const DecisionType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DecisionType& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xsd::cxx::tree::list_stream< wchar_t >& l,
                const DecisionType& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, DecisionType >
    _xsd_DecisionType_type_serializer_init (
      L"DecisionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Action (::std::ostream& o,
            const ::saml2::assertion::ActionType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Action (::std::ostream& o,
            const ::saml2::assertion::ActionType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Action (::std::ostream& o,
            const ::saml2::assertion::ActionType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Action (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::ActionType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Action (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::ActionType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::error_handler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Action (::xercesc::XMLFormatTarget& t,
            const ::saml2::assertion::ActionType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Action (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Action (::xercesc::DOMDocument& d,
            const ::saml2::assertion::ActionType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::ActionType) == typeid (s))
      {
        if (n.name () == L"Action" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Action",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Action",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Action (const ::saml2::assertion::ActionType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::ActionType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Action",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Action",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Action (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActionType& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      // Namespace
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Namespace",
            e));

        a << i.Namespace ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ActionType >
    _xsd_ActionType_type_serializer_init (
      L"ActionType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Evidence (::std::ostream& o,
              const ::saml2::assertion::EvidenceType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Evidence (::std::ostream& o,
              const ::saml2::assertion::EvidenceType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Evidence (::std::ostream& o,
              const ::saml2::assertion::EvidenceType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Evidence (::xercesc::XMLFormatTarget& t,
              const ::saml2::assertion::EvidenceType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Evidence (::xercesc::XMLFormatTarget& t,
              const ::saml2::assertion::EvidenceType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Evidence (::xercesc::XMLFormatTarget& t,
              const ::saml2::assertion::EvidenceType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::wstring& e,
              ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Evidence (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Evidence (::xercesc::DOMDocument& d,
              const ::saml2::assertion::EvidenceType& s,
              ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::EvidenceType) == typeid (s))
      {
        if (n.name () == L"Evidence" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Evidence",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Evidence",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Evidence (const ::saml2::assertion::EvidenceType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::EvidenceType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Evidence",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Evidence",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Evidence (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EvidenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AssertionIDRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::AssertionIDRef_const_iterator
             b (i.AssertionIDRef ().begin ()), n (i.AssertionIDRef ().end ());
             b != n; ++b)
        {
          if (typeid (EvidenceType::AssertionIDRef_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionIDRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionIDRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // AssertionURIRef
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::AssertionURIRef_const_iterator
             b (i.AssertionURIRef ().begin ()), n (i.AssertionURIRef ().end ());
             b != n; ++b)
        {
          if (typeid (EvidenceType::AssertionURIRef_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AssertionURIRef",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AssertionURIRef",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Assertion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::Assertion_const_iterator
             b (i.Assertion ().begin ()), n (i.Assertion ().end ());
             b != n; ++b)
        {
          if (typeid (EvidenceType::Assertion_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Assertion",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Assertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // EncryptedAssertion
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EvidenceType::EncryptedAssertion_const_iterator
             b (i.EncryptedAssertion ().begin ()), n (i.EncryptedAssertion ().end ());
             b != n; ++b)
        {
          if (typeid (EvidenceType::EncryptedAssertion_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedAssertion",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EncryptedAssertion",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EvidenceType >
    _xsd_EvidenceType_type_serializer_init (
      L"EvidenceType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AttributeStatement (::std::ostream& o,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeStatement (::std::ostream& o,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeStatement (::std::ostream& o,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeStatement (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeStatement (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeStatement (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::AttributeStatementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeStatement (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeStatement (::xercesc::DOMDocument& d,
                        const ::saml2::assertion::AttributeStatementType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AttributeStatementType) == typeid (s))
      {
        if (n.name () == L"AttributeStatement" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AttributeStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AttributeStatement",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeStatement (const ::saml2::assertion::AttributeStatementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AttributeStatementType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AttributeStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AttributeStatement",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AttributeStatement (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AttributeStatementType& i)
    {
      e << static_cast< const ::saml2::assertion::StatementAbstractType& > (i);

      // Attribute
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeStatementType::Attribute_const_iterator
             b (i.Attribute ().begin ()), n (i.Attribute ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeStatementType::Attribute_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Attribute",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Attribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // EncryptedAttribute
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeStatementType::EncryptedAttribute_const_iterator
             b (i.EncryptedAttribute ().begin ()), n (i.EncryptedAttribute ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeStatementType::EncryptedAttribute_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptedAttribute",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EncryptedAttribute",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeStatementType >
    _xsd_AttributeStatementType_type_serializer_init (
      L"AttributeStatementType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    Attribute (::std::ostream& o,
               const ::saml2::assertion::AttributeType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Attribute (::std::ostream& o,
               const ::saml2::assertion::AttributeType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Attribute (::std::ostream& o,
               const ::saml2::assertion::AttributeType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Attribute (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AttributeType& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Attribute (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AttributeType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::error_handler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Attribute (::xercesc::XMLFormatTarget& t,
               const ::saml2::assertion::AttributeType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xercesc::DOMErrorHandler& h,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::Attribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Attribute (::xercesc::DOMDocument& d,
               const ::saml2::assertion::AttributeType& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::AttributeType) == typeid (s))
      {
        if (n.name () == L"Attribute" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Attribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Attribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    Attribute (const ::saml2::assertion::AttributeType& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::AttributeType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Attribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"Attribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::Attribute (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AttributeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (AttributeType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // AttributeValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (AttributeType::AttributeValue_const_iterator
             b (i.AttributeValue ().begin ()), n (i.AttributeValue ().end ());
             b != n; ++b)
        {
          if (typeid (AttributeType::AttributeValue_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"AttributeValue",
                L"urn:oasis:names:tc:SAML:2.0:assertion",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"AttributeValue",
              L"urn:oasis:names:tc:SAML:2.0:assertion",
              true, true, e, *b);
        }
      }

      // Name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Name",
            e));

        a << i.Name ();
      }

      // NameFormat
      //
      if (i.NameFormat ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"NameFormat",
            e));

        a << *i.NameFormat ();
      }

      // FriendlyName
      //
      if (i.FriendlyName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"FriendlyName",
            e));

        a << *i.FriendlyName ();
      }
    }

    static
    ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AttributeType >
    _xsd_AttributeType_type_serializer_init (
      L"AttributeType",
      L"urn:oasis:names:tc:SAML:2.0:assertion");


    void
    AttributeValue (::std::ostream& o,
                    const ::xml_schema::type& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeValue (::std::ostream& o,
                    const ::xml_schema::type& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeValue (::std::ostream& o,
                    const ::xml_schema::type& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeValue (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::type& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AttributeValue (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::type& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::error_handler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeValue (::xercesc::XMLFormatTarget& t,
                    const ::xml_schema::type& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xercesc::DOMErrorHandler& h,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::AttributeValue (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AttributeValue (::xercesc::DOMDocument& d,
                    const ::xml_schema::type& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::xml_schema::type) == typeid (s))
      {
        if (n.name () == L"AttributeValue" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AttributeValue",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AttributeValue",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    AttributeValue (const ::xml_schema::type& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::xml_schema::type) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AttributeValue",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"AttributeValue",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::AttributeValue (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAttribute (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::std::ostream& o,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::XMLFormatTarget& t,
                        const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::saml2::assertion::EncryptedAttribute (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedAttribute (::xercesc::DOMDocument& d,
                        const ::saml2::assertion::EncryptedElementType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
      {
        if (n.name () == L"EncryptedAttribute" &&
            n.namespace_ () == L"urn:oasis:names:tc:SAML:2.0:assertion")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptedAttribute",
          L"urn:oasis:names:tc:SAML:2.0:assertion",
          e, n, s);
      }
    }

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedAttribute (const ::saml2::assertion::EncryptedElementType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      try
      {
        ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d;

        if (typeid (::saml2::assertion::EncryptedElementType) == typeid (s))
        {
          d = ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, f);
        }
        else
        {
          ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
            ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

          d = tsm.serialize (
            L"EncryptedAttribute",
            L"urn:oasis:names:tc:SAML:2.0:assertion",
            m, s, f);
        }

        ::saml2::assertion::EncryptedAttribute (*d, s, f);
        return d;
      }
      catch (const ::xsd::cxx::xml::dom::mapping< wchar_t >& e)
      {
        throw ::xsd::cxx::tree::no_namespace_mapping< wchar_t > (e.name ());
      }
      catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
      {
        throw ::xsd::cxx::tree::xsi_already_in_use< wchar_t > ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

