package com.qut.middleware.esoe.sso.impl;


import static org.easymock.EasyMock.createMock;
import static org.easymock.EasyMock.expect;
import static org.easymock.EasyMock.notNull;
import static org.easymock.EasyMock.replay;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.List;
import java.util.SimpleTimeZone;
import java.util.TimeZone;

import org.junit.Before;
import org.junit.Test;
import org.w3._2000._09.xmldsig_.Signature;

import com.qut.middleware.esoe.ConfigurationConstants;
import com.qut.middleware.esoe.crypto.KeyStoreResolver;
import com.qut.middleware.esoe.crypto.impl.KeyStoreResolverImpl;
import com.qut.middleware.esoe.metadata.Metadata;
import com.qut.middleware.esoe.sso.bean.FailedLogout;
import com.qut.middleware.esoe.sso.bean.FailedLogoutRepository;
import com.qut.middleware.esoe.sso.bean.impl.FailedLogoutImpl;
import com.qut.middleware.esoe.sso.bean.impl.FailedLogoutRepositoryImpl;
import com.qut.middleware.esoe.ws.WSClient;
import com.qut.middleware.saml2.StatusCodeConstants;
import com.qut.middleware.saml2.VersionConstants;
import com.qut.middleware.saml2.exception.MarshallerException;
import com.qut.middleware.saml2.handler.Marshaller;
import com.qut.middleware.saml2.handler.impl.MarshallerImpl;
import com.qut.middleware.saml2.identifier.IdentifierCache;
import com.qut.middleware.saml2.identifier.IdentifierGenerator;
import com.qut.middleware.saml2.identifier.impl.IdentifierCacheImpl;
import com.qut.middleware.saml2.identifier.impl.IdentifierGeneratorImpl;
import com.qut.middleware.saml2.schemas.assertion.NameIDType;
import com.qut.middleware.saml2.schemas.protocol.LogoutRequest;
import com.qut.middleware.saml2.schemas.protocol.Response;
import com.qut.middleware.saml2.schemas.protocol.Status;
import com.qut.middleware.saml2.schemas.protocol.StatusCode;
import com.qut.middleware.saml2.validator.SAMLValidator;
import com.qut.middleware.saml2.validator.impl.SAMLValidatorImpl;
import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;

@SuppressWarnings({ "nls", "unqualified-field-access" })
public class LogoutFailureMonitorTest {

	private FailedLogoutMonitor monitor;
	private FailedLogoutRepository failures;
	private IdentifierGenerator idGenerator;
	private String samlID = "_782g0d7fg72r54";
	private String esoeID = "_782g0d7fg72r54";
	private Metadata metadata;
	private KeyStoreResolver keyStoreResolver;
	private WSClient webServiceClient;
	SAMLValidator samlValidator;
	
	int retryInterval = 2;
	int maxAge = 10;
		
	// generated ID of the logout request documents
	String authnID1;
	String authnID2;
	String authnID3;
	String authnID4;
	String authnID5;
	
	@Before
	public void setUp() throws Exception
	{	
		String keyStorePath = System.getProperty("user.dir") + File.separator + "tests" + File.separator + "testdata" + File.separator + "testskeystore.ks";
		String keyStorePassword = "Es0EKs54P4SSPK";
		String esoeKeyAlias = "esoeprimary";
		String esoeKeyPassword = "Es0EKs54P4SSPK";
		
		this.keyStoreResolver = new KeyStoreResolverImpl(new File(keyStorePath), keyStorePassword, esoeKeyAlias, esoeKeyPassword);
		
		IdentifierCache idCache = new IdentifierCacheImpl();
		this.idGenerator = new IdentifierGeneratorImpl(idCache);
			
		// setup some authz failures and add to failure repository
		failures = new FailedLogoutRepositoryImpl();	
		
		this.metadata = createMock(Metadata.class);
		expect(this.metadata.resolveKey("esoeprimary")).andReturn(this.keyStoreResolver.getPublicKey()).anyTimes();
		replay(metadata);
		
		// set saml id as generated by the id generator we ill use so it passes validation
		this.samlID = this.idGenerator.generateSAMLID();
		
		this.webServiceClient = createMock(WSClient.class);
			
		samlValidator = new SAMLValidatorImpl(idCache, Integer.MAX_VALUE/1000);
				
	}

	@Test
	public final void testCacheUpdateFailureMonitorImpl() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, metadata, this.keyStoreResolver, this.idGenerator, webServiceClient, retryInterval, maxAge);		
		
		assertTrue(this.monitor.isAlive());
	}

	/* Test the bahaviour of the monitor when a valid failure exists. Essentially what we have is: 
	 * 
	 * 2 failures added to repository.
	 * 1 is invalid and should be removed on first poll, without calling the singleLogout service.
	 * 1 is valid and should be removed on first poll becuse it was sent succesfully
	 * 
	 */
	@SuppressWarnings("nls")
	@Test
	public final void testBehaviour1() throws Exception
	{			
		// we can't set the expected value of the request document in the call to singleLogout(), because
		// the monitor will regenerate the request document. As such, we can only ever test for ONE failure
		// or ONE success (this is because we cannot differentiate between failures and so can not correctly
		// set the inResponseTo field when generating responses). 
		
		// no timestamp == invalid. This should be removed from the repo by monitor BEFORE the call to
		// singleLogout is made, and so should not affect our mock invocations.
		FailedLogout failure1 = new FailedLogoutImpl();
		failure1.setEndPoint("blah.com");
		// generate a SAML authnID to use
		authnID1 = this.idGenerator.generateSAMLID();
		failure1.setRequestDocument(this.generateLogoutRequest(authnID1));
		
		// represents a successful endpoint
		FailedLogout failure2 = new FailedLogoutImpl();
		failure2.setEndPoint("successful.com");
		// generate a SAML authnID to use
		authnID2 = this.idGenerator.generateSAMLID();
		failure2.setRequestDocument(this.generateLogoutRequest(authnID2));
		failure2.setTimeStamp(new Date(System.currentTimeMillis()));
		
		failures.add(failure1);
		failures.add(failure2);
	
		// return a success response when the singleLogout call is made
		expect(webServiceClient.singleLogout((byte[])notNull(), (String)notNull())).andReturn(this.generateSuccessLogoutResponse(authnID2)).once();
		replay(webServiceClient);
	
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, metadata, this.keyStoreResolver, this.idGenerator, webServiceClient, retryInterval, maxAge);		
		
		assertTrue(this.monitor.isAlive());		
		
		// before first poll both should be in repos
		assertEquals("Failure repository size is incorrect", 2, this.failures.getSize());
		
		// must be longer than retry interval set in constructor
		Thread.sleep(5000);
				
		// after first poll no failures should remain, as both the invalid and successful ones have been removed 
		assertEquals("Failure repository size is incorrect", 0, this.failures.getSize());
	}
	
	/* One failure should be removed from the repository, as the failure date has not been set.
	 * 
	 */
	@SuppressWarnings("nls")
	@Test
	public final void testBehaviour2() throws Exception
	{				
		// we can't set the expected value of the request document in the call to singleLogout(), because
		// the monitor will regenerate the request document. As such, we can only ever test for ONE failure
		// or ONE success (this is because we cannot differentiate between failures and so can not correctly
		// set the inResponseTo field when generating responses). 
		
		// no request document == invalid. This should be removed from the repo by monitor BEFORE the call to
		// singleLogout is made, and so should not affect our mock invocations.
		FailedLogout failure1 = new FailedLogoutImpl();
		failure1.setEndPoint("blah.com");
		failure1.setTimeStamp(new Date(System.currentTimeMillis()));
		// generate a SAML authnID to use
		authnID1 = this.idGenerator.generateSAMLID();
		
		// no endpoint == invalid. This should be removed from the repo by monitor BEFORE the call to
		// singleLogout is made, and so should not affect our mock invocations.
		FailedLogout failure2 = new FailedLogoutImpl();
		// generate a SAML authnID to use
		authnID1 = this.idGenerator.generateSAMLID();
		failure2.setRequestDocument(this.generateLogoutRequest(authnID1));
		failure2.setTimeStamp(new Date(System.currentTimeMillis()));
			
		// represents an unsuccessful endpoint
		FailedLogout failure3 = new FailedLogoutImpl();
		failure3.setEndPoint("unsuccessful.com");
		// generate a SAML authnID to use
		authnID2 = this.idGenerator.generateSAMLID();
		failure3.setRequestDocument(this.generateLogoutRequest(authnID2));
		failure3.setTimeStamp(new Date(System.currentTimeMillis()));
		
		failures.add(failure1);
		failures.add(failure2);
		failures.add(failure3);
		
		// return a failure (invalid) response when the singleLogout call is made. 
		expect(webServiceClient.singleLogout((byte[])notNull(), (String)notNull())).andReturn(this.generateFailedLogoutResponse(authnID2)).atLeastOnce();
		replay(webServiceClient);
	
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, metadata, this.keyStoreResolver, this.idGenerator, webServiceClient, retryInterval, maxAge);		
		
		assertTrue(this.monitor.isAlive());		
		
		// before first poll all 3 should be in repo
		assertEquals("Failure repository size is incorrect", 3, this.failures.getSize());
		
		// must be longer than retry interval set in constructor
		Thread.sleep(5000);
				
		// after first poll only the one failure should remain, as both the invalid ones have been removed 
		assertEquals("Failure repository size is incorrect", 1, this.failures.getSize());
		
		// the unsuccessful send should remain until it expires (int maxAge = 10 seconds)
		Thread.sleep(8000);
				
		// all entries should be expired or otherwise removed
		assertEquals("Failure repository size is incorrect", 0, this.failures.getSize());
		
	}
	
	
	@Test
	public final void testShutdown() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, metadata, this.keyStoreResolver, this.idGenerator, webServiceClient, retryInterval, maxAge);		
		
		Thread.sleep(10000);
		
		this.monitor.shutdown();
		
		Thread.sleep(10000);
		
		assertTrue(!this.monitor.isAlive());
	}
	
	/*
	 * Generate the Logout Response to be sent back to the ESOE.
	 * 
	 */
	private byte[] generateSuccessLogoutResponse(String inResponseTo)
			throws MarshallerException
	{		
		byte[] responseDocument = null;

		NameIDType issuer = new NameIDType();
		issuer.setValue("some.spep.identifier");

		Status status = new Status();
		StatusCode statusCode = new StatusCode();
		statusCode.setValue(StatusCodeConstants.success);
		status.setStatusCode(statusCode);
		status.setStatusMessage("test recieved");

//		 create a local id generator so we dont get collisions in our response ID
		IdentifierCache idCache2 = new IdentifierCacheImpl();
		IdentifierGenerator localIdGenerator = new IdentifierGeneratorImpl(idCache2);
		
		Response response = new Response();
		response.setID(localIdGenerator.generateSAMLID());
		response.setInResponseTo(inResponseTo);
		response.setIssueInstant(new XMLGregorianCalendarImpl(new GregorianCalendar()));
		response.setIssuer(issuer);
		response.setSignature(new Signature());
		response.setStatus(status);
		response.setVersion(VersionConstants.saml20);

		String MAR_PKGNAMES = LogoutRequest.class.getPackage().getName();
		String[] logoutSchemas = new String[] { ConfigurationConstants.samlProtocol };
		
		String keyStorePath = System.getProperty("user.dir") + File.separator + "tests" + File.separator + "testdata" + File.separator + "testskeystore.ks";
		String keyStorePassword = "Es0EKs54P4SSPK";
		String esoeKeyAlias = "esoeprimary";
		String esoeKeyPassword = "Es0EKs54P4SSPK";
		
		KeyStoreResolver keyStoreResolver = new KeyStoreResolverImpl(new File(keyStorePath), keyStorePassword, esoeKeyAlias, esoeKeyPassword);
		
		Marshaller logoutResponseMarshaller = new MarshallerImpl<Response>(MAR_PKGNAMES, logoutSchemas,
				keyStoreResolver.getKeyAlias(), keyStoreResolver.getPrivateKey());
		
		responseDocument = logoutResponseMarshaller.marshallSigned(response);

		return responseDocument;
	}
	
	
	/*
	 * Generate the Logout Response to be sent back to the ESOE.
	 * 
	 */
	private byte[] generateFailedLogoutResponse(String inResponseTo) throws MarshallerException
	{		
		byte[] responseDocument = null;

		NameIDType issuer = new NameIDType();
		issuer.setValue("some.spep.identifier");

		Status status = new Status();
		StatusCode statusCode = new StatusCode();
		statusCode.setValue(StatusCodeConstants.requester);
		status.setStatusCode(statusCode);
		status.setStatusMessage("test recieved");

		// create a local id generator so we dont get collisions in our response ID
		IdentifierCache idCache2 = new IdentifierCacheImpl();
		IdentifierGenerator localIdGenerator = new IdentifierGeneratorImpl(idCache2);
		
		Response response = new Response();
		response.setID(localIdGenerator.generateSAMLID());
		response.setInResponseTo("invalidID");
		response.setIssueInstant(new XMLGregorianCalendarImpl(new GregorianCalendar()));
		response.setIssuer(issuer);
		response.setSignature(new Signature());
		response.setStatus(status);
		response.setVersion(VersionConstants.saml20);

		String MAR_PKGNAMES = LogoutRequest.class.getPackage().getName();
		String[] logoutSchemas = new String[] { ConfigurationConstants.samlProtocol };
		
		String keyStorePath = System.getProperty("user.dir") + File.separator + "tests" + File.separator + "testdata" + File.separator + "testskeystore.ks";
		String keyStorePassword = "Es0EKs54P4SSPK";
		String esoeKeyAlias = "esoeprimary";
		String esoeKeyPassword = "Es0EKs54P4SSPK";
		
		KeyStoreResolver keyStoreResolver = new KeyStoreResolverImpl(new File(keyStorePath), keyStorePassword, esoeKeyAlias, esoeKeyPassword);
		
		Marshaller logoutResponseMarshaller = new MarshallerImpl<Response>(MAR_PKGNAMES, logoutSchemas,
				keyStoreResolver.getKeyAlias(), keyStoreResolver.getPrivateKey());
		
		responseDocument = logoutResponseMarshaller.marshallSigned(response);

		return responseDocument;
	}
	
	
	@Test (expected = IllegalArgumentException.class)
	public void testConstruction1() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(null, samlValidator, metadata, keyStoreResolver, new IdentifierGeneratorImpl(new IdentifierCacheImpl()), webServiceClient, retryInterval, maxAge);		
	}
	
	@Test (expected = IllegalArgumentException.class)
	public void testConstruction2() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, null, metadata, keyStoreResolver, new IdentifierGeneratorImpl(new IdentifierCacheImpl()), webServiceClient, retryInterval, maxAge);		
	}
	
	@Test (expected = IllegalArgumentException.class)
	public void testConstruction3() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, null, keyStoreResolver, new IdentifierGeneratorImpl(new IdentifierCacheImpl()), webServiceClient, retryInterval, maxAge);		
	}
	
	@Test (expected = IllegalArgumentException.class)
	public void testConstruction4() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, samlValidator,  metadata,  null, new IdentifierGeneratorImpl(new IdentifierCacheImpl()), webServiceClient, retryInterval, maxAge);		
	}
	
	@Test (expected = IllegalArgumentException.class)
	public void testConstruction5() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, metadata, keyStoreResolver, null , webServiceClient, retryInterval, maxAge);		
	}
	
	@Test (expected = IllegalArgumentException.class)
	public void testConstruction6() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, metadata, keyStoreResolver, new IdentifierGeneratorImpl(new IdentifierCacheImpl()), webServiceClient,  -1, maxAge);		
	}
	
	@Test (expected = IllegalArgumentException.class)
	public void testConstruction7() throws Exception
	{
		this.monitor = new FailedLogoutMonitor(failures, samlValidator, metadata, keyStoreResolver, new IdentifierGeneratorImpl(new IdentifierCacheImpl()), webServiceClient,  retryInterval, -933);		
	}
	
	private byte[] generateLogoutRequest(String samlAuthnID) throws MarshallerException
	{
		byte[] requestDocument = null;
		LogoutRequest request = new LogoutRequest();
				
		NameIDType subject = new NameIDType();
		NameIDType issuer = new NameIDType();
		subject.setValue(samlAuthnID);
		request.setNameID(subject);
		request.setID(samlAuthnID);
		request.setReason("Test logout request");
		request.setVersion(VersionConstants.saml20);
		issuer.setValue(this.esoeID);
		request.setIssuer(issuer);
		
		// Timestamps MUST be set to UTC, no offset
		TimeZone utc = new SimpleTimeZone(0, ConfigurationConstants.timeZone); 
		GregorianCalendar cal = new GregorianCalendar(utc);
		request.setIssueInstant(new XMLGregorianCalendarImpl(cal));
		
		request.setSignature(new Signature());
		
		List<String>sessionIndicies = null;
		if(sessionIndicies != null)
		{
			Iterator<String> iterator = sessionIndicies.iterator();
			while(iterator.hasNext())
			{
				String sessionIndex = iterator.next();
				if(sessionIndex != null)
					request.getSessionIndices().add(sessionIndex);
			}
			
		}
		
		String[] schemas = new String[] { ConfigurationConstants.samlProtocol };
		String MAR_PKGNAMES = LogoutRequest.class.getPackage().getName();
		
		Marshaller<LogoutRequest> logoutRequestMarshaller = new MarshallerImpl<LogoutRequest>(MAR_PKGNAMES, schemas, this.keyStoreResolver.getKeyAlias(), this.keyStoreResolver.getPrivateKey());
		
		requestDocument = logoutRequestMarshaller.marshallSigned(request);
	
		return requestDocument;
	}
	
}
